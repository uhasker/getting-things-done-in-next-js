<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Asynchronous Programming</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title-page.html">Getting Things Done in Next.js</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">Acknowledgments</a></li><li class="chapter-item expanded "><a href="../chapter1/index.html"><strong aria-hidden="true">1.</strong> A Brief Introduction to JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter1/01-hello-world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../chapter1/02-primitive-data-types.html"><strong aria-hidden="true">1.2.</strong> Primitive Data Types</a></li><li class="chapter-item expanded "><a href="../chapter1/03-arrays-and-objects.html"><strong aria-hidden="true">1.3.</strong> Arrays and Objects</a></li><li class="chapter-item expanded "><a href="../chapter1/04-control-flow.html"><strong aria-hidden="true">1.4.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../chapter1/05-functions.html"><strong aria-hidden="true">1.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../chapter1/06-error-handling.html"><strong aria-hidden="true">1.6.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../chapter1/07-basic-datastructures.html"><strong aria-hidden="true">1.7.</strong> Basic Data Structures</a></li><li class="chapter-item expanded "><a href="../chapter1/08-functional-thinking.html"><strong aria-hidden="true">1.8.</strong> Functional Thinking</a></li><li class="chapter-item expanded "><a href="../chapter1/09-asynchronous-programming.html" class="active"><strong aria-hidden="true">1.9.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapter1/10-modules.html"><strong aria-hidden="true">1.10.</strong> Modules</a></li><li class="chapter-item expanded "><a href="../chapter1/11-writing-decent-code.html"><strong aria-hidden="true">1.11.</strong> Writing Decent Code</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter2/index.html"><strong aria-hidden="true">2.</strong> Leveling Up with TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter2/01-why-typescript.html"><strong aria-hidden="true">2.1.</strong> Why TypeScript?</a></li><li class="chapter-item expanded "><a href="../chapter2/02-basic-types.html"><strong aria-hidden="true">2.2.</strong> Basic Types</a></li><li class="chapter-item expanded "><a href="../chapter2/03-annotating-functions.html"><strong aria-hidden="true">2.3.</strong> Annotating Functions</a></li><li class="chapter-item expanded "><a href="../chapter2/04-union-types.html"><strong aria-hidden="true">2.4.</strong> Union Types</a></li><li class="chapter-item expanded "><a href="../chapter2/05-generics.html"><strong aria-hidden="true">2.5.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../chapter2/06-configuring-typescript.html"><strong aria-hidden="true">2.6.</strong> Configuring TypeScript</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter3/index.html"><strong aria-hidden="true">3.</strong> Networking Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter3/01-ips-ports-and-domains.html"><strong aria-hidden="true">3.1.</strong> IPs, Ports and Domains</a></li><li class="chapter-item expanded "><a href="../chapter3/02-an-http-primer.html"><strong aria-hidden="true">3.2.</strong> An HTTP Primer</a></li><li class="chapter-item expanded "><a href="../chapter3/03-more-on-http.html"><strong aria-hidden="true">3.3.</strong> More on HTTP</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter4/index.html"><strong aria-hidden="true">4.</strong> A Vanilla Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter4/01-hypertext-markup-language.html"><strong aria-hidden="true">4.1.</strong> Hypertext Markup Language</a></li><li class="chapter-item expanded "><a href="../chapter4/02-marking-up-text.html"><strong aria-hidden="true">4.2.</strong> Marking Up Text</a></li><li class="chapter-item expanded "><a href="../chapter4/03-hyperlinks-and-images.html"><strong aria-hidden="true">4.3.</strong> Hyperlinks and Images</a></li><li class="chapter-item expanded "><a href="../chapter4/04-the-document-object-model.html"><strong aria-hidden="true">4.4.</strong> The Document Object Model</a></li><li class="chapter-item expanded "><a href="../chapter4/05-web-forms.html"><strong aria-hidden="true">4.5.</strong> Web Forms</a></li><li class="chapter-item expanded "><a href="../chapter4/06-a-simple-client.html"><strong aria-hidden="true">4.6.</strong> A Simple Client</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter5/index.html"><strong aria-hidden="true">5.</strong> Adding Spice with React</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter5/01-react-components.html"><strong aria-hidden="true">5.1.</strong> React Components</a></li><li class="chapter-item expanded "><a href="../chapter5/02-react-state.html"><strong aria-hidden="true">5.2.</strong> React State</a></li><li class="chapter-item expanded "><a href="../chapter5/03-react-effects.html"><strong aria-hidden="true">5.3.</strong> React Effects</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter6/index.html"><strong aria-hidden="true">6.</strong> Moving to the Server with Next.js</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter6/01-setup.html"><strong aria-hidden="true">6.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../chapter6/02-pages-and-layouts.html"><strong aria-hidden="true">6.2.</strong> Pages and Layouts</a></li><li class="chapter-item expanded "><a href="../chapter6/03-more-on-routes.html"><strong aria-hidden="true">6.3.</strong> More on Routes</a></li><li class="chapter-item expanded "><a href="../chapter6/04-server-and-client-components.html"><strong aria-hidden="true">6.4.</strong> Server and Client Components</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter7/index.html"><strong aria-hidden="true">7.</strong> Becoming Pretty with Tailwind CSS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter7/01-setup.html"><strong aria-hidden="true">7.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../chapter7/02-typography-utilities.html"><strong aria-hidden="true">7.2.</strong> Typography Utilities</a></li><li class="chapter-item expanded "><a href="../chapter7/03-background-utilities.html"><strong aria-hidden="true">7.3.</strong> Background Utilities</a></li><li class="chapter-item expanded "><a href="../chapter7/04-size-utilities.html"><strong aria-hidden="true">7.4.</strong> Size Utilities</a></li><li class="chapter-item expanded "><a href="../chapter7/05-border-utilities.html"><strong aria-hidden="true">7.5.</strong> Border Utilities</a></li><li class="chapter-item expanded "><a href="../chapter7/06-spacing-utilities.html"><strong aria-hidden="true">7.6.</strong> Spacing Utilities</a></li><li class="chapter-item expanded "><a href="../chapter7/07-flexbox.html"><strong aria-hidden="true">7.7.</strong> Flexbox</a></li><li class="chapter-item expanded "><a href="../chapter7/08-grid.html"><strong aria-hidden="true">7.8.</strong> Grid</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter8/index.html"><strong aria-hidden="true">8.</strong> Persistence with SQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter8/01-setup.html"><strong aria-hidden="true">8.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../chapter8/02-inserting-updating-and-deleting-data.html"><strong aria-hidden="true">8.2.</strong> Inserting, Updating and Deleting Data</a></li><li class="chapter-item expanded "><a href="../chapter8/03-selecting-rows.html"><strong aria-hidden="true">8.3.</strong> Selecting Data</a></li><li class="chapter-item expanded "><a href="../chapter8/04-multiple-tables.html"><strong aria-hidden="true">8.4.</strong> Multiple Tables</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter9/index.html"><strong aria-hidden="true">9.</strong> Typesafe SQL with Drizzle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter9/01-setup.html"><strong aria-hidden="true">9.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../chapter9/02-inserting-updating-and-deleting-data.html"><strong aria-hidden="true">9.2.</strong> Inserting, Updating and Deleting Data</a></li><li class="chapter-item expanded "><a href="../chapter9/03-selecting-rows.html"><strong aria-hidden="true">9.3.</strong> Selecting Data</a></li><li class="chapter-item expanded "><a href="../chapter9/04-multiple-tables.html"><strong aria-hidden="true">9.4.</strong> Multiple Tables</a></li><li class="chapter-item expanded "><a href="../chapter9/05-migrations.html"><strong aria-hidden="true">9.5.</strong> Migrations</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter10/index.html"><strong aria-hidden="true">10.</strong> The Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter10/01-setup.html"><strong aria-hidden="true">10.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../chapter10/02-task-page.html"><strong aria-hidden="true">10.2.</strong> Task Page</a></li><li class="chapter-item expanded "><a href="../chapter10/03-styling-the-task-page.html"><strong aria-hidden="true">10.3.</strong> Styling the Task Page</a></li><li class="chapter-item expanded "><a href="../chapter10/04-project-page.html"><strong aria-hidden="true">10.4.</strong> Project Page</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h2>
<div style="text-align: right"> <i> - proverb Ancient Chinese <br> is hard Asynchronous programming </i> </div>
<h3 id="why-asynchronous-programming"><a class="header" href="#why-asynchronous-programming">Why Asynchronous Programming?</a></h3>
<p>We often need to execute long-running operations (especially in web development).
For example, we might need to fetch a resource from a server or request camera access from a user.
In the first case, we need to wait for all the network packets to arrive, which might take a long time depending on your network connectivity.
In the second case, we need to wait for the user to grant us access to the resource we require.</p>
<p>We want do be able to do this without "blocking".
To accomplish this, we need to break with the "synchronous" programming model where statements are executed one after another.</p>
<p>Consider the following example:</p>
<pre><code class="language-js">function getTask(taskId) {
  return `Task with ID ${taskId}`;
}

const task = getTask(0);
console.log(task);
</code></pre>
<p>The <code>getTask</code> function is a <strong>synchronous function</strong>.
This means that the calling code (i.e. <code>const task = getTask(0)</code>) has to wait until <code>getTask</code> has finished its work to continue.
That is all fine and dandy here, given that <code>getTask</code> should (hopefully) complete its "work" very fast.</p>
<p>But what if <code>getTask</code> represents a long-running operation, like retrieving a task from a server?</p>
<pre><code class="language-js">function getTask(taskId) {
  return retrieveTaskFromServer(taskId);
}

const task = getTask(0);
console.log(task);
</code></pre>
<p>Now the calling code has to wait for the request to complete before it can do anything else.
This will become a huge problem in the browser environment, given that synchronous functions like <code>getTask</code> are "blocking".
Therefore as long as <code>getTask</code> is executing, no other code will be able to run, including code that handles user events.
This means that the user will not be able to select text, click buttons or do anything else with the website, i.e. the website "hangs".</p>
<p>Of course we want to avoid such a nuisance since this will result in the much dreaded <em>negative user experience</em>.</p>
<blockquote>
<p>If you ever clicked a button on a website and everything just freezes for three seconds, this often means that some developer wrote a synchronous function that handles a long-running task.</p>
</blockquote>
<p>We need a mechanism to start a (potentially) long-running task and still be able to do other things (like respond to user events) instead of blocking until the task is finished.
Once the task is completed, our program needs to be notified with result.</p>
<p>Here is a step-by-step breakdown of what we want to accomplish:</p>
<ol>
<li>Call a function that starts a long-running operation.</li>
<li>The function should return immediately, so that the "main" program is able to do something else.</li>
<li>Once the long-running operation is completed, the "main" program should be notified.</li>
</ol>
<blockquote>
<p>In case you think to yourself right now "this all sounds very complicated and when do I need long-running tasks anyway, maybe I'll skip this section" - don't.
Almost every project you'll write (essentially when doing web development) will contain asynchronous code.</p>
</blockquote>
<h3 id="promises"><a class="header" href="#promises">Promises</a></h3>
<p>The central object in asynchronous JavaScript is the <strong>promise</strong>.
A promise represents the eventual completion (or failure) of an asynchronous operation.
Now that you are sufficiently confused by this opaque definition, we can move on to an actually useful explanation.</p>
<p>Basically a promise is a like an IOU document - it "promises" you that it is currently working on some long-running operation and that it will eventually get back to you with the result of that long-running operation.</p>
<p>To give another metaphor, consider the process of ordering a hamburger at SyncMcBurgers.
For simplicity (and improved metaphormaking) we will pretend that SyncMcBurgers only has one counter.</p>
<p>In a perfect “synchronous” world, you would walk up, tell your order to the hardworking employee of the restaurant and then he would immediately create the hamburger right then and there.
However, unless SyncMcBurgers has rediscovered the ancient secret art of instant burgermaking using dark magic, the preparation of a hamburger does not happen immediately (it's a "long-running operation").</p>
<p>Therefore, in reality the following process happen when you try to order something at SyncMcBurgers.
You walk up to the counter and the employee takes your order (a hamburger) and starts preparing the hamburger right there at the counter in front of you.
In the meantime, you have to wait at the counter until the hamburger is finished.</p>
<p>This process has an obvious problem - both you and the employee now block the entire restaurant from doing anything else (remember, there is only a single counter).
No other customer can try to order anything (because you are standing at the counter) and no other employee can take an order anyway (because the employee serving you is blocking the counter with his hamburger preparation).
This doesn't sound like a recipe for success.</p>
<p>Luckily, there is a change in management and SyncMcBurgers rebrands as AsyncMcBurgers.
The important difference between SyncMcBurgers and the new and improved AsyncMcBurgers is a change in the burger ordering process.</p>
<blockquote>
<p>There is still only one counter though.
After all the managers at AsyncMcBurgers want to respect our metaphor.</p>
</blockquote>
<p>The new process looks as follows.
You walk up to the counter, an employee takes your order and hands it to the kitchen.
Instead of the burger, he hands you receipt, which is a <em>promise</em> (get it?) that you will get your burger after some time.
Now you don't have to stand in front of the counter waiting for the employee to finish.
Instead you take your receipt, leave the counter and the next customer may order.</p>
<p>In case you missed it, this is how every normal fast food restaurant in the world operates - and for good reason (except that normal fast food restaurants usually have more than a single counter).</p>
<p>Armed with these examples, we can now actually understand the definition of a promise.
Remember, that a promise represents the eventual completion (or failure) of an asynchronous operation.</p>
<p>In this example, the asynchronous operation is the preparation of the hamburger.
This asynchronous operation will eventually complete (the hamburger will be prepared) or fail (there will a problem during the hamburger preparation).
The order receipt that you get represents the eventual (i.e. probably not immediate) completion of the burger prepartion.</p>
<p>Now that we made sense of the definition, we can introduce the three states of a promise:</p>
<p>We say that a promise is <strong>pending</strong> when it has been created, but the asynchronous operation it represents has not been completed yet.
This would be the case when you already received the order receipt but you're still waiting for the hamburger.</p>
<p>We say that a promise is <strong>fulfilled</strong> when the asynchronous operation it represents has been successfully completed.
This would be the case when the hamburger is successfully prepared and handed to you.</p>
<p>We say that a promise is <strong>rejected</strong> when the asynchronous operation it represents has failed.
This would be the case when (for example) the kitchen spontaneously combusts due to the ongoing AsyncMcBurger dark magic experiments in the backroom lab.</p>
<p>Finally a promise is <strong>settled</strong> when is either fulfilled or rejected, but not pending.</p>
<p>Promises also allow us to associate <strong>handlers</strong> (also called handler functions) with the eventual success or failure.
For example, we could say that when the hamburger is prepared, we want to eat it (or throw it in the trash, which might actually be the preferrable alternative in some cases).</p>
<h3 id="working-with-promises-in-javascript"><a class="header" href="#working-with-promises-in-javascript">Working with Promises in JavaScript</a></h3>
<p>Let's work through an example - fetching a resource from a server via HTTP.
The HTTP protocol will be discussed in more detail later, but basically it enables us to send a request to a server and get a response.
Since network packets don't arrive immediately, this can take a while, so we are dealing with a "long-running operation".</p>
<p>Both the browser as well as Node.js allow us to retrieve a resource from the network via the asynchronous <code>fetch</code> function.
Consider this example:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url).then((response) =&gt; console.log(response));
</code></pre>
<p>This will log the response object we get from <code>https://jsonplaceholder.typicode.com/todos/1</code> to the console (we will learn how to deal with this response object in a second).</p>
<p>We can rewrite the above example in a more explicit manner:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
fetchPromise.then((response) =&gt; console.log(response));
console.log(fetchPromise);
</code></pre>
<p>This is what happens:</p>
<ol>
<li>We call <code>fetch</code> which <em>immediately</em> returns a <em>pending</em> promise.</li>
<li>We pass a handler function into the <code>then</code> method.
The handler function will be called when the <code>fetch</code> succeeds (i.e. the promise returned by <code>fetch</code> is fulfilled).</li>
<li>After a while the <code>fetch</code> succeeds, <code>fetchPromise</code> is fulfilled and the <code>response</code> object is logged.</li>
</ol>
<p>It is important to note <code>fetch</code> returns immediately.
The return value of <code>fetch</code> is a pending promise (that will eventually settle with either a response value or some kind of error).</p>
<p>This is why <code>console.log(fetchPromise)</code> is executed before <code>console.log(response)</code> and you see the following output in the console:</p>
<pre><code>Promise { &lt;pending&gt; }
Response {
    ...
}
</code></pre>
<p>Additionally the <code>then</code> method <em>also</em> returns immediately, after it has attached the handler function to the <code>fetchPromise</code>.
However the execution of the <em>handler function</em> happens only after the promise returned by fetch is fulfilled.</p>
<p>On one hand this is what we want - while we are waiting for the network request to complete, we can do other stuff (like logging <code>fetchPromise</code>).</p>
<p>On the other hand this is the reason why asynchronous programming is often so confusing to beginners - it "breaks" the regular programming model.
When we write synchronous code, we just execute statements one after another.
With asynchronous code this is no longer the case - here we "register" a function to be executed later, do something else, and then at some point the registered function is executed.</p>
<h3 id="chaining-promises"><a class="header" href="#chaining-promises">Chaining Promises</a></h3>
<p>The <code>response</code> object is not terribly useful by itself.
Let's retrieve the "actual" response which is a JSON object.
Here is how the JSON we get from <code>https://jsonplaceholder.typicode.com/todos/1</code> looks like:</p>
<pre><code class="language-json">{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
</code></pre>
<p>The <code>response</code> object has a <code>json</code> method to retrieve the JSON contained in a response.
However, the <code>json</code> method is also asynchronous, so we are again dealing with promises.</p>
<p>Your first instinct might be to write something like this:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
const jsonPromise = fetchPromise.then((response) =&gt; {
  const jsonPromise = response.json();
  jsonPromise.then((json) =&gt; console.log(json));
});
</code></pre>
<p>This is <em>technically</em> not wrong, but it's ugly.
Basically every time we need to add an asynchronous operation to our code that depends on the result of a previous asynchronous operation, we would need to add one level of nesting which will quickly become unreadable.</p>
<p>Luckily for us, the benevolent god-emperors of JavaScript have eliminated this problem by making <code>then</code> return a promise that "resolves" to the result of the handler function.
Therefore instead of nesting promises, we can <strong>chain</strong> promises:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
const jsonPromise = fetchPromise.then((response) =&gt; response.json());
jsonPromise.then((json) =&gt; console.log(json));
</code></pre>
<p>This is (quite appropriately) called <strong>promise chaining</strong>.</p>
<p>Here is what happens, when we call this code:</p>
<ol>
<li>The <code>fetch</code> method immediately returns a pending promise <code>fetchPromise</code>.</li>
<li>The <code>then</code> method of <code>fetchPromise</code> attaches the handler function <code>(response) =&gt; response.json()</code> to the <code>fetchPromise</code> and also immediately returns.
This time the return value is the pending promise <code>jsonPromise</code>.</li>
<li>The <code>then</code> method of <code>jsonPromise</code> attaches the handler function <code>(json) =&gt; console.log(json)</code> and also immediately returns another pending promise (which we ignore here).</li>
<li>The network request initiated by <code>fetch</code> finishes and <code>fetchPromise</code> is fulfilled (with a <code>Response</code> object as its fulfillment value).</li>
<li>Now that <code>fetchPromise</code> is fulfilled the handler function <code>(response) =&gt; response.json()</code> is kicked off and attempts to parse the response as a JSON object.</li>
<li>At some point the JSON parsing is finished and <code>jsonPromise</code> is fulfilled.</li>
<li>Now that <code>jsonPromise</code> is fulfilled the handler function <code>(json) =&gt; console.log(json)</code> is kicked off and the JSON object is logged to the console.</li>
</ol>
<p>You can basically think of a chain as being executed in two stages.
In the first stage the promises are set up and the handler functions are attached using the <code>then</code> method.
This stage happens immediately.
In the second stage the promises are settled and the attached handler functions are actually executed.
This stage can take quite some time, depending on how long the tasks we want to accomplish take.</p>
<blockquote>
<p>This explanation is the most important part of this entire section.
You should pause and think about this promise chain for a second (or maybe even multiple seconds).
If you understand this point, you (mostly) understand asynchronous programming.</p>
</blockquote>
<p>Note that we can rewrite our promise chain to be a bit more elegant:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; response.json())
  .then((json) =&gt; console.log(json));
</code></pre>
<h3 id="handling-errors"><a class="header" href="#handling-errors">Handling Errors</a></h3>
<p>The above code is completely missing one very important point - error handling.
Most long-running operations (especially those that involve external resources like a network or a file system) can fail.
For example <code>fetch</code> will fail (and <code>fetchPromise</code> will thus be rejected) if your network is down.</p>
<p>You can test this - turn off your network and execute the above code again.
You will get a weird error that looks approximately like this:</p>
<pre><code>TypeError: fetch failed
    at Object.fetch (node:internal/deps/undici/undici:11457:11)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5) {
  cause: Error: getaddrinfo EAI_AGAIN jsonplaceholder.typicode.com
      at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:107:26) {
    errno: -3001,
    code: 'EAI_AGAIN',
    syscall: 'getaddrinfo',
    hostname: 'jsonplaceholder.typicode.com'
  }
}
</code></pre>
<p>Additionally, we will usually want to throw an error if <code>fetch</code> itself succeeds, but the status of the response is "not ok" (we will return to this in more detail in the section about HTTP):</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response.json();
  })
  .then((json) =&gt; console.log(json));
</code></pre>
<p>We want to be able to catch all the errors that can happen and log an error message to the console.
The Promise API gives us the appropriately named <code>catch</code> method to accomplish this.
We simply add a catch handler to the end of our promise chain - it will be called when any of the asynchronous operations fail:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response.json();
  })
  .then((json) =&gt; console.log(json))
  .catch((error) =&gt; console.error(error));
</code></pre>
<p>Turn off your network and try running the <code>fetch</code> again.
You will now see an appropriately logged error.
Instead of just crashing, you program can now do something else (like showing an error modal to the user and informing him that something went wrong).</p>
<h3 id="async-and-await"><a class="header" href="#async-and-await">Async and Await</a></h3>
<p>Promises are great, but as discussed, the are not completely intuitive.
We can use <code>async</code> and <code>await</code> keywords to simplify asynchronous code and make it look more like synchronous code.
To this end, we can declare an <code>async</code> function and then use the <code>await</code> keyword to wait for a promise and get its fulfillment value:</p>
<pre><code class="language-js">async function fetchTask(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    const json = await response.json();
    return json;
  } catch (error) {
    console.error(`Could not fetch URL ${url}`);
  }
}

const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetchTask(url).then((json) =&gt; console.log(json));
</code></pre>
<p>Note that for some runtimes you can only use <code>await</code> inside an <code>async</code> function.
This is why we use <code>then</code> with <code>fetchTask</code> instead of <code>await</code>ing the promise returned by <code>fetchTask</code>.</p>
<h2 id="the-void-operator"><a class="header" href="#the-void-operator">The <code>void</code> Operator</a></h2>
<p>The <code>void</code> operator evaluates an expression and returns <code>undefined</code>.
This can used with promises if you simply want to start an asynchronous operation, but you don't care about the result, for example:</p>
<pre><code class="language-js">void fetchTask(url);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter1/08-functional-thinking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter1/10-modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter1/08-functional-thinking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter1/10-modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
