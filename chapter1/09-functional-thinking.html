<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional Thinking</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="functional-thinking"><a class="header" href="#functional-thinking">Functional Thinking</a></h2>
<div style="text-align: right"> <i> Gold can't be pure, but functions can. <br> — Ancient Chinese proverb </i> </div>
<h3 id="pure-functions"><a class="header" href="#pure-functions">Pure Functions</a></h3>
<p>A function is called <strong>pure</strong> if its outputs (the returned values) depend only on its inputs and if the function doesn't have any <em>side effects</em>.
This means that the function doesn't change program state and doesn't write anything to an external data source.</p>
<p>Here is an example of a pure function:</p>
<pre><code class="language-js">const square = (x) =&gt; x * 2;
</code></pre>
<p>Indeed, the output of <code>square</code> depends only on its input and nothing else.
In addition, <code>square</code> doesn't produce any side effects.</p>
<p>Here is an example of a function that is <em>not</em> pure:</p>
<pre><code class="language-js">const x = 2;
const addImpure = (y) =&gt; x + y;
</code></pre>
<p>The output of this function doesn't depend just on its input variables, but also on a global variable <code>x</code>.</p>
<p>Here is another function that's not pure:</p>
<pre><code class="language-js">const sayHello = () =&gt; console.log('Hello, World!');
</code></pre>
<p>The <code>sayHello</code> function has a side effect—it outputs something to the console.</p>
<p>Why do we care about all of this?
The fundamental reason is that <em>pure functions are very easy to reason about</em>.
There is practically no room for surprising behaviour.</p>
<p>Consider the above <code>square</code> function.
It takes an input and produces an output that is dependent <em>only on the input</em>.
It doesn't matter what the rest of the program is doing—the function will always produce identical outputs for identical inputs.</p>
<blockquote>
<p>If you are mathematically inclined, pure functions are basically regular mathematical functions.
They take an input which is a member of some domain and produce an output which is a member of some codomain.
For example, the <code>square</code> function is simply the function f: A → B, f(x) = x² where A and B are certain sets of numbers.
Note that A and B are emphatically <em>not</em> equal to the set of real numbers since JavaScript can't represent every possible real number (we've already discussed this).</p>
</blockquote>
<p>All of the above isn't true for the <code>addImpure</code> function.
That's because it can produce <em>different</em> outputs for identical inputs.
This makes it very hard to troubleshoot the function in case of an error.
After all, you may not know what the (global) state of the program was when the error occurred.</p>
<p>Closely related is another very nice property of pure functions—they are <em>easily testable</em>.
There is no need to fake global state as the function output depends only on the input.
Therefore, all you need to do is to call the function, pass some input and check whether the output matches the expected output.</p>
<h3 id="immutability"><a class="header" href="#immutability">Immutability</a></h3>
<p>A variable is <strong>immutable</strong> if it's unchangeable.
Otherwise, we call it <strong>mutable</strong>.
The more mutability we have inside our program the more can go wrong since it's hard to reason about (global) state.</p>
<p>This is where the alert reader might interject—after all, isn't the purpose of a program to <em>do something</em>?
And how can we achieve that if we don't change state?</p>
<p>A fundamental correction is in order here—the purpose of every program isn't to <em>do something</em>, but to <em>manipulate data</em>.
You can of course manipulate data directly by mutating global state like in the following example:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
task.title = 'Next.js book';
</code></pre>
<p>This works for simple objects and changes.
But such an approach will quickly become brittle with growing complexity.
<em>Reasoning about state and state changes is hard.</em></p>
<p>Instead, we can create copies of the objects which contain the changes we need:</p>
<pre><code class="language-js">const newTask = {
  ...task,
  title: 'Next.js book',
};
</code></pre>
<p>Note that we didn't change the original object, but created a copy of the object with a different title.</p>
<p>Immutability and pure functions are closely linked.
The programs that are easiest to understand are the ones where immutable data structures are passed through pure functions.</p>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h3>
<p>We already know that JavaScript functions are just regular objects.
We even showed an example of how you can assign a function to a variable:</p>
<pre><code class="language-js">const square = (num) =&gt; num * num;
</code></pre>
<p>This allows us to do interesting things.
Because functions are just objects we can <em>pass them to other functions</em>.</p>
<p>Consider an example function that repeats some action <code>n</code> times:</p>
<pre><code class="language-js">function repeat(fun, n) {
  for (let i = 0; i &lt; n; i++) {
    fun();
  }
}
</code></pre>
<p>We can use it like this:</p>
<pre><code class="language-js">const hello = () =&gt; console.log('Hello, World!');
repeat(hello, 4);
</code></pre>
<p>We could even shorten this code to:</p>
<pre><code class="language-js">repeat(() =&gt; console.log('Hello, World!'), 4);
</code></pre>
<p>Both versions will produce the same output:</p>
<pre><code>Hello, World!
Hello, World!
Hello, World!
Hello, World!
</code></pre>
<p>The most important thing here is that the <code>repeat</code> function doesn't care what <code>fun</code> is.
Indeed, <code>fun</code> could be a simple <code>console.log</code> or a function which simulates a universe.
All the <code>repeat</code> function does is simply repeat <code>fun</code> the specified number of times.</p>
<p>Functions which take (or return) functions are called <strong>higher-order functions</strong>.</p>
<h3 id="the-trinity-of-map-filter-and-reduce"><a class="header" href="#the-trinity-of-map-filter-and-reduce">The Trinity of <code>map</code>, <code>filter</code> and <code>reduce</code></a></h3>
<p>We now introduce the three most important higher-order functions—<code>map</code>, <code>filter</code> and <code>reduce</code>.
These functions allow you to perform an <em>incredibly</em> rich set of operations on arrays.</p>
<blockquote>
<p>We want to use this blockquote to emphasize <em>how often</em> you will be using <code>map</code>, <code>filter</code> and <code>reduce</code>.</p>
</blockquote>
<p>We will use two running examples throughout the section—an array of <code>numbers</code> and an array of <code>tasks</code>:</p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4];
const tasks = [
  {
    id: 1,
    title: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    timeLogged: 60,
    status: 'In progress',
  },
  {
    id: 2,
    title: 'Write a task app',
    description: 'Write an awesome task app.',
    timeLogged: 0,
    status: 'Todo',
  },
  {
    id: 3,
    title: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    timeLogged: 120,
    status: 'In progress',
  },
];
</code></pre>
<p>The <code>map</code> function takes one argument—a function <code>f</code> to apply to every element of the array.
It returns the array that results from applying <code>f</code> to every element of the original array.</p>
<p><img src="images/map.png" alt="" /></p>
<p>Let's say we wanted to square all the elements of <code>numbers</code>.
We could write something like this:</p>
<pre><code class="language-js">const result = [];
for (const number of numbers) {
  result.push(number ** 2);
}
</code></pre>
<p>This is ugly and (you guessed it) <em>tedious</em>.
Instead we can (and should) use the <code>map</code> function:</p>
<pre><code class="language-js">const result = numbers.map((number) =&gt; number ** 2);
console.log(result); // [1, 4, 9, 16]
</code></pre>
<p>Consider another example.
Let's say we wanted to add a long description to all the <code>tasks</code> based on the title and the description.
We can use the <code>map</code> function again:</p>
<pre><code class="language-js">const longTasks = tasks.map((task) =&gt; ({
  ...task,
  longDescription: `${task.title}: ${task.description}`,
}));
</code></pre>
<blockquote>
<p>You can see why the spread syntax is so handy.
Thanks to this <em>incredible innovation</em>, you only need to explicitly specify the object parts where something interesting happens.</p>
</blockquote>
<p>The <code>longTasks</code> array will look like this:</p>
<pre><code class="language-js">[
  {
    id: 1,
    title: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    timeLogged: 60,
    status: 'In progress',
    longDescription: 'Read the Next.js book: Read and understand the Next.js book.',
  },
  {
    id: 2,
    title: 'Write a task app',
    description: 'Write an awesome task app.',
    timeLogged: 0,
    status: 'Todo',
    longDescription: 'Write a task app: Write an awesome task app.',
  },
  {
    id: 3,
    title: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    timeLogged: 120,
    status: 'In progress',
    longDescription: 'Think of a funny joke: Come up with a funny joke to lighten the mood.',
  },
];
</code></pre>
<p>The <code>filter</code> function allows you to select elements from an array based on some condition.
It takes a function <code>f</code> which returns <code>true</code> or <code>false</code> for some input(s).
All elements for which <code>f</code> returns <code>true</code> are kept, all elements for which <code>f</code> returns <code>false</code> are thrown away.</p>
<blockquote>
<p>A function which returns <code>true</code> or <code>false</code> is commonly referred to as a <em>predicate</em>.</p>
</blockquote>
<p>For example, let's say we want to select all even elements from <code>numbers</code>.
Here is the non-functional way:</p>
<pre><code class="language-js">const result = [];
for (const number of numbers) {
  if (number % 2 === 0) {
    result.push(number ** 2);
  }
}
</code></pre>
<p>Ugh!
For loops and if statements all over the place.
So <em>non-functional</em>.
Let's rest our eyes and consider the <em>functional</em> approach:</p>
<pre><code class="language-js">const result = numbers.filter((number) =&gt; number % 2 === 0);
</code></pre>
<p>The <code>filter</code> function also works in more complicated scenarios.
For example, we might want to select all tasks from the <code>tasks</code> array which have the status <code>'Todo'</code>.</p>
<p>Think for a moment what the appropriate predicate would be.</p>
<p>That's right, it looks like this:</p>
<pre><code class="language-js">const todoTasks = tasks.filter((task) =&gt; task.status === 'Todo');
</code></pre>
<p>Finally, there is the <code>reduce</code> function which (you guessed it) <em>reduces</em> an array to a single value.
The <code>reduce</code> function moves over an array from left to right and keeps track of a value (a so-called <em>accumulator</em>).
At every element of the array it recomputes the accumulator based on a function <code>f</code> (this function <code>f</code> is the first argument of the <code>reduce</code> function).
The second argument of the reduce function is the initial value.</p>
<p>Here is how we might compute the sum of an array:</p>
<pre><code class="language-js">const sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
<p>Basically, this is what happens:</p>
<p>The <code>reduce</code> function looks at <code>acc</code> (which is the initial value, i.e. <code>0</code> at the beginning) and <code>curr</code> (which is <code>1</code>), produces <code>acc + curr</code>, and sets this as the new accumulator (i.e. the new accumulator is <code>1</code>).</p>
<p>Next, the <code>reduce</code> function again looks at <code>acc</code> (which is now <code>1</code>) and <code>curr</code> (which is <code>2</code>), produces <code>acc + curr</code>, and sets this as the new accumulator (i.e. the new accumulator becomes <code>3</code>).</p>
<p>The next update results in the accumulator being <code>6</code> and the final update results in the accumulator being <code>10</code>.
Therefore, <code>sum</code> becomes <code>10</code>.</p>
<p>For another example, let's say we would like to compute the total logged time (i.e. the time logged for all the tasks combined).
This would look like this:</p>
<pre><code class="language-js">const totalTime = tasks.reduce((curr, task) =&gt; task.timeLogged + curr, 0);
</code></pre>
<blockquote>
<p>We recommend that you try to reason through this <code>reduce</code> for a deeper understanding of this topic.</p>
</blockquote>
<p>Note that unlike <code>map</code> and <code>filter</code>, you should use <code>reduce</code> sparingly as it's very easy to write <em>very convoluted</em> code with <code>reduce</code>.
If you find yourself writing extremely complicated <code>reduce</code> expressions, you should consider using for loops and if statements instead.</p>
<h3 id="other-higher-order-functions"><a class="header" href="#other-higher-order-functions">Other Higher-Order Functions</a></h3>
<p>While <code>map</code>, <code>filter</code> and <code>reduce</code> are the most known higher-order functions, JavaScript provides us with many more.
It's worthwhile to get to know them since they will make a lot of tasks easier.</p>
<p>The <code>find</code> method returns the first element in an array that satisfies some predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.find((x) =&gt; x &gt; 9)); // 12
</code></pre>
<p>The <code>findIndex</code> method is similar, except that it returns the <em>index</em> of the first element in an array that satisfies some predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.findIndex((x) =&gt; x &gt; 9)); // 3
</code></pre>
<p>The <code>every</code> method checks whether all elements in an array satisfy a predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.every((x) =&gt; x % 2 === 0)); // true
console.log(numbers.every((x) =&gt; x &lt; 9)); // false
</code></pre>
<p>The <code>some</code> method checks whether there is at least one element in an array that satisfies a predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.some((x) =&gt; x &lt; 9)); // true
console.log(numbers.some((x) =&gt; x % 2 !== 0)); // false
</code></pre>
<p>The <code>forEach</code> method executes some function for every array element.
This is very similar to a for loop (hence the name):</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.forEach((x) =&gt; console.log(x));
</code></pre>
<p>This will output:</p>
<pre><code>2
8
4
12
6
10
</code></pre>
<h3 id="sorting-arrays"><a class="header" href="#sorting-arrays">Sorting Arrays</a></h3>
<p>The <code>sort</code> method can be used to sort the elements of an array:</p>
<pre><code class="language-js">const tasks = ['Task 2', 'Task 1', 'Task 3'];
tasks.sort();
console.log(tasks); // [ 'Task 1', 'Task 2', 'Task 3' ]
</code></pre>
<p>The default sort order is ascending and elements are sorted by converting them to strings and then sorting the strings lexicographically.
However, this may not be what you want, especially when you're trying to sort numbers:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.sort();
console.log(numbers); // [ 10, 12, 2, 4, 6, 8 ]
</code></pre>
<p>If you want to sort differently, you need to specify a <strong>comparison function</strong> <code>compareFn</code>.
A comparison function takes two arguments <code>a</code> and <code>b</code> and returns a number whose sign indicates the relative order of the elements in the sorted array.</p>
<p>If <code>compareFn(a, b)</code> is greater than <code>0</code>, <code>a</code> should be sorted after <code>b</code>.</p>
<p>If <code>compareFn(a, b)</code> is smaller than <code>0</code>, <code>a</code> should be sorted before <code>b</code>.</p>
<p>If <code>compareFn(a, b)</code> is equal to <code>0</code>, the original order of <code>a</code> and <code>b</code> should be kept.</p>
<p>For example, if you want to sort numbers in an ascending manner, you should specify the comparison function <code>(x, y) =&gt; x - y</code>.
After all, if <code>x - y</code> is greater than <code>0</code> then <code>y</code> will be sorted after <code>x</code> (which is exactly what you want).
Similarly, if <code>x - y</code> is smaller than <code>0</code> then <code>y</code> will be sorted before <code>x</code> (which is again what you want).</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.sort((x, y) =&gt; x - y);
console.log(numbers); // [ 2, 4, 6, 8, 10, 12 ]
</code></pre>
<p>If you would want to sort numbers in a descending manner, you would need to change your comparison function to <code>(x, y) =&gt; y - x</code>:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.sort((x, y) =&gt; y - x);
console.log(numbers); // [ 12, 10, 8, 6, 4, 2 ]
</code></pre>
<p>You can use the comparison function to sort arbitrary objects as well.
For example, here is how you could sort the <code>tasks</code> array by the <code>timeLogged</code> property:</p>
<pre><code class="language-js">tasks.sort((task1, task2) =&gt; task1.timeLogged - task2.timeLogged);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter1/08-basic-datastructures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter1/10-asynchronous-programming.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter1/08-basic-datastructures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter1/10-asynchronous-programming.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
