<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>React Effects</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="react-effects"><a class="header" href="#react-effects">React Effects</a></h2>
<div style="text-align: right"> <i> Why can't React effects keep a secret? <br> Because as soon as something changes, they just have to run and tell everyone! <br> - From "1000 programming dad-jokes" </i> </div>
<h3 id="why-effects"><a class="header" href="#why-effects">Why Effects?</a></h3>
<p><strong>Effects</strong> are useful if you want to synchronize React with some <em>external system</em> (like a server).</p>
<p>Consider a component which, upon rendering, needs to fetch a task title and display it to the user.
While your first instinct might be to use an event handler together with state, this is not possible.
After all, there is no real user event here.
Instead we need to execute something <em>because the component is rendering</em>.</p>
<p>This is where effects come in handy.</p>
<h3 id="the-useeffect-hook"><a class="header" href="#the-useeffect-hook">The <code>useEffect</code> Hook</a></h3>
<p>Here is the simplest possible example for a <code>useEffect</code> hook.
This hook takes a function which is executed when the component is first rendered or rerendered:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleComponent() {
  React.useEffect(() =&gt; {
    console.log('Effect runs');
  });

  return &lt;div&gt;Hello, World!&lt;/div&gt;;
}
</code></pre>
<p>If you display this component on a page, here is what you will see in the console:</p>
<pre><code>Effect runs
</code></pre>
<p>Let's add some state to the component so that we can see what happens when the component rerenders:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleCounter() {
  const [count, setCount] = React.useState(0);

  React.useEffect(() =&gt; {
    console.log(`Effect runs (currently count=${count})`);
  });

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          setCount(count + 1);
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Open the page containing the component again and you will see the following log:</p>
<pre><code>Effect runs (currently count=0)
</code></pre>
<p>Now click the button a few times - you will see that on each rerender the effect is executed:</p>
<pre><code>Effect runs (currently count=1)
Effect runs (currently count=2)
Effect runs (currently count=3)
Effect runs (currently count=4)
</code></pre>
<p>Additionally we can return a cleanup function, which will run when the component is destroyed (<em>unmounted</em>), and before every <em>rerun</em> of the useEffect. We will examine when exactly an useEffect reruns in the <a href="#the-dependency-array">next section</a>.
Consider this example:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleComponent() {
  React.useEffect(() =&gt; {
    console.log('Effect runs');

    return () =&gt; {
      console.log('Component destroyed');
    };
  });

  return &lt;div&gt;Hello, World!&lt;/div&gt;;
}
</code></pre>
<p>If the component is destroyed (for example, because you refresh the page or navigate away from the current page), you will see the following log:</p>
<pre><code>Component destroyed
</code></pre>
<p>Usually you would use the cleanup function to do some cleanup (<em>no way</em>).
For example, if you've connected to an external system, here is were you would disconnect.</p>
<h3 id="the-dependency-array"><a class="header" href="#the-dependency-array">The Dependency Array</a></h3>
<p>The <code>useEffect</code> hook also takes a second argument - a <strong>dependency array</strong>.
This allows you to specify that the effect should run only if a particular value changes.</p>
<p>Consider this (slightly constructed) example:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Counter() {
  const [firstCount, setFirstCount] = React.useState(0);
  const [secondCount, setSecondCount] = React.useState(0);

  React.useEffect(() =&gt; {
    console.log(`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`);
  }, [firstCount]);

  return (
    &lt;div&gt;
      &lt;p&gt;{`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`}&lt;/p&gt;
      &lt;button onClick={() =&gt; setFirstCount(firstCount + 1)}&gt;Increment first count&lt;/button&gt;
      &lt;button onClick={() =&gt; setSecondCount(secondCount + 1)}&gt;Increment second count&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>As usual, the effect runs on the initial render:</p>
<pre><code>Current counts: firstCount=0, secondCount=0
</code></pre>
<p>If you click the "Increment first count" button, you will see that the effect runs again:</p>
<pre><code>Current counts: firstCount=1, secondCount=0
Current counts: firstCount=2, secondCount=0
Current counts: firstCount=3, secondCount=0
Current counts: firstCount=4, secondCount=0
</code></pre>
<p>However, if you click the "Increment second count" button, you will see that the effect doesn't run (and nothing is logged to the console).</p>
<p>This is because <code>firstCount</code> is in the dependency array, but <code>secondCount</code> isn't.
Therefore, an update to <code>firstCount</code> (via the <code>setFirstCount</code> setter function) will trigger the effect.
But an update to <code>secondCount</code> (via the <code>setSecondCount</code> setter function) won't.</p>
<p>If you want to trigger the effect when <code>secondCount</code> is updated, you will need to add <code>secondCount</code> to the dependency array:</p>
<pre><code class="language-js">React.useEffect(() =&gt; {
  console.log(`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`);
}, [firstCount, secondCount]);
</code></pre>
<p>Note that if the dependency array is empty, the effect will run only once - when the component is first rendered.
This directly follows from the explanation above - an empty dependency array contains no values that would trigger the effect again.</p>
<p>Consider this example:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Counter() {
  const [firstCount, setFirstCount] = React.useState(0);
  const [secondCount, setSecondCount] = React.useState(0);

  React.useEffect(() =&gt; {
    console.log(`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`);
  }, []);

  return (
    &lt;div&gt;
      &lt;p&gt;{`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`}&lt;/p&gt;
      &lt;button onClick={() =&gt; setFirstCount(firstCount + 1)}&gt;Increment first count&lt;/button&gt;
      &lt;button onClick={() =&gt; setSecondCount(secondCount + 1)}&gt;Increment second count&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>The effect will run on the initial render:</p>
<pre><code>Current counts: firstCount=0, secondCount=0
</code></pre>
<p>But it won't run again, no matter how often you click the buttons.</p>
<p>Here is a bonus tip regarding effects: <strong>You should always explicitly specify the dependency array</strong>.</p>
<p>Remember, if you don't specify the dependency array, the effect will rerun on every render, which is rarely the desired behaviour.
In fact this can result in catastrophic behaviour, like in the following example:</p>
<pre><code class="language-jsx">export default function ExampleComponent() {
  const [count, setCount] = React.useState(0);

  React.useEffect(() =&gt; {
    setCount(count + 1);
  });

  return (
    &lt;div&gt;
      &lt;h1&gt;Example Component&lt;/h1&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>If you run this, you will see that the counter just keeps incrementing in an infinite loop.
This is because, the effect calls <code>setCount</code>, which will trigger a rerender, which will trigger the effect again, which will call <code>setCount</code> etc.</p>
<p>React is actually smart enough to realize the problem and will log the following warning to the console:</p>
<pre><code>Maximum update depth exceeded.
This can happen when a component calls setState inside useEffect,
but useEffect either doesn't have a dependency array,
or one of the dependencies changes on every render.
</code></pre>
<h3 id="using-fetch-and-useeffect-together"><a class="header" href="#using-fetch-and-useeffect-together">Using <code>fetch</code> and <code>useEffect</code> Together</a></h3>
<p>One of the most common usages of <code>useEffect</code> is to synchronize your component with an external API.</p>
<p>Let's return to our motivation for this section, where we wanted to fetch a task title and display it to the user.
Since the task title is held by the API (i.e. an external system), this seems like a perfect use case for an effect:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleTask() {
  const [title, setTitle] = React.useState('');

  React.useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/todos/1')
      .then((response) =&gt; {
        if (!response.ok) {
          throw new Error(`Response status was ${response.status}`);
        }
        return response.json();
      })
      .then((json) =&gt; setTitle(json.title))
      .catch((error) =&gt; console.log(error));
  }, []);

  return &lt;p&gt;{title}&lt;/p&gt;;
}
</code></pre>
<p>This code should be pretty clear if you understand the <code>fetch</code> function and the <code>useEffect</code> hook.</p>
<p>Our effect fetches a the task from the API and then sets a state called <code>title</code> after the fetch is completed.
Because we only want this to happen on the initial component render, we specify an empty dependency array.</p>
<p>Note that we don't have a cleanup function in our effect - normally we would abort the request here.
However this is out of scope for this introductory book.</p>
<h3 id="you-rarely-need-an-effect"><a class="header" href="#you-rarely-need-an-effect">You Rarely Need an Effect</a></h3>
<p>Just like with state, beginners tend to heavily <em>overuse</em> effects.</p>
<p>Remember: <strong>Effects are only needed if you need to synchronize with an external system</strong>.
You should not need an effect in any other scenario.</p>
<p>Effects are definitely not needed if you need update some state based on props and other state.
Something like this is completely unneccessary:</p>
<pre><code class="language-jsx">import * as React from 'react';

type Task = {
  id: string;
  title: string;
};

export default function TaskList() {
  const [tasks, setTasks] = React.useState&lt;Task[]&gt;([]);
  const [numTasks, setNumTasks] = React.useState(0);

  // This is a really bad idea
  React.useEffect(() =&gt; {
    setNumTasks(tasks + 1);
  }, [tasks])

  function handleSubmit(event) {
    event.preventDefault();
    const taskId = event.currentTarget.taskId.value.trim();
    const title = event.currentTarget.title.value.trim();
    setTasks([
      ...tasks,
      {
        id: taskId,
        title,
      },
    ]);
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {tasks.map((item) =&gt; (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;You have {numTasks} tasks&lt;/p&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label htmlFor="taskId"&gt;Task ID:&lt;/label&gt;
        &lt;input type="text" id="taskId" /&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" /&gt;
        &lt;br /&gt;
        &lt;button type="submit"&gt;Add task&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Instead you should simply calculate the depending value during rendering (like we discussed in the previous section).</p>
<p>Similarly, you don't need effects when you want to reset or adjust some state based on a prop change.</p>
<blockquote>
<p>In fact, these days some guidelines recommend to not use an effect even for fetching data.
This is because if you fetch data inside an effect in more complex scenarios, you need to think about cleanup functions, race conditions etc.
This why most frameworks that build on top of React (like Next.js) usually provide better data fetching mechanisms than fetching data in effects.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter7/02-react-state.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter8/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter7/02-react-state.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter8/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
