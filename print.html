<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Getting Things Done in Next.js</a></li><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li><li class="chapter-item expanded "><a href="chapter1/index.html"><strong aria-hidden="true">1.</strong> A Brief Introduction to JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/01-hello-world.html"><strong aria-hidden="true">1.1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="chapter1/02-primitive-data-types.html"><strong aria-hidden="true">1.2.</strong> Primitive Data Types</a></li><li class="chapter-item expanded "><a href="chapter1/03-arrays-and-objects.html"><strong aria-hidden="true">1.3.</strong> Arrays and Objects</a></li><li class="chapter-item expanded "><a href="chapter1/04-control-flow.html"><strong aria-hidden="true">1.4.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="chapter1/05-functions.html"><strong aria-hidden="true">1.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter1/06-error-handling.html"><strong aria-hidden="true">1.6.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="chapter1/07-basic-datastructures.html"><strong aria-hidden="true">1.7.</strong> Basic Data Structures</a></li><li class="chapter-item expanded "><a href="chapter1/08-functional-thinking.html"><strong aria-hidden="true">1.8.</strong> Functional Thinking</a></li><li class="chapter-item expanded "><a href="chapter1/09-asynchronous-programming.html"><strong aria-hidden="true">1.9.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="chapter1/10-modules.html"><strong aria-hidden="true">1.10.</strong> Modules</a></li><li class="chapter-item expanded "><a href="chapter1/11-packages.html"><strong aria-hidden="true">1.11.</strong> Packages</a></li><li class="chapter-item expanded "><a href="chapter1/12-writing-decent-code.html"><strong aria-hidden="true">1.12.</strong> Writing Decent Code</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/index.html"><strong aria-hidden="true">2.</strong> Leveling Up with TypeScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/01-why-typescript.html"><strong aria-hidden="true">2.1.</strong> Why TypeScript?</a></li><li class="chapter-item expanded "><a href="chapter2/02-basic-types.html"><strong aria-hidden="true">2.2.</strong> Basic Types</a></li><li class="chapter-item expanded "><a href="chapter2/03-annotating-functions.html"><strong aria-hidden="true">2.3.</strong> Annotating Functions</a></li><li class="chapter-item expanded "><a href="chapter2/04-union-types.html"><strong aria-hidden="true">2.4.</strong> Union Types</a></li><li class="chapter-item expanded "><a href="chapter2/05-generics.html"><strong aria-hidden="true">2.5.</strong> Generics</a></li><li class="chapter-item expanded "><a href="chapter2/06-configuring-typescript.html"><strong aria-hidden="true">2.6.</strong> Configuring TypeScript</a></li></ol></li><li class="chapter-item expanded "><a href="chapter3/index.html"><strong aria-hidden="true">3.</strong> Networking Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter3/01-ips-ports-and-domains.html"><strong aria-hidden="true">3.1.</strong> IPs, Ports and Domains</a></li><li class="chapter-item expanded "><a href="chapter3/02-an-http-primer.html"><strong aria-hidden="true">3.2.</strong> An HTTP Primer</a></li><li class="chapter-item expanded "><a href="chapter3/03-more-on-http.html"><strong aria-hidden="true">3.3.</strong> More on HTTP</a></li></ol></li><li class="chapter-item expanded "><a href="chapter4/index.html"><strong aria-hidden="true">4.</strong> A Vanilla Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4/01-hypertext-markup-language.html"><strong aria-hidden="true">4.1.</strong> Hypertext Markup Language</a></li><li class="chapter-item expanded "><a href="chapter4/02-marking-up-text.html"><strong aria-hidden="true">4.2.</strong> Marking Up Text</a></li><li class="chapter-item expanded "><a href="chapter4/03-hyperlinks-and-images.html"><strong aria-hidden="true">4.3.</strong> Hyperlinks and Images</a></li><li class="chapter-item expanded "><a href="chapter4/04-the-document-object-model.html"><strong aria-hidden="true">4.4.</strong> The Document Object Model</a></li><li class="chapter-item expanded "><a href="chapter4/05-web-forms.html"><strong aria-hidden="true">4.5.</strong> Web Forms</a></li><li class="chapter-item expanded "><a href="chapter4/06-a-simple-client.html"><strong aria-hidden="true">4.6.</strong> A Simple Client</a></li></ol></li><li class="chapter-item expanded "><a href="chapter5/index.html"><strong aria-hidden="true">5.</strong> Adding Spice with React</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter5/01-react-components.html"><strong aria-hidden="true">5.1.</strong> React Components</a></li><li class="chapter-item expanded "><a href="chapter5/02-react-state.html"><strong aria-hidden="true">5.2.</strong> React State</a></li><li class="chapter-item expanded "><a href="chapter5/03-react-effects.html"><strong aria-hidden="true">5.3.</strong> React Effects</a></li></ol></li><li class="chapter-item expanded "><a href="chapter6/index.html"><strong aria-hidden="true">6.</strong> Moving to the Server with Next.js</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter6/01-setup.html"><strong aria-hidden="true">6.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="chapter6/02-pages-and-layouts.html"><strong aria-hidden="true">6.2.</strong> Pages and Layouts</a></li><li class="chapter-item expanded "><a href="chapter6/03-more-on-routes.html"><strong aria-hidden="true">6.3.</strong> More on Routes</a></li><li class="chapter-item expanded "><a href="chapter6/04-server-and-client-components.html"><strong aria-hidden="true">6.4.</strong> Server and Client Components</a></li></ol></li><li class="chapter-item expanded "><a href="chapter7/index.html"><strong aria-hidden="true">7.</strong> Becoming Pretty with Tailwind CSS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter7/01-setup.html"><strong aria-hidden="true">7.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="chapter7/02-typography-utilities.html"><strong aria-hidden="true">7.2.</strong> Typography Utilities</a></li><li class="chapter-item expanded "><a href="chapter7/03-background-utilities.html"><strong aria-hidden="true">7.3.</strong> Background Utilities</a></li><li class="chapter-item expanded "><a href="chapter7/04-size-utilities.html"><strong aria-hidden="true">7.4.</strong> Size Utilities</a></li><li class="chapter-item expanded "><a href="chapter7/05-border-utilities.html"><strong aria-hidden="true">7.5.</strong> Border Utilities</a></li><li class="chapter-item expanded "><a href="chapter7/06-spacing-utilities.html"><strong aria-hidden="true">7.6.</strong> Spacing Utilities</a></li><li class="chapter-item expanded "><a href="chapter7/07-flexbox.html"><strong aria-hidden="true">7.7.</strong> Flexbox</a></li><li class="chapter-item expanded "><a href="chapter7/08-grid.html"><strong aria-hidden="true">7.8.</strong> Grid</a></li></ol></li><li class="chapter-item expanded "><a href="chapter8/index.html"><strong aria-hidden="true">8.</strong> Persistence with SQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter8/01-setup.html"><strong aria-hidden="true">8.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="chapter8/02-inserting-updating-and-deleting-data.html"><strong aria-hidden="true">8.2.</strong> Inserting, Updating and Deleting Data</a></li><li class="chapter-item expanded "><a href="chapter8/03-selecting-rows.html"><strong aria-hidden="true">8.3.</strong> Selecting Data</a></li><li class="chapter-item expanded "><a href="chapter8/04-multiple-tables.html"><strong aria-hidden="true">8.4.</strong> Multiple Tables</a></li></ol></li><li class="chapter-item expanded "><a href="chapter9/index.html"><strong aria-hidden="true">9.</strong> Typesafe SQL with Drizzle</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter9/01-setup.html"><strong aria-hidden="true">9.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="chapter9/02-inserting-updating-and-deleting-data.html"><strong aria-hidden="true">9.2.</strong> Inserting, Updating and Deleting Data</a></li><li class="chapter-item expanded "><a href="chapter9/03-selecting-rows.html"><strong aria-hidden="true">9.3.</strong> Selecting Data</a></li><li class="chapter-item expanded "><a href="chapter9/04-multiple-tables.html"><strong aria-hidden="true">9.4.</strong> Multiple Tables</a></li><li class="chapter-item expanded "><a href="chapter9/05-migrations.html"><strong aria-hidden="true">9.5.</strong> Migrations</a></li></ol></li><li class="chapter-item expanded "><a href="chapter10/index.html"><strong aria-hidden="true">10.</strong> The Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter10/01-setup.html"><strong aria-hidden="true">10.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="chapter10/02-task-page.html"><strong aria-hidden="true">10.2.</strong> Task Page</a></li><li class="chapter-item expanded "><a href="chapter10/03-styling-the-task-page.html"><strong aria-hidden="true">10.3.</strong> Styling the Task Page</a></li><li class="chapter-item expanded "><a href="chapter10/04-project-page.html"><strong aria-hidden="true">10.4.</strong> Project Page</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-things-done-in-nextjs"><a class="header" href="#getting-things-done-in-nextjs">Getting Things Done In Next.js</a></h1>
<p><em>by Mikhail Berkov</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="text-align: right"> <i>No one reads introductions anyway.<br> — Sun Tzu</i></div>
<p>Long gone are the times when JavaScript was just a scripting language to add simple interactive behaviour to websites. The ECMAScript 2015 standard significantly improved the usability of the language. Excellent UI libraries like React allow you to write straightforward declarative code which massively simplifies building user interfaces. Thanks to Node.js you can write JavaScript on the server. Next.js empowers you to write complex APIs very quickly and PostgreSQL provides a relational database that fits right in with the other tools. The Next.js stack therefore allows you to quickly develop complex applications using just one language - JavaScript (with optional type hints via TypeScript).</p>
<p>This book serves as an introduction to the Next.js stack. However you don't learn software development by <em>just</em> reading books, you learn it by creating projects. We will therefore not bombard you with useless language trivia for hundreds of pages. If you care about that, go read the standard - it's <em>pretty comprehensive</em>. Instead we will create a real software project - an application for managing tasks called <strong>easy-opus</strong> (get it?). We will begin with nothing more than an empty project directory and the <em>will to learn</em>. We will end with a useful piece of software that allows us to create tasks, assign tasks to different users, update their statuses and much more.</p>
<p>This book is therefore <em>inherently practical</em> - unlike some other literature we will not dwell much on theoretical considerations. On the other hand, purely practical concerns are first-class citizens here (for example there is an entire chapter devoted to hosting your application). This doesn't mean that <em>theory bad, practice good</em>. It simply means that the approach for <em>this particular book</em> is heavily geared towards completing a real software project.</p>
<p>This book is therefore also <em>not</em> about becoming <em>yet another JavaScript guru</em>™ (there are already too many of them). It's about writing a useful product. It is fundamentally about <strong>getting things done</strong>. The Next.js stack is really just a tool we use to get things done.</p>
<p>This book is suitable for both beginners who want to pick up their first tech stack as well as for seasoned software developers looking to expand their knowledge.</p>
<p>This book is intended to be a standalone resource. While there are resources for further reading in each section, these are merely pointers if you want to dive deeper into a certain topic. You <em>don't have</em> to read them and you should be able to understand everything without reading them. In fact, if you are hard stuck in a certain place, this probably represents a failure on our part. Maybe we didn't explain an important concept well enough (or at all!). Don't hesitate to write an email to <code>uhasker@protonmail.com</code> or to create an issue at <code>https://github.com/uhasker/getting-things-done-in-next-js</code> explaining your problem.</p>
<p><em>Happy hacking</em></p>
<p><em>Mikhail Berkov</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>I sincerely thank <strong>Jannis Morgenstern</strong>, <strong>Alexander Berkov</strong>, <strong>Jakob Stechow</strong> and <strong>Julian Wasmeier</strong> for proofreading chapter drafts and giving valuable feedback on missing parts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-a-brief-introduction-to-javascript"><a class="header" href="#chapter-1-a-brief-introduction-to-javascript">Chapter 1: A Brief Introduction to JavaScript</a></h1>
<div style="text-align: right"> <i> JavaScript has beauty, but not everyone sees it. <br> - Confucius </i> </div>
<p>First we will need to go through the basics of the JavaScript language that we will use pretty much everywhere throughout this book. After all the Next.js stack is built on top of it.</p>
<p>You will setup your runtime, learn about variables, data types, operators and control flow. You will also learn how to write functions and how to think <em>functionally</em>. Thinking <em>functionally</em> will make you a better software developer and a better person. Isn't that great?</p>
<p>Let's dive right in!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<div style="text-align: right"> <i> A journey of a thousand miles begins with a single "Hello, world!" program. <br> — Ancient Chinese proverb </i> </div>
<h3 id="runtime-environments"><a class="header" href="#runtime-environments">Runtime Environments</a></h3>
<p>Contrary to popular belief, code sadly doesn't run on pixie dust, magic spells, and unicorn tears.
Instead, it runs on something called a <strong>runtime environment</strong> (also referred to as <em>runtime system</em> or just <em>runtime</em>).
Put simply, a runtime is a program capable of executing code written in some programming language.
It <em>provides the environment in which programs can run</em>.
In order to execute all the <em>awesome</em> JavaScript code we are about to write, we therefore need a runtime first.</p>
<p>There are two runtimes capable of executing JavaScript code, which are relevant to this book - the browser and Node.js.
The browser as well as the Node.js console have <strong>REPL</strong> (read-eval-print-loop) capabilities.
This means you can directly type some code into the console and execute it.
REPLs are very nice, because they allow you to quickly test what you just learned.
Additionally, both runtimes can execute a file containing JavaScript code.
This is how we will usually utilize the runtimes - we write a <strong>script</strong> (a file containing JavaScript code) and tell our runtime to execute it.</p>
<blockquote>
<p>As projects grow larger, we will usually be dealing with multiple files at the same time.
We will talk about this in the "Modules" section of this chapter.</p>
</blockquote>
<p>Every runtime environment comes with a <strong>console</strong>.
This isn't a retro gaming console; rather, it's a special part of the runtime where you can input commands and see the results of your code in real-time.
Think of it as a conversation between you and the program - you tell it what to do (input commands) and it responds by executing those commands and showing you what happened (output).</p>
<p>In this section we will set up the browser and Node.js runtimes.
Then we will print "Hello, world!" to both the browser console and the Node.js console to test that our setup functions as anticipated.</p>
<h3 id="the-browser-environment"><a class="header" href="#the-browser-environment">The Browser Environment</a></h3>
<p>Open a browser, and open its console.
How you do this will depend on the browser.</p>
<p>If you are using <em>Firefox</em> the shortcut for opening the console is <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd> on Ubuntu/Debian and <kbd>Cmd</kbd> + <kbd>Option</kbd> + <kbd>K</kbd> on macOS.
If you are using <em>Chrome</em> or <em>Microsoft Edge</em> the shortcut is <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd> on Ubuntu/Debian and <kbd>Cmd</kbd> + <kbd>Option</kbd> + <kbd>J</kbd> on macOS.
If you are using <em>Safari</em> on macOS, you will need to enable the develop menu first by going to <code>Settings &gt; Advanced</code> and ticking the box <code>Show Develop menu in menu bar</code>. Then you can open the console using <kbd>Cmd</kbd> + <kbd>Option</kbd> + <kbd>K</kbd>.</p>
<blockquote>
<p>If you are using Internet Explorer, please navigate to <code>google.com</code> and search for "Firefox" to install a <em>real</em> browser.
This line was originally intended to be a funny joke, but on June 15, 2022 Microsoft ended support for Internet Explorer, so it's not even a joke anymore.
We personally recommend Firefox, but Chrome, Microsoft Edge or Safari are also fine choices.</p>
</blockquote>
<p>This is approximately how the browser console will look like in Firefox:</p>
<p><img src="chapter1/images/browser-console.png" alt="" /></p>
<blockquote>
<p>Note that if you see a bunch of scary error or warning messages upon opening the console, <em>don't panic</em> (this is also good life advice in general).
Most of these will probably come from various extensions you might have installed or the web page you are currently viewing.
You can simply delete these messages, as we don't care about them.</p>
</blockquote>
<p>Let us print something using the <code>console.log</code> method. Type the following into the browser console:</p>
<pre><code class="language-js">console.log('Hello, world!');
</code></pre>
<p>Now hit <kbd>Return</kbd> (you may also know this as <kbd>Enter</kbd> or simply <kbd>⏎</kbd>).
You will see the output "Hello, world!" in the console:</p>
<p><img src="chapter1/images/browser-console-log.png" alt="" /></p>
<blockquote>
<p>Ignore the "undefined" for now.</p>
</blockquote>
<p>Hooray, you printed something to the browser console!
This is the point at which you go tell everyone that you are now a <em>programmer</em>™.</p>
<h3 id="executing-javascript-in-the-browser"><a class="header" href="#executing-javascript-in-the-browser">Executing JavaScript in the Browser</a></h3>
<p>As we already mentioned, instead of executing JavaScript in the browser console directly, we can (and often will) execute it from a JavaScript <em>file</em>.
Since we're on the browser, we will need to create two files - an HTML file and a JavaScript file.</p>
<p>HTML is short for <em>HyperText Markup Language</em> and is the standard markup language for documents that should be displayed in a browser.
We will cover HTML in detail in a later chapter, for now we just need to be able to create a very simple HTML document.</p>
<p>Create a new HTML file.
We will call it <em>hello.html</em>; however you can name it whatever you want.
The filename should have an <em>html</em> extension though.</p>
<p>Open the HTML file in any text editor (see below for text editors that are good choices for coding) and add the following text to the file:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;script src="hello.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Don't forget to save the file!</p>
<p>Now create another file called <em>hello.js</em> in the same directory as <em>hello.html</em> with the following content:</p>
<pre><code class="language-js">console.log('Hello, world');
</code></pre>
<blockquote>
<p>Note the semicolon after the <code>console.log</code>.
It terminates the <code>console.log</code> statement.
The semicolon is technically not required here and there are many JavaScript programmers who don't use semicolons.
However, to avoid a bunch of pitfalls, we will use semicolons throughout this book and therefore we want you to get accustomed to them as soon as possible.</p>
</blockquote>
<p>Now open this file in your browser by simply double-clicking the file.
After opening this file in your browser, open the console.
You should the output <code>Hello, world!</code>.</p>
<p>Congratulations, you wrote your first script!</p>
<h3 id="working-with-a-command-line"><a class="header" href="#working-with-a-command-line">Working With a Command Line</a></h3>
<p>Now that we know how to use the browser runtime, we will move on to Node.js.
However, before we can do that, we will need to learn how to interact with the <strong>command-line interface</strong> (also called command line, command prompt or CLI).
A command line allows you to execute various tasks called commands.</p>
<p>If you're on Ubuntu, you can open the command line by pressing <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>T</kbd>.</p>
<p>If you're on macOS, you can open the command line by pressing <kbd>Cmd</kbd> + <kbd>Space</kbd> to open <em>search</em>, typing <em>terminal</em> and then hitting <kbd>Return</kbd>.</p>
<p>Now that you've opened a CLI, you can type a command and hit <kbd>Return</kbd> to execute it.
Try executing this command for starters:</p>
<pre><code class="language-sh">echo 'Hello, world!'
</code></pre>
<blockquote>
<p>Generally whenever we tell you to execute a command you need to type it in the CLI and hit <kbd>Return</kbd>.</p>
</blockquote>
<h3 id="the-nodejs-runtime"><a class="header" href="#the-nodejs-runtime">The Node.js Runtime</a></h3>
<p>For a long time, JavaScript was mostly used inside the browser runtime environment by programmers.
However in 2009 Node.js came along and changed that by allowing programmers to easily run JavaScript outside the browser.</p>
<p>Node.js will probably not be installed on your machine, so let's fix that.
First, we will install the <strong>Fast Node Manager</strong> (<strong>fnm</strong> for short) which will allow us to manage Node.js versions in a simple and straightforward manner.</p>
<p>If you're on Ubuntu/Debian you will need to run the following:</p>
<pre><code class="language-sh">curl -fsSL https://fnm.vercel.app/install | bash
source ~/.bashrc
</code></pre>
<p>If you're on macOS you will need to run the following:</p>
<pre><code class="language-sh">curl -fsSL https://fnm.vercel.app/install | zsh
source ~/.zshrc
</code></pre>
<p>Check that <code>fnm</code> was successfully installed:</p>
<pre><code class="language-sh">fnm --version
</code></pre>
<p>Finally we will install Node.js (version 18):</p>
<pre><code class="language-sh">fnm install 18
</code></pre>
<p>Verify that Node.js was successfully installed:</p>
<pre><code class="language-sh">node --version
</code></pre>
<p>The installation script also automatically installed the <strong>node package manager</strong> (<em>npm</em> for short) which is a tool for managing dependencies in our projects.
Verify that <code>npm</code> was installed as well:</p>
<pre><code class="language-sh">npm --version
</code></pre>
<p>Throughout this book we will use the <code>pnpm</code> package manager, so let's install that too:</p>
<pre><code class="language-sh">npm install -g pnpm
</code></pre>
<p>Verify that <code>pnpm</code> was installed:</p>
<pre><code class="language-sh">pnpm --version
</code></pre>
<p>Now that Node.js is installed, you can open a Node.js console by typing <code>node</code> in the command line.</p>
<p>We can now print "Hello, world!" in the Node.js console using the <code>console.log</code> method.
Type the following into the console and hit <kbd>Return</kbd>:</p>
<pre><code class="language-js">console.log('Hello, world!');
</code></pre>
<p>You should see the output <code>"Hello, world!"</code>.</p>
<h3 id="executing-a-javascript-file"><a class="header" href="#executing-a-javascript-file">Executing a JavaScript File</a></h3>
<p>We can also use Node.js to execute a JavaScript file.</p>
<p>Create a file named <code>hello.js</code>.
Open the file in any text editor and add the following content to the file:</p>
<pre><code class="language-js">console.log('Hello, world!');
</code></pre>
<p>Open a command line again and <em>change the current directory location to the directory containing the JavaScript file</em>.
You can do so using the <em>cd</em> command.
For example if <code>hello.js</code> is located at <code>/home/users/user</code> you would execute the following:</p>
<pre><code class="language-sh">cd /home/users/user
</code></pre>
<p>Now execute the JavaScript file by running:</p>
<pre><code class="language-sh">node hello.js
</code></pre>
<p>This should again print <code>"Hello, world!"</code>.</p>
<p>Note that for the remainder of this chapter you should follow along using the Node.js console.
Nevertheless, as we dive further into the Next.js stack, we will have to write JavaScript for the browser runtime environment on a regular basis.</p>
<h3 id="the-browser-vs-nodejs"><a class="header" href="#the-browser-vs-nodejs">The Browser vs Node.js</a></h3>
<p>We managed to execute some JavaScript on the browser and some JavaScript in Node.js.
Right now, these two runtime environments don't look too different because we only logged something to the console.
However, in later sections you will learn that it is in fact extremely important which runtime you're on.</p>
<p>For example in Node.js you cannot access your browser window (which makes sense since there <em>is no browser window</em>).
On the other hand, if you are in the browser you cannot write files to the computer (to protect users from malicious websites).
Often people say that JavaScript code can be run <em>on the client</em> (in the browser) or <em>on the server</em> (usually using Node.js).</p>
<p>Remember this point, since it will become extremely important later.</p>
<h2 id="editors"><a class="header" href="#editors">Editors</a></h2>
<p>In the previous paragraphs you had to create a few files containing code.
It will not come as a surprise that this be necessary <em>a lot</em> during your programming journey.
You should therefore select a good editor that has features such as syntax highlighting, autocompletion etc.</p>
<blockquote>
<p>Coding in Notepad is in fact <em>not</em> a good idea.</p>
</blockquote>
<p>If you're a complete beginner, the <a href="https://code.visualstudio.com">Visual Studio Code</a> editor is often an excellent first choice.</p>
<h3 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h3>
<p>Before we dive into JavaScript, you should know that programs are made of statements and expressions.</p>
<p>A <strong>statement</strong> is a syntactic unit responsible for executing some action.
A <strong>program</strong> is then essentially a sequence of statements which should be executed when running the program.
For example <code>console.log('Hello, world!')</code> is a statement which executes the action of printing "Hello, world!" to the console.</p>
<p>An <strong>expression</strong> is a syntactic unit that may be evaluated to get its value.
For example <code>2 + 2</code> would be an expression which would evaluate to <code>4</code>.</p>
<p>You could put it this way: Statements are executed to make something happen, while expressions are evaluated to produce a value.</p>
<blockquote>
<p>Note that other authors might define statements and expressions in a slightly different manner.
However we will stick to these definitions throughout this book.</p>
</blockquote>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Everything that comes after a double slash on a line is a <strong>comment</strong> in JavaScript.
Comments are ignored by the runtime and therefore have no effect on the execution of your program:</p>
<pre><code class="language-js">// This is just a comment
// Comments have no effect
console.log('Hello, world!');
// Therefore this program is equivalent to the
// program from the previous chapter
</code></pre>
<p>We will heavily utilize comments throughout this book inside the code blocks to highlight important ideas.</p>
<blockquote>
<p>There is a lot of discussion in the programming community on how much you should comment your programs.
We will return to this when discussing functions.
However one rule is that if your code is so terrible that it requires <em>extensive commentary</em> to explain its behavior or purpose, you should fix the code.
Just like a work of art, your code should stand on it's own merits.
Imagine <em>commenting</em> a work of art (oh, wait)...
However it is better to have terrible code and comments than have terrible code and no comments.
And of course if your code does something particularly complicated, throwing in a comment might be a good idea.</p>
</blockquote>
<p>We will also adopt the convention that if a comment is next to a line with a <code>console.log</code> statement, that comment shows the output that would be logged to the console if the code was executed.
For example:</p>
<pre><code class="language-js">console.log('Hellave the file!o, world!'); // Hello, world!
</code></pre>
<p>This is the point where we tell you that while you are reading this book you should <em>absolutely follow along in some runtime</em> (probably Node.js, but a browser is fine too).
This is <em>very important</em>.
Go ahead and open a Node.js console <em>now</em>.</p>
<p>Come on, we'll wait...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p><em>Finally</em>.
Let's move on.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="primitive-data-types"><a class="header" href="#primitive-data-types">Primitive Data Types</a></h2>
<div style="text-align: right"> <i> == is the equality operator <br> === is the one and true equality operator <br> ==== is the equality operator which transcends time and space <br> ===== is the equality operator which transcends all other equality operators <br> ====== is the equality operator which summons the UNSPEAKABLE DOOM h̷̳͓͝ě̵̞͂ ̵̮͍͊͋i̴͎͂s̵̗͒ ̷̘̤̓̅h̸͜͝ḙ̵̀r̶͈̆ȇ̶̗̱̍ ̸͕̾h̴̲̗̾̅e̷̟̋ả̶̬v̶̯́̐͜ẽ̸̛͔n̶̩̒͊ ̴̢̯̍ḣ̵̳̻e̴̙̒̓l̵͇̟̃p̶̘̑ ̷̠͛͝ŭ̴͇̯̕s̶̮͕̒ <br> — from "The Book of the Equality Operators and their Virtue" by Laozi </i> </div>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p>Whenever we write programs, we need to manipulate data.
This data needs to be stored somewhere and we need to be able to access it somehow.
We also need to deal with the fact that when we execute a program, the values we deal with are not predictable in advance.
For example we don't know which tasks a user might create (that is kind of the point of writing our application).
Nevertheless, we must be able to access created tasks through a predictable name like <code>tasks</code> or <code>createdTasks</code>.</p>
<p>Therefore we need a way to put an <em>unpredictable</em> value somewhere and refer to it using a <em>predictable</em> name.
In programming, that "somewhere" is referred to as <em>storage</em> and the predictable name as a <em>symbolic name</em>.</p>
<p>A <strong>variable</strong> is just that - a storage location containing a value which is referred to by a symbolic name.
This <em>sounds</em> really fancy, but it just means that there is a value somewhere in your storage and you can refer to that value using a symbolic name that doesn't change (even if the value itself changes).</p>
<p>For example you could have a variable <code>age</code> which has the value <code>20</code> (we say that <code>age</code> is equal to <code>20</code>):</p>
<p><img src="chapter1/images/variable.png" alt="" /></p>
<p>Now even if the value of <code>age</code> changes (e.g. to <code>21</code> because a birthday happened), the variable name doesn't change, only the value does.
The variable name will still be <code>age</code>, however now <code>age</code> will have the value <code>21</code> (i.e. <code>age</code> will be equal to <code>21</code>):</p>
<p><img src="chapter1/images/variable-changed.png" alt="" /></p>
<p>JavaScript lets you declare variables with the <code>let</code> keyword.
You can assign values to variables using the <strong>assignment operator</strong> (<code>=</code>):</p>
<pre><code class="language-js">// Declare a variable
let x;

// Assign a value to a variable
x = 10;
</code></pre>
<p>You can print the value of the variable using the <code>console.log</code> method:</p>
<pre><code class="language-js">console.log(x); // 10
</code></pre>
<blockquote>
<p>If you follow along in the Node.js (or browser) console, you don't actually need to use the <code>console.log</code> method to print the value of a variable.
Instead you can simply type the variable (or any expression for that matter) and the console will display its value.</p>
</blockquote>
<p>You can also have a declaration and an assignment on a single line. In fact, this is usually the way to go:</p>
<pre><code class="language-js">let y = 10;
</code></pre>
<p>The value of a variable may change over the course of a program:</p>
<pre><code class="language-js">let y = 10;
console.log(y); // 10

// Assign a new value to the variable
y = 20;
console.log(y); // 20
</code></pre>
<p>This will log <code>10</code> and then <code>20</code> to the console.</p>
<p>If you want to declare a predictable name for a value that never changes, you can declare a <strong>constant</strong>.
This is done using the <code>const</code> keyword:</p>
<pre><code class="language-js">const ten = 10;
</code></pre>
<p>If you try to reassign a value to a constant, you get an error. For example if you do</p>
<pre><code class="language-js">const ten = 10;
ten = 20;
</code></pre>
<p>you get</p>
<pre><code>Uncaught TypeError: Assignment to constant variable.
</code></pre>
<p>You will almost exclusively see us using <code>const</code> instead of <code>let</code> from now on.
Reassignment is not nearly as necessary as you might think right now.</p>
<blockquote>
<p>You can also declare variables using the <code>var</code> keyword.
We will not cover it here and you essentially only need to know one thing about <code>var</code> - you should <em>basically never use it</em>.
It's mostly a historical artifact of the language at this point.</p>
</blockquote>
<p>Any variable has a <strong>data type</strong> which denotes the range of values it can take and which operations can be performed on the variable.
You can use the <code>typeof</code> operator to obtain the data type of a variable.</p>
<p>We begin with a few particularly important <strong>primitive data types</strong>.
Let's talk about numbers, booleans, strings and <code>undefined</code>.</p>
<h3 id="numbers"><a class="header" href="#numbers">Numbers</a></h3>
<p>You've already encountered the <code>Number</code> data type:</p>
<pre><code class="language-js">const age = 20;
console.log(typeof age); // number
</code></pre>
<p>Any integer or real number is a <code>Number</code>:</p>
<pre><code class="language-js">console.log(typeof 42); // number
console.log(typeof -20); // number
console.log(typeof 3.4); // number
console.log(typeof -1.7); // number
</code></pre>
<p>You can perform arithmetic on numbers using the usual arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>.
There is also the <code>%</code> (modulo) operator which returns the remainder of a division.
Finally, there is the <code>**</code> operator which does exponentiation:</p>
<pre><code class="language-js">const a = 3;
const b = 4;
console.log(a + b); // 7
console.log(a - b); // -1
console.log(a * b); // 12
console.log(a / b); // 0.75
console.log(a % b); // 3
console.log(a ** b); // 81
</code></pre>
<p>You can also use the <strong>shorthand assignment operators</strong> to combine asssignment and arithmetic operators:</p>
<pre><code class="language-js">let a = 3;
a += 4;
console.log(a); // 7
a -= 2;
console.log(a); // 5
a *= 3;
console.log(a); // 15
a /= 3;
console.log(a); // 5
a %= 3;
console.log(a); // 2
a **= 5;
console.log(a); // 32
</code></pre>
<p>You also use the <strong>postfix increment</strong> and the <strong>postfix decrement</strong> operators to increment or decrement a value by 1:</p>
<pre><code class="language-js">let a = 4;
a++;
console.log(a); // 5
a--;
console.log(a); // 4
</code></pre>
<p>So far, so obvious.
However there are also some other things which have type <code>Number</code> like <code>Infinity</code>.
<code>Infinity</code> is a special value that represents mathematical infinity:</p>
<pre><code class="language-js">console.log(typeof Infinity); // number
</code></pre>
<p>Additionally there is a special value called <code>NaN</code> (short for "not a number").
For example the result of <code>0 / 0</code> is <code>NaN</code>:</p>
<pre><code class="language-js">console.log(0 / 0); // NaN
</code></pre>
<p>Hilariously, <code>NaN</code> itself is a number (despite the name):</p>
<pre><code class="language-js">console.log(typeof NaN); // number
</code></pre>
<p>Don't let that confuse you.</p>
<p>Another important thing about numbers is that you need to be careful when you are trying to perform operations with real numbers.
For example if you add <code>0.1</code> and <code>0.2</code> you get a weird result:</p>
<pre><code class="language-js">console.log(0.1 + 0.2); // 0.30000000000000004
</code></pre>
<p>This is not the fault of JavaScript, but instead has to do with the limitations of trying to represent numbers with a potentially infinite amount of digits on a finite hardware.</p>
<blockquote>
<p>We will not go into great detail in this book about this problem.
If you're interested in more details we encourage you to have a look at the IEEE754 standard.</p>
</blockquote>
<h3 id="booleans"><a class="header" href="#booleans">Booleans</a></h3>
<p>Another primitive type is the <code>Boolean</code> type.
This allows you to represent values which are either <code>true</code> or <code>false</code>:</p>
<pre><code class="language-js">const thisBookIsAwesome = true;
const thisBookSucks = false;
console.log(typeof thisBookIsAwesome); // boolean
console.log(typeof thisBookSucks); // boolean
</code></pre>
<p>You can do simple logic using the logical operators <code>&amp;&amp;</code> (which denotes <strong>and</strong>), <code>||</code> (which denotes <strong>or</strong>) and <code>!</code> (which denotes <strong>not</strong>).</p>
<p>The <code>&amp;&amp;</code> (<em>and</em>) operator takes two values and evaluates to <code>true</code> only if both values are <code>true</code>.
Otherwise it evaluates to <code>false</code>:</p>
<pre><code class="language-js">console.log(true &amp;&amp; true); // true
console.log(false &amp;&amp; true); // false
console.log(true &amp;&amp; false); // false
console.log(false &amp;&amp; false); // false
</code></pre>
<p>The <code>||</code> (<em>or</em>) operator takes two values and evaluates to <code>true</code> if <em>at least one</em> of the values is <code>true</code>.
Otherwise it evaluates to <code>false</code>:</p>
<pre><code class="language-js">console.log(true || true); // true
console.log(false || true); // true
console.log(true || false); // true
console.log(false || false); // false
</code></pre>
<p>The <code>!</code> (<em>not</em>) operator takes a single value and simply negates it, i.e. "switches" a value to it's opposite:</p>
<pre><code class="language-js">console.log(!true); // false
console.log(!false); // true
</code></pre>
<p>Here is an example with all the operators together:</p>
<pre><code class="language-js">const b1 = true;
const b2 = false;
console.log(b1 &amp;&amp; b2); // false
console.log(b1 || b2); // true
console.log(!b1); // false
</code></pre>
<blockquote>
<p>Note that technically all the logical operators can take <em>any</em> value (not just boolean values).
The result of the logical operator application is then dependent on whether the values are <em>truthy</em> or <em>falsy</em>.
We will discuss this later.</p>
</blockquote>
<p>A boolean variable usually occurs as the result of an expression.
Often it is the result of an expression containing the <strong>strict equality operator</strong> (<code>===</code>) which allows us to compare the values of variables:</p>
<pre><code class="language-js">const x1 = 5;
const x2 = 10;
const x3 = 5;
console.log(x1 === x1); // true
console.log(x1 === x2); // false
console.log(x1 === x3); // true
</code></pre>
<blockquote>
<p>There is also another equality operator (<code>==</code>) which performs various type coercions before doing the equality comparison.
This operator can be best described as an April Fools' joke that somehow made it into the language.
<em>Never use it</em>.</p>
</blockquote>
<p>If you want to write <em>not equals</em> you can use <code>!==</code>:</p>
<pre><code class="language-js">console.log(5 !== 10); // true
console.log(5 !== 5); // false
</code></pre>
<p>Additionally you can also check if one value is less than or greater than another value.
This is most commonly done with numbers:</p>
<pre><code class="language-js">console.log(2 &lt; 3); // true
console.log(2 &lt;= 3); // true
console.log(2 &gt; 3); // false
console.log(2 &gt;= 3); // false
</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Another primitive data type is the <code>String</code> type.
A string is simply a sequence of characters and is used to represent text.
Strings are usually written using single quotes in JavaScript:</p>
<pre><code class="language-js">const s = 'Some text';
console.log(typeof s); // string
</code></pre>
<blockquote>
<p>Note that it's also possible to write strings using double quotes, however in most projects strings are written using single quotes.
We will stick to this convention.</p>
</blockquote>
<p>The <code>+</code> operator works on strings and does concatenation:</p>
<pre><code class="language-js">const s1 = 'Next.js ';
const s2 = 'book';
console.log(s1 + s2); // Next.js book
</code></pre>
<p>Note that instead of doing concatenation all the time you can also use <strong>template strings</strong> (also called template literals).
This allows writing JavaScript expressions directly inside strings.
Consider the following example:</p>
<pre><code class="language-js">const s = 'world';
const greeting = `Hello ${s}!`;
console.log(greeting); // Hello world!
</code></pre>
<p>Template strings are written using backticks (<em>not</em> single quotes).
They may contain so called <em>placeholders</em> which are expressions embedded inside <code>${...}</code>.
These expressions can be any valid JavaScript expression that evaluates to a value implicitly convertible to a string.
JavaScript will then try to convert any value inside the placeholder to a string:</p>
<pre><code class="language-js">console.log(`2 + 2 = ${2 + 2}`); // 2 + 2 = 4
</code></pre>
<p>You can get the length (i.e. the number of characters) of a string like this:</p>
<pre><code class="language-js">const s = 'MERN book';
console.log(s.length); // 9
</code></pre>
<blockquote>
<p>Note that JavaScript does not have a special "character" data type (unlike Java for example).
Instead, characters are simply strings of length 1.</p>
</blockquote>
<p>There is much more to strings and we will return to them later.</p>
<h3 id="undefined"><a class="header" href="#undefined">Undefined</a></h3>
<p>Finally there is one more primitive type that is of interest to us, namely <code>undefined</code>.
There is only one value of this type: <code>undefined</code>.
If a variable has the value <code>undefined</code> this (quite logically) means that it hasn't been defined.
For example, whenever you have a variable that has been initialized, but not assigned to, it will automatically have the value and therefore the type <code>undefined</code>.</p>
<pre><code class="language-js">let someVariable;
console.log(someVariable); // undefined
console.log(typeof someVariable); // undefined
</code></pre>
<p>You can also manually assign the <code>undefined</code> value to a variable:</p>
<pre><code class="language-js">let someVariable = undefined;
console.log(someVariable); // undefined
console.log(typeof someVariable); // undefined
</code></pre>
<p>An important operator to know is the nullish coalescing operator <code>??</code>.
This operator takes two values and check if the left-hand side is <code>undefined</code> (or <code>null</code> - a value that we will not pay much attention to).
If the left value is <code>undefined</code> or <code>null</code> the nullish coalescing operator evaluates the expression to the right-hand side, otherwise it returns the left-hand side:</p>
<pre><code class="language-js">console.log(undefined ?? 1); // 1
console.log(0 ?? 1); // 0
</code></pre>
<p>The <code>??</code> operator is commonly used to provide useful default values.</p>
<blockquote>
<p>Note that <code>string</code>, <code>number</code>, <code>boolean</code> and <code>undefined</code> are not the only primitive data types.
However the other primitive data types will not be relevant for this book.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arrays-and-objects"><a class="header" href="#arrays-and-objects">Arrays and Objects</a></h2>
<div style="text-align: right"> <i> The object of the superior programmer is truthy. <br> — Confucius </i> </div>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Let's say you are writing a task application (<em>how did I come up with that example?</em>) and you need to store a bunch of tasks.
You could of course declare a separate variable for every task like this:</p>
<pre><code class="language-js">const task1 = 'First task';
const task2 = 'Second task';
const task3 = 'Third task';
</code></pre>
<p>However this would quickly become very <em>tedious</em>.
In addition you may want to add or delete tasks.
Adding and deleting variables will become even more <em>tedious</em>.
It would become almost as <em>tedious</em> as repeating the word <em>tedious</em> over and over.
Did we mention that this is really <em>tedious</em>?</p>
<p>As you can see, we need a way to store multiple values in a single variable.</p>
<p>A JavaScript <strong>array</strong> is an ordered collection of multiple values.
You can declare an array using an <strong>array literal</strong> (also called an <em>array initializer</em> in this context):</p>
<pre><code class="language-js">const tasks = ['First task', 'Second task', 'Third task'];
</code></pre>
<p>Note that an array is no longer a primitive type, instead arrays have the type <code>object</code>:</p>
<pre><code class="language-js">console.log(typeof tasks); // object
</code></pre>
<p>You can access individual elements of an array using the index notation.
This works by writing the name of the array, followed by the position of the element you want to retrieve inside square brackets.
Note that when we count the indices (positions), we start at <code>0</code>, <em>not</em> at <code>1</code>:</p>
<pre><code class="language-js">console.log(tasks[0]); // First task
console.log(tasks[1]); // Second task
</code></pre>
<p>If the array index is too big, trying to access the element at that index will return <code>undefined</code>:</p>
<pre><code class="language-js">console.log(tasks[3]); // undefined
</code></pre>
<p>You can get the length of an array by using <code>.length</code>:</p>
<pre><code class="language-js">console.log(tasks.length); // 3
</code></pre>
<blockquote>
<p>Note that even though the <code>tasks</code> array is declared as a constant here, you can still change the <em>contents</em> of the array.
However you can't <em>reassign</em> <code>tasks</code> to something else, i.e. you can't write something like <code>tasks = [1]</code>.</p>
</blockquote>
<p>JavaScript has some elegant syntax for working with arrays.
If you want to assign variables based on values of an array, you would normally have to do something like this:</p>
<pre><code class="language-js">const firstTask = tasks[0];
const secondTask = tasks[1];
const thirdTask = tasks[2];
</code></pre>
<p>This is (you guessed it) <em>tedious</em>.
Instead you can use the <strong>array destructuring assignment</strong>:</p>
<pre><code class="language-js">const [firstTask, secondTask, thirdTask] = tasks;
console.log(secondTask); // Second task
</code></pre>
<p>If you only care about some of the elements, you can use the <strong>spread</strong> (<code>...</code>) syntax:</p>
<pre><code class="language-js">const [firstTask, ...otherTasks] = tasks;
</code></pre>
<p>Something that commonly trips up beginners is trying to <em>copy</em> an array.
Let's say you have an array of numbers called <code>arr</code> and you want to create a copy called <code>arr2</code>.
You would probably try something like</p>
<pre><code class="language-js">const arr = [1, 2, 3, 4];
const arr2 = arr;
</code></pre>
<p>This is <em>wrong</em>.
Let's try changing the first element of <code>arr</code> and look at <code>arr[0]</code> and <code>arr2[0]</code>:</p>
<pre><code class="language-js">arr[0] = 5;
console.log(arr[0]); // 5
console.log(arr2[0]); // 5
</code></pre>
<p>Uh-oh!
That's probably not what we want.
The reason for this behaviour is that <code>arr</code> and <code>arr2</code> both point to the same array.
Remember how we were careful to introduce a variable <em>as a storage location together with a symbolic name</em>?
Well, it turns out that <em>different symbolic names</em> may refer to the <em>exact same storage location</em>.
You can visualize it like this:</p>
<p><img src="chapter1/images/array-copy-incorrect.png" alt="" /></p>
<p>Here we have a storage location containing the values <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code> somewhere.
We also have two symbolic names <code>arr</code> and <code>arr2</code>.
While the symbolic names are different, they point to the same storage location.
Therefore if we change the storage location, we will observe a change via both symbolic names.</p>
<p>In order to actually copy the values, we can use the spread syntax as this will <em>copy</em> the values:</p>
<pre><code class="language-js">const copied = [...arr];
</code></pre>
<p>Let's check that this is indeed an actual copy:</p>
<pre><code class="language-js">arr[0] = 5;
console.log(arr[0]); // 5
console.log(copied[0]); // 1
</code></pre>
<p>This looks good.
Here is the mental picture you should have in your head for copying an array:</p>
<p><img src="chapter1/images/array-copy-correct.png" alt="" /></p>
<blockquote>
<p>If you only briefly skimmed the section on array destructuring and the spread syntax, go right back and read it carefully.
These two concepts will come up <em>a lot</em> in the following chapters (much more often than you think right now).</p>
</blockquote>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<p>Let's return to our imaginary (as of now) task application.
A task will probably be something more than just a string.
For example it might contain an ID, a title and a description.
We could again store these in constants:</p>
<pre><code class="language-js">const taskId = 1;
const taskTitle = 'Read the Next.js book';
const taskDescription = 'Read and understand the Next.js book.';
</code></pre>
<p>As you can probably guess, this will quickly become <em>tedious</em> (oh no, not this again).
<strong>Objects</strong> to the rescue!
These allow us to store name-value pairs inside a single variable.
Here is how we might create a <code>task</code> object that contains all the information we want to know about a task:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>Every such value is called a <strong>property</strong>.
We can access properties using the dot notation or the square bracket notation.
For example to access the <code>title</code> property of the <code>task</code> object, you would write <code>task.title</code> or <code>task['title']</code>.
Try it out:</p>
<pre><code class="language-js">console.log(task.id); // 1
console.log(task.title); // Read the Next.js book
console.log(task.description); // Read and understand the Next.js book.
console.log(task['id']); // 1
console.log(task['title']); // Read the Next.js book
console.log(task['description']); // Read and understand the Next.js book.
</code></pre>
<blockquote>
<p>Note that we will practically always use the dot notation.</p>
</blockquote>
<p>Remember how you accessed the length of an array using <code>arr.length</code>?
You can do that because every array has a property called <code>length</code> that indicates the length of that array.</p>
<p>Properties don't have to be primitive values.
They can also be other objects.</p>
<p>Generally speaking, you can arbitrarily nest objects and arrays.
For example, here is how you can nest an object inside an object:</p>
<pre><code class="language-js">const user = {
  name: 'John Doe',
  task: {
    id: 1,
    title: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
  },
};
</code></pre>
<p>You can access the <code>title</code> property of the <code>user.task</code> object like this:</p>
<pre><code class="language-js">console.log(user.task.title); // Read the Next.js book
</code></pre>
<p>If you try to access a property that doesn't exist, the result will be <code>undefined</code>:</p>
<pre><code class="language-js">console.log(task.date); // undefined
</code></pre>
<p>Sometimes you want to explicitly indicate that a property may be absent.
For example a person may not have a task assigned to them.
You can write something like this:</p>
<pre><code class="language-js">const person = {
  name: 'John Doe',
  task: undefined,
};
</code></pre>
<p>You could also use the <code>null</code> value:</p>
<pre><code class="language-js">const person = {
  name: 'John Doe',
  task: null,
};
</code></pre>
<p>Whether to use <code>undefined</code> or <code>null</code> in this situation is largely convention.
Throughout this book we will always use <code>undefined</code>.</p>
<p>Just as with arrays, you can use the <strong>destructuring assignment</strong> when working with objects:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
const { id, title, description } = task;
</code></pre>
<p>And just as with arrays, you can use the spread syntax:</p>
<pre><code class="language-js">const taskWithAssignee = {
  assignee: 'John Doe',
  ...task,
};
console.log(taskWithAssignee);
</code></pre>
<p>This will output:</p>
<pre><code class="language-json">{
  "assignee": "John Doe",
  "id": 1,
  "title": "Read the Next.js book",
  "description": "Read and understand the Next.js book."
}
</code></pre>
<blockquote>
<p>Note that objects are more than just containers for values.
We will return to this later.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<div style="text-align: right"> <i> Don't push the for loop, it flows by itself. <br> — Ancient Chinese proverb </i> </div>
<h3 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h3>
<p>Quite often, we need to make <em>decisions</em> in our programs.
Let's say we want to display a fancy message when a bunch of tasks are completed.
This is a decision: <em>If</em> all the tasks are completed, <em>then</em> we want to display a message.
Put generally: <em>If</em> a condition holds (is true), <em>then</em> we want to do something.</p>
<p>Conveniently, the language keyword that allows us to accomplish this is called <code>if</code>:</p>
<pre><code class="language-js">const completed = true;
if (completed) {
  console.log('Hooray, you completed all your tasks!');
}
</code></pre>
<p>This would print:</p>
<pre><code>Hooray, you completed all your tasks!
</code></pre>
<p>The general form of an <code>if</code> statement looks like this:</p>
<pre><code class="language-js">if (condition) {
  statements;
}
</code></pre>
<p>If <code>condition</code> is true, then the <code>statements</code> inside the curly braces will be executed.
If <code>condition</code> is false, nothing will happen.</p>
<blockquote>
<p>Note that technically it suffices if the condition is <em>truthy</em> or <em>falsy</em>. We will ignore this detail for now and return to it in a second.</p>
</blockquote>
<p>The simplest condition is a boolean variable.
However, nothing prevents us from writing more complex conditions.
For example, let's say we have a list of uncompleted tasks (conveniently) named <code>tasks</code>.
Then we could check that all tasks have been completed by checking whether <code>tasks</code> is empty (i.e. the length of <code>tasks</code> is zero):</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
}
</code></pre>
<p>Sometimes you need to do something in one case and something else in another case.
The (also conveniently named) <code>else</code> keyword allows you to accomplish exactly that:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
} else {
  console.log('You still have some tasks to complete.');
}
</code></pre>
<p>The general form of an <code>if...else</code> statement looks like this:</p>
<pre><code class="language-js">if (condition) {
  statements1;
} else {
  statements2;
}
</code></pre>
<p>If <code>condition</code> is true, the statements corresponding to <code>statements1</code> will be executed (i.e. the statements inside the curly braces after the <code>if</code>).
If <code>condition</code> is false, the statements corresponding to <code>statements2</code> will be executed (i.e. the statements inside the curly braces after the <code>else</code>).</p>
<p>Note that there may be multiple statements between the curly braces.
This is totally valid:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
  console.log('Congratulations!');
  console.log('No really, you are amazing!');
} else {
  console.log('You still have some tasks to complete.');
  console.log('Do not despair!');
}
</code></pre>
<p>Assuming <code>tasks</code> has a <code>length</code> of <code>0</code> this will print:</p>
<pre><code>Hooray, you completed all your tasks!
Congratulations!
No really, you are amazing!
</code></pre>
<p>Sometimes you need to handle more than two cases.
Since JavaScript was fresh out of keywords at this point, they allowed you to do so using <code>else if</code>:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
} else if (tasks.length === 1) {
  console.log('Only one task left! Go! Go! Go!');
} else {
  console.log('You still have some tasks to complete.');
}
</code></pre>
<p>The general form of an <code>if...else if...else</code> statement looks like this:</p>
<pre><code class="language-js">if (condition1) {
  statements1;
} else if (condition2) {
  statements2;
} /*possibly more else ifs*/ else if (conditionN) {
  statementsN;
} else {
  statementsElse;
}
</code></pre>
<p>Here all the conditions will be checked one after another.
As soon as a condition is true, the corresponding statements will be executed.
If no condition matches, the statements corresponding to <code>statementsElse</code> will be executed.</p>
<p>You can have any number of <code>else if</code> statements.
For example, this is valid:</p>
<pre><code class="language-js">if (tasks.length === 0) {
  console.log('Hooray, you completed all your tasks!');
} else if (tasks.length === 1) {
  console.log('Only one task left! Go! Go! Go!');
} else if (tasks.length === 2) {
  console.log('You have two tasks to do.');
} else if (tasks.length === 3) {
  console.log('There are three tasks left.');
} else {
  console.log('You still have some tasks to complete.');
}
</code></pre>
<p>Note that the <code>else</code> block is not required.
If it's missing and none of the conditions are true, nothing will happen.</p>
<h3 id="truthiness-and-falsiness"><a class="header" href="#truthiness-and-falsiness">Truthiness and falsiness</a></h3>
<p>Note that the condition does not necessary have to be a boolean as JavaScript will automatically evaluate non-boolean values as "truthy" or "falsy" in boolean contexts.
For example you could write something like this:</p>
<pre><code class="language-js">if (1) {
  console.log('1 is truthy.');
} else {
  console.log('1 is falsy.');
}
</code></pre>
<p>This will print "1 is truthy." because JavaScript will consider <code>1</code> to be <code>true</code> in this context since <code>1</code> is a <em>truthy</em> value.</p>
<p>Generally speaking, a <strong>truthy</strong> value is considered to be true when encountered in a boolean context (like a condition).
A <strong>falsy</strong> value is considered to be false when encountered in a boolean context.
The most important falsy values are <code>false</code>, <code>0</code>, <code>''</code> (empty string), <code>null</code> and <code>undefined</code>.
Most other values (like <code>1</code>, <code>[]</code> (empty array), <code>[3]</code>, <code>{ example: 'hello' }</code> etc) are truthy.</p>
<p>Try to <em>avoid using non-boolean values in boolean contexts</em> as it can lead to surprising behaviour.
Nevertheless it's still useful to know about truthiness and falsiness, as it will otherwise trip you up in certain cases.</p>
<h3 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary operator</a></h3>
<p>The <strong>ternary operator</strong> takes a <em>condition</em>, an <em>expression to execute if the condition is truthy</em> and an <em>expression to execute if the condition is falsy</em>.
It looks like this:</p>
<pre><code class="language-js">const doneMsg = 'All tasks are done';
const notDoneMsg = 'There are tasks left';
const msg = done ? doneMsg : notDoneMsg;
</code></pre>
<p>The general form is:</p>
<pre><code class="language-js">condition ? expression1 : expression2;
</code></pre>
<p>You can think of the ternary operator as a short, compact way to write a conditional expression.
The ternary operator evaluates a condition, and if that condition is <code>true</code> (truthy), the result will have the value of the first expression.
If the condition is <code>false</code> (falsy), the result will have the value of the second expression.</p>
<p>There is a very common thing beginning programmers do with ternary operators which looks like this:</p>
<pre><code class="language-js">const finished = tasks.length === 0 ? true : false;
</code></pre>
<p>You should stop for a second and think about why this is unnecessary.</p>
<p><em>Thought</em> about it?
That's right - the expression <code>tasks.length === 0</code> already evaluates to a boolean value.
You can just write</p>
<pre><code class="language-js">const finished = tasks.length === 0;
</code></pre>
<h3 id="optional-chaining"><a class="header" href="#optional-chaining">Optional chaining</a></h3>
<p>Consider the following task object:</p>
<pre><code class="language-js">const nextTask = {
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book',
  date: {
    day: 8,
    month: 6,
    year: 2022,
  },
};
</code></pre>
<p>Let's say we want to access the day of the task.
We can do this by using <code>nextTask.date.day</code>.
But what if the day does not have to be present, i.e. is <em>optional</em>?
This could happen, for example, because the user didn't enter a task.</p>
<p>The object could look like this:</p>
<pre><code class="language-js">const nextTask = {
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book',
};

// or like this if you were to use `null`
const nextTask = {
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book',
  date: null,
};
</code></pre>
<p>Then <code>nextTask.date.day</code> will fail with</p>
<pre><code>Uncaught TypeError: Cannot read properties of undefined (reading 'day')
</code></pre>
<p>This makes sense since <code>nextTask.date</code> will result in <code>undefined</code> and you can't access a property on <code>undefined</code>.
But let's say we would like to access the day and set it to <code>undefined</code> if the <code>date</code> property is not present.
Then we would need to do something like the following:</p>
<pre><code class="language-js">const day = nextTask.date !== undefined ? nextTask.date.day : undefined;
</code></pre>
<p>Here is what this line does:
If <code>nextTask.date</code> is defined, then <code>nextTask.date.day</code> is assigned to <code>day</code>.
If <code>nextTask.date</code> is not defined, the <code>undefined</code> is assigned to <code>day</code>.</p>
<p>Alternatively we could make use of <code>&amp;&amp;</code> and write:</p>
<pre><code class="language-js">const day = nextTask.date &amp;&amp; nextTask.date.day;
</code></pre>
<blockquote>
<p>This is correct because of the way the <code>&amp;&amp;</code> works.
If the first expression is <code>false</code> (or falsy) then <code>&amp;&amp;</code> doesn't look at the second expression and immediately returns the value of the first expression.
If the first expression is <code>true</code> (or truthy) then <code>&amp;&amp;</code> returns the second expression.</p>
</blockquote>
<p>Generally consider an object that has a bunch of values that may be absent (i.e. <code>null</code> or <code>undefined</code>).
Working with such values will be annoying and only grow more cumbersome with deeper nesting.
To avoid all this JavaScript allows you to do <strong>optional chaining</strong>.
This works by writing <code>?.</code> instead of <code>.</code> when trying to work on something that may be <code>undefined</code>.
The above line would then become:</p>
<pre><code class="language-js">const day = nextTask.date?.day;
</code></pre>
<p>Now the result will be <code>undefined</code> instead of giving you a TypeError.</p>
<h3 id="the-switch-statement"><a class="header" href="#the-switch-statement">The <code>switch</code> Statement</a></h3>
<p>The <code>switch</code> statement evaluates an expression and then attempts to match the result against a number of <code>case</code> clauses.
As soon as a <code>case</code> clause is matched all following statements are executed until a <code>break</code> statement is encountered.
If no case matches and a <code>default</code> statement is present, execution will jump to the code after the <code>default</code> statement:</p>
<pre><code class="language-js">switch (tasks.length) {
  case 0:
    console.log('Hooray, you completed all your tasks!');
    break;
  case 1:
    console.log('Only one task left! Go! Go! Go!');
    break;
  case 2:
    console.log('You have two tasks to do.');
    break;
  case 3:
    console.log('There are three tasks left.');
    break;
  default:
    console.log('You still have some tasks to complete.');
}
</code></pre>
<p>Don't forget the <code>break</code> statements, otherwise <em>all the code after the matched case</em> will be executed, which is rarely what you want.</p>
<h3 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h3>
<p>You can use <strong>loops</strong> to repeat an action multiple times (usually depending on some condition).</p>
<p>The <code>while</code> loop allows you to execute a statement as long as a certain condition is true:</p>
<pre><code class="language-js">let counter = 0;

while (counter &lt; 3) {
  console.log(counter);
  counter += 1;
}
</code></pre>
<p>This will log the following lines to the console:</p>
<pre><code>0
1
2
</code></pre>
<p>The <code>do...while</code> loop is similar to the <code>while</code> loop with one subtle difference.
The <code>while</code> loop evaluates the condition <em>before</em> executing the statement.
The <code>do...while</code> loop on the other hand evaluates the condition <em>after</em> executing the statement.</p>
<p>Consider this example:</p>
<pre><code class="language-js">let counter = 0;

do {
  console.log(counter);
  counter++;
} while (counter &lt; 3);
</code></pre>
<p>This will log the following lines to the console:</p>
<pre><code>0
1
2
3
</code></pre>
<p>Because of the way the <code>do...while</code> loop works the statement(s) inside the loop body will always be executed at least once.
The following example will log <code>Hello</code> to the console once despite the condition being <code>false</code>:</p>
<pre><code class="language-js">do {
  console.log('Hello');
} while (false);
</code></pre>
<h3 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h3>
<p>The regular <code>for</code> loop consists of three expressions.</p>
<p>The first expression is the <em>initialization expression</em> and typically initializes some kind of counter.
The second expression is the <em>condition expression</em> and typically checks for some condition.
If the condition is true the statement(s) in the loop body execute, otherwise the loop terminates.
Finally the third expression (sometimes called <em>afterthough expression</em>) is evaluated at the end of each loop iteration and typically advances the counter.</p>
<p>As usual a code example says more than a thousand words:</p>
<pre><code class="language-js">for (let i = 0; i &lt; 3; i++) {
  console.log(i);
}
</code></pre>
<p>This will log the following lines to the console:</p>
<pre><code>0
1
2
</code></pre>
<p>You can use regular <code>for</code> loops to iterate over arrays:</p>
<pre><code class="language-js">const tasks = ['Task 1', 'Task 2', 'Task 3'];

for (let i = 0; i &lt; tasks.length; i++) {
  console.log(tasks[i]);
}
</code></pre>
<p>This will log the following lines to the console:</p>
<pre><code>Task 1
Task 2
Task 3
</code></pre>
<p>However we will soon learn better ways to perform array iteration.</p>
<h3 id="the-break-and-continue-statements"><a class="header" href="#the-break-and-continue-statements">The <code>break</code> and <code>continue</code> Statements</a></h3>
<p>The <code>break</code> statement gives you a tool to prematurely terminate a loop:</p>
<pre><code class="language-js">let counter = 0;

while (counter &lt; 4) {
  console.log(counter);
  counter += 1;

  if (counter === 2) {
    break;
  }
}
</code></pre>
<p>This will log the following lines to the console:</p>
<pre><code>0
1
</code></pre>
<p>The <code>continue</code> statement terminates the rest of the current iteration and continues with the next iteration:</p>
<pre><code class="language-js">let counter = 0;

while (counter &lt; 4) {
  counter += 1;
  if (counter === 2) {
    continue;
  }

  console.log(counter);
}
</code></pre>
<p>This will log the following lines to the console:</p>
<pre><code>1
3
4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<div style="text-align: right"> <i> A function with no purpose is like a dragon with no fire. <br> — Ancient Chinese proverb </i> </div>
<h3 id="declaring-and-calling-functions"><a class="header" href="#declaring-and-calling-functions">Declaring and Calling Functions</a></h3>
<p>In our programs we often need to perform multiple common actions over and over again.
For example we might want to get the list of tasks assigned to a user at various parts of our task application.
Instead of writing code that (essentially) does the same thing again and again we could use a <strong>function</strong>.</p>
<p>Within the <strong>function definition</strong> we would specify what statements should be executed.
Then we can write a <strong>function call</strong> (also called <strong>function invocation</strong>).
This would then actually execute the statements specified in the definition.</p>
<p>We can use this mechanism to group common actions into a function and then just call the function whenever we need to execute those actions.</p>
<p>Here is a very simple function definition:</p>
<pre><code class="language-js">function printGreeting() {
  console.log('Hello world!');
}
</code></pre>
<p>Function definitions begin with the <code>function</code> keyword followed by the function name (in this case <code>printGreeting</code>).
We will cover the meaning of the parentheses in a second, but the curly braces contain the <em>body</em> of the function.
These are all the statements that will be executed when the function is called.
In this case we have one statement, which will simply output <code>Hello world!</code> to the console.</p>
<p>You can call / invoke the <code>printGreeting</code> function like this:</p>
<pre><code class="language-js">printGreeting(); // Hello world!
</code></pre>
<p>You have as many statements as you want inside the function body:</p>
<pre><code class="language-js">function printGreetings() {
  console.log('Hello world!');
  console.log('Hello again!');
}
</code></pre>
<p>These functions are not particularly interesting since they do the exact same thing for every function call.
In this case, we print the exact same greeting(s) every time.
But what if we wanted to (for example) output a different greeting depending on the user?</p>
<p>We can do this by defining <strong>function parameters</strong>.
These allow us to pass values into the function, so that the function can adjust its behaviour <em>depending on those values</em>.</p>
<p>The function parameters go between the parentheses:</p>
<pre><code class="language-js">function printGreeting(user) {
  console.log(`Hello ${user}!`);
}

printGreeting('Jane'); // Hello Jane!
</code></pre>
<p>In this example we have a single parameter called <code>user</code>.
The function prints the greeting with the appropriate user.
Within the function call we then pass the user (in this case <code>Jane</code>) as an <strong>argument</strong> to the function.</p>
<p>We can also <strong>return</strong> values from functions using the <code>return</code> keyword.
This keyword is used to specify the result that the function should produce, which can then be used in other parts of your code.</p>
<p>Here is a function that takes a number and returns the square of that number:</p>
<pre><code class="language-js">function square(num) {
  return num * num;
}
</code></pre>
<p>We can now use the function as follows:</p>
<pre><code class="language-js">const squaredNum = square(3);
console.log(squaredNum); // 9
</code></pre>
<h3 id="default-parameters"><a class="header" href="#default-parameters">Default Parameters</a></h3>
<p>You can use <strong>default parameters</strong> to initialize parameters with default values if no values or <code>undefined</code> is passed:</p>
<pre><code class="language-js">function add(x, y = 1) {
  return x + y;
}

console.log(add(1)); // 2
console.log(add(1, undefined)); // 2
console.log(add(1, 4)); // 5
</code></pre>
<h3 id="rest-parameters"><a class="header" href="#rest-parameters">Rest Parameters</a></h3>
<p>Sometimes it can be useful to pass an arbitrary number of arguments to a function.
This can be done via <strong>rest parameters</strong>:</p>
<pre><code class="language-js">function sum(...args) {
  let result = 0;
  for (let i = 0; i &lt; args.length; i++) {
    result += args[i];
  }
  return result;
}

console.log(sum()); // 0
console.log(sum(1)); // 1
console.log(sum(1, 2)); // 3
console.log(sum(1, 2, 3)); // 6
</code></pre>
<h3 id="functions-are-objects"><a class="header" href="#functions-are-objects">Functions are Objects</a></h3>
<p>Despite the fact that using <code>typeof</code> on function will result in <code>function</code>, functions are really just objects.</p>
<p>This means that we can assign functions as variables, pass them to other functions as arguments and do all the other neat things we can do with primitives and objects.
For example we could assign the <code>square</code> function to a variable:</p>
<pre><code class="language-js">const square = function square(num) {
  return num * num;
};
</code></pre>
<p>We could then call this like a regular function by doing e.g. <code>square(3)</code>.</p>
<p>This is called a <strong>function expression</strong>.
Note that the function may be <strong>anonymous</strong> (i.e. nameless):</p>
<pre><code class="language-js">const square = function (num) {
  return num * num;
};
</code></pre>
<p>The syntax for calling such a function is still the same, e.g. we would still write <code>square(3)</code> to call the function.</p>
<h3 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h3>
<p>There is a shorthand notation available in JavaScript called the <strong>arrow function</strong> notation.
This notation allows you to omit certain keywords in certain situations.
For example here is how you could rewrite the <code>square</code> function using the arrow function notation:</p>
<pre><code class="language-js">const square = (num) =&gt; num * num;
</code></pre>
<p>This is much shorter and less <em>tedious</em> (haha) indeed.</p>
<p>For an arrow function you only have to specify the parameter(s), followed by an arrow, followed by the returned value.
If you have multiple parameters, you need to put them inside parentheses:</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y;
</code></pre>
<p>You can also have multiple statements in the function body, but then you have to specify the <code>return</code> keyword and surround the statements with curly braces:</p>
<pre><code class="language-js">const printAndGreet = (user) =&gt; {
  const greeting = `Hello ${user}`;
  console.log(greeting);
  return greeting;
};
</code></pre>
<p>As you can see this is not too different from a regular function declaration or expression (unlike the <code>square</code> function, where the arrow notation was much shorter).
It is therefore common practice to only use arrow functions for short functions like <code>square</code>.
However this is again just a convention.</p>
<p>One thing you might have noticed is that we only showed you <strong>arrow function expressions</strong>.
This is not an oversight but stems from the fact that there is no way to write a function declaration with the arrow function notation.</p>
<h3 id="instance-methods"><a class="header" href="#instance-methods">Instance Methods</a></h3>
<p>An <strong>instance method</strong> (often just <strong>method</strong> for short) is a function which is a property of an object.</p>
<pre><code class="language-js">const greeter = {
  greet: function () {
    console.log('Hello, world!');
  },
};
</code></pre>
<p>You can call a method like this:</p>
<pre><code class="language-js">greeter.greet(); // Hello, world!
</code></pre>
<p>Methods can refer to the properties of an object using the <code>this</code> keyword which is simply a reference to the current object:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
  longDescription: function () {
    return `${this.title}(ID = ${this.id}): ${this.description}`;
  },
};
</code></pre>
<p>You can call the method by writing <code>task.longDescription()</code>.
This would output:</p>
<pre><code>Read the Next.js book(ID = 1): Read and understand the MERN book.
</code></pre>
<p>Methods can also change properties of objects.</p>
<p>We will not dwell on methods for too long, since we will not use them all that often as this would lead to a <em>ghastly</em> thing called <em>Object-Oriented Programming</em> (OOP for short).
Instead we want you to think <em>functionally</em>, which is what the next section will be about.</p>
<blockquote>
<p>Inevitable disclaimer for <em>certain</em> Java/C#/... people:
The sentence about OOP was a joke and used correctly, OOP has its merits.
We just wanted to be funny.
We're very sorry about that and will now perform the appropriate penance procedure.</p>
</blockquote>
<h3 id="static-methods"><a class="header" href="#static-methods">Static Methods</a></h3>
<p>Static methods are methods that are like regular functions which need to be prefixed with a name.
For example you can use <code>Number.parseInt</code> to parse a string argument:</p>
<pre><code class="language-js">console.log(Number.parseInt('123')); // 123
</code></pre>
<p>Static methods will become important in a few sections, when we introduce a few useful static methods that deal with arrays and objects.</p>
<blockquote>
<p>Our definition of static methods is a bit ugly because the technically correct definition would require the concept of a class, which we're not going to introduce in this book.</p>
</blockquote>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>The <strong>scope</strong> of a variable is the part of the program in which it can be referenced.
There are three scopes that are important right now - the <strong>global scope</strong>, the <strong>function scope</strong> and the <strong>block scope</strong>.</p>
<blockquote>
<p>Later we will also learn about the module scope.</p>
</blockquote>
<p>Consider the following script:</p>
<pre><code class="language-js">let inGlobalScope = 0;

function f() {
  let inFunctionScope = 1;

  if (true) {
    let inBlockScope = 2;
  }
}
</code></pre>
<p>The variable <code>inGlobalScope</code> is in global scope and can be accessed by the entire script.
For example all of these <code>console.log</code> calls will correctly print the value of the variable:</p>
<pre><code class="language-js">let inGlobalScope = 0;

function f() {
  let inFunctionScope = 1;

  if (true) {
    let inBlockScope = 2;

    console.log(inGlobalScope);
  }

  console.log(inGlobalScope);
}

f();
console.log(inGlobalScope);
</code></pre>
<p>This will log:</p>
<pre><code>0
0
0
</code></pre>
<p>The variable <code>inFunctionScope</code> is accessible only from within the function <code>f</code>:</p>
<pre><code class="language-js">let inGlobalScope = 0;

function f() {
  let inFunctionScope = 1;

  if (true) {
    let inBlockScope = 2;

    console.log(inFunctionScope);
  }

  console.log(inFunctionScope);
}

f();
console.log(inFunctionScope); // This will result in an error!
</code></pre>
<p>This will log:</p>
<pre><code>1
1
file.js:16
console.log(inFunctionScope);
            ^

ReferenceError: inFunctionScope is not defined
</code></pre>
<p>Finally the variable <code>inBlockScope</code> is in block scope and is available only in the block of the <code>if</code> statement:</p>
<pre><code class="language-js">let inGlobalScope = 0;

function f() {
  let inFunctionScope = 1;

  if (true) {
    let inBlockScope = 2;

    console.log(inBlockScope);
  }

  console.log(inBlockScope); // This will result in an error!
}

f();
</code></pre>
<p>This will log:</p>
<pre><code>2
file.js:12
  console.log(inBlockScope); // This will result in an error!
              ^

ReferenceError: inBlockScope is not defined
</code></pre>
<h3 id="jsdoc"><a class="header" href="#jsdoc">JSDoc</a></h3>
<p>JSDoc is a markup language that can be used to annotate JavaScript code.
The most important use is to annotate functions.</p>
<p>For example, here is how you could annotate a function using JSDoc:</p>
<pre><code class="language-js">/**
 * Calculates the sum of two numbers.
 *
 * @param {number} a - The first number.
 * @param {number} b - The second number.
 * @returns {number} The sum of a and b.
 */
function sum(a, b) {
  return a + b;
}
</code></pre>
<p>This is useful if you have complex functions with lots of parameters.
Documenting your functions allows other developers to quickly understand their purpose without needing to read the function bodies.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<div style="text-align: right"> <i> A wise coder once said, 'An error ignored is like an ancestor forgotten – it will return with a vengeance.' <br> — Ancient Chinese proverb </i> </div>
<h3 id="the-throw-statement"><a class="header" href="#the-throw-statement">The <code>throw</code> Statement</a></h3>
<p>The <code>throw</code> statement allows you to throw an exception:</p>
<pre><code class="language-js">throw 'Something bad happened';
</code></pre>
<p>Usually error objects are thrown:</p>
<pre><code class="language-js">throw new Error('Something bad happened');
</code></pre>
<blockquote>
<p>The <code>new</code> operator creates a new object (of some class).
We will revisit this operator in more detail later.</p>
</blockquote>
<h3 id="the-trycatch-statement"><a class="header" href="#the-trycatch-statement">The <code>try...catch</code> Statement</a></h3>
<p>The <code>try...catch</code> statement specifies a block of statements to execute "normally" and a block to execute if the "normal" block throws an exception.
The normal block is contained in a <code>try</code> block while the "exception" block is contained in a <code>catch</code> block.
If any statement in the <code>try</code> throws an exception, code execution jumps to the <code>catch</code> block immediately - the rest of the <code>try</code> block is ignored:</p>
<pre><code class="language-js">function divide(x, y) {
  if (y === 0) {
    throw new Error('Division by 0 is a bad idea');
  }

  return x / y;
}

try {
  console.log('try block');
  console.log(divide(3, 0));
} catch (e) {
  console.log('catch block');
}
</code></pre>
<p>This will log:</p>
<pre><code>try block
catch block
</code></pre>
<p>Note that if the <code>try</code> block doesn't throw an exception, the <code>catch</code> block is never executed.</p>
<p>Consider this example:</p>
<pre><code class="language-js">function divide(x, y) {
  if (y === 0) {
    throw new Error('Division by 0 is a bad idea');
  }

  return x / y;
}

try {
  console.log('try block');
  console.log(divide(3, 1));
} catch (e) {
  console.log('catch block');
}
</code></pre>
<p>This will log:</p>
<pre><code>try block
3
</code></pre>
<h3 id="the-finally-block"><a class="header" href="#the-finally-block">The <code>finally</code> Block</a></h3>
<p>The <code>finally</code> block is an optional block that can be used after <code>catch</code> if some cleanup code should always run after the <code>try</code> block:</p>
<pre><code class="language-js">function divide(x, y) {
  if (y === 0) {
    throw new Error('Division by 0 is a bad idea');
  }

  return x / y;
}

try {
  console.log('try block');
  console.log(divide(3, 0));
} catch (e) {
  console.log('catch block');
} finally {
  console.log('finally block');
}
</code></pre>
<p>This will output:</p>
<pre><code>try block
catch block
finally block
</code></pre>
<p>The <code>finally</code> block will become useful once we write more complex code that performs resource management and we need to perform cleanup of a resource regardless of whether an exception is thrown or not.</p>
<h3 id="error-objects"><a class="header" href="#error-objects">Error Objects</a></h3>
<p>Error objects have a <code>name</code> and a <code>message</code> property which can be used to gather information when an error is thrown:</p>
<pre><code class="language-js">function divide(x, y) {
  if (y === 0) {
    throw new Error('Division by 0 is a bad idea');
  }
}

try {
  console.log('try block');
  divide(3, 0);
} catch (e) {
  console.log('catch block');
  console.log(e.name);
  console.log(e.message);
}
</code></pre>
<p>This will log:</p>
<pre><code>try block
catch block
Error
Division by 0 is a bad idea
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-data-structures"><a class="header" href="#basic-data-structures">Basic Data Structures</a></h2>
<div style="text-align: right"> <i> A set is like a wise emperor's court: it welcomes many, but never the same face twice. <br> — Ancient Chinese proverb </i> </div>
<h3 id="more-on-strings"><a class="header" href="#more-on-strings">More on Strings</a></h3>
<p>We already learned about strings (which represent sequences of characters).
We also learned that they can be concatenated using the <code>+</code> operator and that you can get their length using the <code>length</code> property.
However this is not enough to efficiently work with strings.</p>
<p>Luckily, strings offer a wide range of additional functionality for pretty much every use case you will ever need - in this subsection we will briefly look at some of it.</p>
<p>First, you can access individual characters using the <code>charAt</code> function or array brackets:</p>
<pre><code class="language-js">const str = 'Hello';
console.log(str[1]); // e
console.log(str.charAt(1)); // e
</code></pre>
<p>Remember that there is no special character data type in JavaScript, i.e. <code>typeof str[1]</code> is simply <code>'string'</code>.</p>
<p>Strings also offer a wide range of methods, most of which are self-explanatory:</p>
<pre><code class="language-js">const str = 'Hello';
console.log(str.concat(' world')); // Hello world
console.log(str.includes('el')); // true
console.log(str.startsWith('He')); // true
console.log(str.endsWith('llo')); // true
console.log(str.indexOf('l')); // 2
console.log(str.lastIndexOf('l')); // 3
console.log(str.toLowerCase()); // hello
console.log(str.toUpperCase()); // HELLO
</code></pre>
<p>The <code>substring</code> method allows you to return a part of a string.
You need to pass a start index and and end index:</p>
<pre><code class="language-js">console.log(str.substring(1, 3)); // el
</code></pre>
<p>Note that the start index will be <em>included</em> and the end index will be <em>excluded</em> when creating the substring.</p>
<blockquote>
<p>There is also the <code>substr</code> method which is deprecated so don't use it.</p>
</blockquote>
<p>The <code>trim</code> method allows you to remove whitespace from the start and the end of a string.
This is especially useful when you need to process user input and need to remove accidental whitespace at the start and the end of a string:</p>
<pre><code class="language-js">console.log(' Hello '.trim()); // Hello
</code></pre>
<p>The <code>split</code> method splits the string into substring by a delimiter.
For example here is how you might split a comma-separated list into its items:</p>
<pre><code class="language-js">console.log('Task 1, Task 2, Task 3, Task 4'.split(','));
</code></pre>
<p>This will result in the following array:</p>
<pre><code>[ 'Task 1', ' Task 2', ' Task 3', ' Task 4' ]
</code></pre>
<p>Note that the whitespace is not removed by the <code>split</code> method, you would need to iterate over the resulting array and use the <code>trim</code> method on each string to accomplish that.</p>
<h3 id="more-on-arrays"><a class="header" href="#more-on-arrays">More on Arrays</a></h3>
<p>We already learned how to construct arrays and how to work with individual array elements.
However just like strings, arrays have a few additional methods that will often come in handy.</p>
<p>You can check whether an object is an array using the <code>Array.isArray</code> method:</p>
<pre><code class="language-js">console.log(Array.isArray([1, 2, 3])); // true
console.log(Array.isArray('123')); // false
</code></pre>
<p>You can create an array from an object with <code>Array.from</code>.
To successfully use <code>Array.from</code> the object must be <em>convertible to an array</em>.</p>
<p>For example, a string is convertible to an array:</p>
<pre><code class="language-js">console.log(Array.from('123')); // [ '1', '2', '3' ]
</code></pre>
<p>If you try to use <code>Array.from</code> on an object that is not convertible to an array you will get an empty array:</p>
<pre><code class="language-js">console.log(Array.from(2)); // []
</code></pre>
<p>You can create an array from a variable number of arguments by using <code>Array.of</code>:</p>
<pre><code class="language-js">console.log(Array.of(1, 2, 3)); // [ 1, 2, 3 ]
</code></pre>
<p>Just like strings, arrays have a <code>concat</code>, <code>includes</code>, <code>indexOf</code> and <code>lastIndexOf</code> method:</p>
<pre><code class="language-js">console.log([1, 2, 3].concat([4, 5, 6])); // [ 1, 2, 3, 4, 5, 6 ]
console.log([1, 2, 3].includes(2)); // true
console.log(['a', 'b', 'b', 'c'].indexOf('b')); // 1
console.log(['a', 'b', 'b', 'c'].lastIndexOf('b')); // 2
</code></pre>
<p>The <code>join</code> method allows you to concatenate all elements in an array to a string, where the elements are separated by a delimiter:</p>
<pre><code class="language-js">console.log(['H', 'e', 'l', 'l', 'o'].join('')); // Hello
console.log(['H', 'e', 'l', 'l', 'o'].join(',')); // H,e,l,l,o
</code></pre>
<p>You can use the <code>push</code> method to add a new element to the end of an array:</p>
<pre><code class="language-js">const arr = [1, 2, 3];
arr.push(4);
console.log(arr); // [ 1, 2, 3, 4 ]
</code></pre>
<p>The <code>pop</code> element removes the last element of an array:</p>
<pre><code class="language-js">const arr = [1, 2, 3];
arr.pop();
console.log(arr); // [ 1, 2 ]
</code></pre>
<p>The <code>reverse</code> method allows you to reverse an array:</p>
<pre><code class="language-js">const arr = [1, 2, 3];
arr.reverse();
console.log(arr); // [ 3, 2, 1 ]
</code></pre>
<p>Arrays can be nested, resulting in multidimensional arrays.
Accessing an element of such a nested array results in another array (of a lower dimension).
Nested arrays can be flattened with the <code>flat</code> method:</p>
<pre><code class="language-js">const nestedArray = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
console.log(nestedArray[1]); // [ 4, 5, 6 ]
console.log(nestedArray[1][2]); // 6
console.log(nestedArray.flat()); // [ 1, 2, 3, 4, 5, 6 , 7, 8, 9 ]
</code></pre>
<h3 id="the-forof-loop"><a class="header" href="#the-forof-loop">The <code>for...of</code> Loop</a></h3>
<p><code>For..of</code> loops allow you to <em>iterate over arrays and strings</em> (and some other things that we will cover later on) and perform a task for each element / character.
Let's say you want to print all tasks from a list named <code>tasks</code>.
Previously we would have used a regular <code>for</code> loop:</p>
<pre><code class="language-js">const tasks = ['Task 1', 'Task 2', 'Task 3'];
for (let i = 0; i &lt; tasks.length; i++) {
  console.log(tasks[i]);
}
</code></pre>
<p>Instead you can use the <code>for...of</code> loop:</p>
<pre><code class="language-js">const tasks = ['Task 1', 'Task 2', 'Task 3'];
for (let task of tasks) {
  console.log(task);
}
</code></pre>
<p>Both versions will output:</p>
<pre><code>Task 1
Task 2
Task 3
</code></pre>
<p>As we already mentioned, you can use a <code>for..of</code> loop to iterate over a string as well:</p>
<pre><code class="language-js">const str = 'Task';
for (let char of str) {
  console.log(char);
}
</code></pre>
<p>This would output each character of the string, i.e.:</p>
<pre><code>T
a
s
k
</code></pre>
<p>The general syntax of a <code>for..of</code> loop is</p>
<pre><code class="language-js">for (let variable of arrayOrString) {
  statements;
}
</code></pre>
<p>It should be noted that if you don't change the variable inside the loop, you can and should also declare it as <code>const</code>.
Our first <code>for...of</code> example could therefore be rewritten to</p>
<pre><code class="language-js">const tasks = ['Task 1', 'Task 2', 'Task 3'];
for (const task of tasks) {
  console.log(task);
}
</code></pre>
<blockquote>
<p>Just to reiterate, a <code>for...of</code> loop can iterate over more objects than just arrays and strings.
However this is out of scope for this book.</p>
</blockquote>
<h3 id="more-on-objects"><a class="header" href="#more-on-objects">More on Objects</a></h3>
<p>You can use the static methods <code>Object.keys</code> and <code>Object.values</code> to retrieve the keys and values of an object respectively:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};

console.log(Object.keys(task)); // [ 'id', 'title', 'description' ]
console.log(Object.values(task)); // [ 1, 'Read the Next.js book', 'Read and understand the Next.js book.' ]
</code></pre>
<p>You can also use the static method <code>Object.entries</code> to retrieve the key-value pairs of an object:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};

console.log(Object.entries(task));
</code></pre>
<p>This will output:</p>
<pre><code class="language-js">[
  ['id', 1],
  ['title', 'Read the Next.js book'],
  ['description', 'Read and understand the Next.js book.'],
];
</code></pre>
<h3 id="the-forin-loop"><a class="header" href="#the-forin-loop">The <code>for...in</code> Loop</a></h3>
<p>The <code>for...in</code> loop allows you to iterate over the properties of an object:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};

for (const prop in task) {
  console.log(prop);
}
</code></pre>
<p>This will output:</p>
<pre><code>id
title
description
</code></pre>
<h3 id="maps"><a class="header" href="#maps">Maps</a></h3>
<p>A <code>Map</code> object is a collection of a key-value pairs:</p>
<pre><code class="language-js">const capitals = new Map([
  ['Germany', 'Berlin'],
  ['France', 'Paris'],
]);
capitals.set('Spain', 'Madrid');
console.log(capitals.get('France')); // Paris
console.log(capitals.size); // 3
capitals.delete('France');
console.log(capitals.has('France')); // false
</code></pre>
<p>At first glance maps appear to be very similar to objects, however there are a few imporant differences.</p>
<p>First, it is very easy to get the size of a map (using the <code>size</code> property), whereas with objects you would need to keep track of the size manually.</p>
<p>Second, the keys of an object are usually strings, whereas with maps they can have any data type.</p>
<p>It is recommended to use maps if the key-value pairs are unknown until run time (for example because they are determined by user input), all keys have the same type and all values have the same type.</p>
<h3 id="sets"><a class="header" href="#sets">Sets</a></h3>
<p>A <code>Set</code> object is a collection of unique values:</p>
<pre><code class="language-js">const values = new Set([1, 2, 3]);
values.add(4);
console.log(values.has(2)); // true
console.log(values.size); // 4
values.delete(3);
</code></pre>
<p>Note that all values in a set must be unique, i.e. duplicates are not allowed:</p>
<pre><code class="language-js">const values = new Set([1, 2, 3]);
values.add(2);
console.log(values); // Set(3) { 1, 2, 3 }
</code></pre>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>JSON is a data format for data exchange (e.g. on a network) and can basically store nested JavaScript objects and arrays.
While it was heavily inspired by JavaScript, it is a language-independent data format and is in fact used by many other programming languages to exchange data.</p>
<p>Here is an example JSON file:</p>
<pre><code class="language-json">{
  "user": {
    "name": "John Doe",
    "age": 24,
    "hobbies": ["running", "swimming"]
  },
  "group": "Example group"
}
</code></pre>
<blockquote>
<p>Yes, this is exactly the same syntax that you would use in JavaScript to define objects and arrays.</p>
</blockquote>
<p>You can convert a JavaScript value to a JSON string using <code>JSON.stringify</code>:</p>
<pre><code class="language-js">const result1 = JSON.stringify({ x: 1 });
console.log(typeof result1); // 'string'
console.log(result1); // {"x":1}

const result2 = JSON.stringify([1, 2, 3]);
console.log(typeof result2); // 'string'
console.log(result2); // [1,2,3]
</code></pre>
<p>Note that <code>JSON.stringify</code> has some unintuitive behaviours.
For example, running <code>JSON.stringify</code> on a map or a set will always return <code>{}</code>:</p>
<pre><code class="language-js">console.log(JSON.stringify(new Map([[1, 2]]))); // {}
console.log(JSON.stringify(new Set([1, 2]))); // {}
</code></pre>
<p>The reverse operation to <code>JSON.stringify</code> is <code>JSON.parse</code> which takes a JSON string and constructs a JavaScript value from it:</p>
<pre><code class="language-js">const obj = JSON.parse('{"x": 1}');
console.log(typeof obj); // 'object'
console.log(obj); // { x: 1 }

const arr = JSON.parse('[1, 2, 3]');
console.log(typeof arr); // 'object'
console.log(arr); // [ 1, 2, 3 ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functional-thinking"><a class="header" href="#functional-thinking">Functional Thinking</a></h2>
<div style="text-align: right"> <i> Gold can't be pure, but functions can. <br> — Ancient Chinese proverb </i> </div>
<h3 id="pure-functions"><a class="header" href="#pure-functions">Pure Functions</a></h3>
<p>A function is called <strong>pure</strong> if its outputs (the returned values) depend only on its inputs and if the function does not have any <em>side effects</em> (i.e. it doesn't change program state and doesn't write anything to an external data source).</p>
<p>Here is an example of a pure function:</p>
<pre><code class="language-js">const square = (x) =&gt; x * 2;
</code></pre>
<p>Indeed, the output of <code>square</code> depends only on its input and nothing else.
In addition, <code>square</code> doesn't produce any side effects.</p>
<p>Here is an example of a function that is <em>not</em> pure:</p>
<pre><code class="language-js">const x = 2;
const addImpure = (y) =&gt; x + y;
</code></pre>
<p>The output of this function doesn't depend just on its input variables, but also on a global variable <code>x</code>.</p>
<p>Here is another function that's not pure:</p>
<pre><code class="language-js">const hello = () =&gt; console.log('Hello, world!');
</code></pre>
<p>The <code>hello</code> function has a side effect - it outputs something to the console.</p>
<p>Why do we care about all of this?
The fundamental reason is that <em>pure functions are very easy to reason about</em>.
There is practically no room for suprising behaviour.</p>
<p>Consider the above <code>square</code> function.
It takes an input and produces an output that is dependent <em>only on the input</em>.
It doesn't matter what the rest of the program is doing - the function will always produce identical outputs for identical inputs.</p>
<blockquote>
<p>If you are mathematically inclined, pure functions are basically regular mathematical functions.
They take an input which is a member of some domain and produce an output which is a member of some codomain.
For example the <code>square</code> function is simply the function f: A → B, f(x) = x² where A and B are certain sets of numbers.
Note that A and B are emphatically <em>not</em> equal to the set of real numbers since of course JavaScript cannot represent every possible real number (we already discussed this).</p>
</blockquote>
<p>All of the above is not true for the <code>addImpure</code> function.
This function can produce <em>different</em> outputs for identical inputs.
This makes it hard very hard to troubleshoot it in case of an error.
After all, you may not know what the (global) state of the program was when the error occured.</p>
<p>Closely related is another very nice property of pure functions - they are <em>easily testable</em>.
There is no need to fake global state as the function output depends only on the input.
Therefore all you need to do is to call the function, pass some input and check whether the output matches the expected output.</p>
<h3 id="immutability"><a class="header" href="#immutability">Immutability</a></h3>
<p>A variable is <strong>immutable</strong> if it is unchangeable.
Otherwise we call it <strong>mutable</strong>.
The more mutability we have inside our program the more can go wrong since it's hard to reason about (global) state.</p>
<p>This is where the alert reader might interject - after all, isn't the purpose of a program to do something?
And how can we achieve that if we don't change state?</p>
<p>A fundamental correction is in order here - the purpose of every program is not <em>to do something</em>, but to <em>manipulate data</em>.
You can of course manipulate data directly by mutating global state like in the following example:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
task.title = 'Next.js book';
</code></pre>
<p>This works for simple objects and changes.
But this will quickly become brittle with growing complexity.
<em>Reasoning about state and state changes is really hard.</em></p>
<p>Instead we can create copies of the objects which contain the changes we need:</p>
<pre><code class="language-js">const newTask = {
  ...task,
  title: 'Next.js book',
};
</code></pre>
<p>Note that we didn't change the original object, but created a copy of the object with a different title.</p>
<p>Immutability and pure functions are closely linked.
The programs that are easiest to understand are the ones where immutable datastructures are passed through pure functions.</p>
<h3 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-order functions</a></h3>
<p>We already know that JavaScript functions are just regular objects.
We even showed an example of how you can assign a function to a variable:</p>
<pre><code class="language-js">const square = (num) =&gt; num * num;
</code></pre>
<p>This allows us do to interesting things.
Because functions are just objects we can <em>pass them to other functions</em>.</p>
<p>Consider an example function that repeats some action <code>n</code> times:</p>
<pre><code class="language-js">function repeat(fun, n) {
  for (let i = 0; i &lt; n; i++) {
    fun();
  }
}
</code></pre>
<p>We can use it like this:</p>
<pre><code class="language-js">const hello = () =&gt; console.log('Hello, world!');
repeat(hello, 4);
</code></pre>
<p>Or even just:</p>
<pre><code class="language-js">repeat(() =&gt; console.log('Hello, world!'), 4);
</code></pre>
<p>Both versions will output:</p>
<pre><code>Hello, world!
Hello, world!
Hello, world!
Hello, world!
</code></pre>
<p>The important things about this is that the <code>repeat</code> function doesn't care what <code>fun</code> is.
Here <code>fun</code> could be a simple <code>console.log</code> or a function which produces a simulated universe.
All the <code>repeat</code> function does is to simply repeat <code>fun</code> the specified number of times.</p>
<p>Functions which take (or return) functions are called <strong>higher-order functions</strong>.</p>
<h3 id="the-trinity-of-map-filter-and-reduce"><a class="header" href="#the-trinity-of-map-filter-and-reduce">The Trinity of <code>map</code>, <code>filter</code> and <code>reduce</code></a></h3>
<p>We now introduce the three most important higher-order functions - <code>map</code>, <code>filter</code> and <code>reduce</code>.
These functions allow you to perform an <em>incredibly</em> rich set of operations on arrays.</p>
<blockquote>
<p>We want to use this blockquote to emphasize <em>how often</em> you will be using <code>map</code>, <code>filter</code> and <code>reduce</code>.</p>
</blockquote>
<p>We will use two running examples throughout the section - an array of <code>numbers</code> and an array of <code>tasks</code>:</p>
<pre><code class="language-js">const numbers = [1, 2, 3, 4];
const tasks = [
  {
    id: 1,
    title: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    timeLogged: 60,
    status: 'In progress',
  },
  {
    id: 2,
    title: 'Write a task app',
    description: 'Write an awesome task app.',
    timeLogged: 0,
    status: 'Todo',
  },
  {
    id: 3,
    title: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    timeLogged: 120,
    status: 'In progress',
  },
];
</code></pre>
<p>The <code>map</code> function takes one argument - a function <code>f</code> to apply to every element of the array.
It returns the array that results from applying <code>f</code> to every element of the original array.</p>
<p><img src="chapter1/images/map.png" alt="" /></p>
<p>Let's say we wanted to square all the elements of <code>numbers</code>.
We could write something like this:</p>
<pre><code class="language-js">const result = [];
for (const number of numbers) {
  result.push(number ** 2);
}
</code></pre>
<p>This is ugly and (you guessed it) <em>tedious</em>.
Instead we can (and should) use the <code>map</code> function:</p>
<pre><code class="language-js">const result = numbers.map((number) =&gt; number ** 2);
console.log(result); // [1, 4, 9, 16]
</code></pre>
<p>Consider another example.
Let's say we wanted to add a long description to all the <code>tasks</code> based on the title and the description.
We can use the <code>map</code> function again:</p>
<pre><code class="language-js">const longTasks = tasks.map((task) =&gt; ({
  ...task,
  longDescription: `${task.title}: ${task.description}`,
}));
</code></pre>
<blockquote>
<p>You can see why the spread syntax is so handy.
Thanks to this <em>incredible innovation</em>, you only need to explicitly specify the object parts where something interesting happens.</p>
</blockquote>
<p>The <code>longTasks</code> array will look like this:</p>
<pre><code class="language-js">[
  {
    id: 1,
    title: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    timeLogged: 60,
    status: 'In progress',
    longDescription: 'Read the Next.js book: Read and understand the Next.js book.',
  },
  {
    id: 2,
    title: 'Write a task app',
    description: 'Write an awesome task app.',
    timeLogged: 0,
    status: 'Todo',
    longDescription: 'Write a task app: Write an awesome task app.',
  },
  {
    id: 3,
    title: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    timeLogged: 120,
    status: 'In progress',
    longDescription: 'Think of a funny joke: Come up with a funny joke to lighten the mood.',
  },
];
</code></pre>
<p>The <code>filter</code> function allows you to select elements from an array based on some condition.
It takes a function <code>f</code> which returns <code>true</code> or <code>false</code> for some input(s).
All elements for which <code>f</code> returns <code>true</code> are kept, all elements for which <code>f</code> returns <code>false</code> are thrown away.</p>
<blockquote>
<p>A function which returns <code>true</code> or <code>false</code> is commonly referred to as a <em>predicate</em>.</p>
</blockquote>
<p>For example let's say we want to select all even elements from <code>numbers</code>.
Here is the non-functional way:</p>
<pre><code class="language-js">const result = [];
for (const number in numbers) {
  if (number % 2 === 0) {
    result.push(number ** 2);
  }
}
</code></pre>
<p>Ugh!
For loops and if statements all over the place.
So <em>non-functional</em>.
Let's rest our eyes and consider the <em>functional</em> approach:</p>
<pre><code class="language-js">const result = numbers.filter((number) =&gt; number % 2 === 0);
</code></pre>
<p>The <code>filter</code> function also works in more complicated scenarios.
For example we might want to select all tasks from the <code>tasks</code> array which have the status <code>'Todo'</code>.</p>
<p>Think for a moment what the appropriate predicate would be.</p>
<p>That's right, it looks like this:</p>
<pre><code class="language-js">const todoTasks = tasks.filter((task) =&gt; task.status === 'Todo');
</code></pre>
<p>Finally there is the <code>reduce</code> function which (you guessed it) <em>reduces</em> an array to a single value.
The <code>reduce</code> function moves over an array from left to right and keeps track of a value (a so called <em>accumulator</em>).
At every element of the array it recomputes the accumulator based on a function <code>f</code> (this function <code>f</code> is the first argument of the <code>reduce</code> function).
The second argument of the reduce function is the initial value.</p>
<p>Here is how we might compute the sum of an array:</p>
<pre><code class="language-js">const sum = numbers.reduce((acc, curr) =&gt; acc + curr, 0);
</code></pre>
<p>Basically this is what happens:</p>
<p>The <code>reduce</code> function looks at <code>acc</code> (which is the initial value, i.e. <code>0</code> at the beginning) and <code>curr</code> (which is <code>1</code>), produces <code>acc + curr</code>, and sets this as the new accumulator (i.e. the new accumulator is <code>1</code>).</p>
<p>Next the <code>reduce</code> function again looks at <code>acc</code> (which is now <code>1</code>) and <code>curr</code> (which is <code>2</code>), produces <code>acc + curr</code>, and sets this as the new accumulator (i.e. the new accumulator is <code>3</code>).</p>
<p>The next update results in the accumulator being <code>6</code> and the final update result in the accumulator being <code>10</code>.
Therefore <code>sum</code> will be <code>10</code>.</p>
<p>For another example, let's say we would like to compute the total logged time (i.e. the time logged for all the tasks combined).
This would look like this:</p>
<pre><code class="language-js">const totalTime = tasks.reduce((curr, task) =&gt; task.timeLogged + curr, 0);
</code></pre>
<blockquote>
<p>We recommend that you try to reason through this <code>reduce</code> for a deeper understanding of this topic.</p>
</blockquote>
<p>Note that unlike <code>map</code> and <code>filter</code>, you should use <code>reduce</code> sparingly as it's very easy to write <em>very convoluted</em> code with <code>reduce</code>.
If you find yourself writing extremely complicated <code>reduce</code> expressions, you should consider using for loops and if statements instead.</p>
<h3 id="more-higher-order-functions"><a class="header" href="#more-higher-order-functions">More Higher-Order Functions</a></h3>
<p>While <code>map</code>, <code>filter</code> and <code>reduce</code> are the most known higher-order functions, JavaScript defines many more.
It is worthwhile to get to know them since they will make a lot of tasks easier.</p>
<p>The <code>find</code> method returns the first element in an array that satisfies some predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.find((x) =&gt; x &gt; 9)); // 12
</code></pre>
<p>The <code>findIndex</code> method is similar, except that it returns the <em>index</em> of the first element in an array that satisfies some predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.findIndex((x) =&gt; x &gt; 9)); // 3
</code></pre>
<p>The <code>every</code> method checks whether all elements in an array satisfy a predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.every((x) =&gt; x % 2 === 0)); // true
console.log(numbers.every((x) =&gt; x &lt; 9)); // false
</code></pre>
<p>The <code>some</code> method checks whether there is at least one element in an array that satisfies a predicate:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
console.log(numbers.some((x) =&gt; x &lt; 9)); // true
console.log(numbers.some((x) =&gt; x % 2 !== 0)); // false
</code></pre>
<p>The <code>forEach</code> method executes some function for every array element.
This is very similar to a for loop (hence the name):</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.forEach((x) =&gt; console.log(x));
</code></pre>
<p>This will output:</p>
<pre><code>2
8
4
12
6
10
</code></pre>
<h3 id="sorting-arrays"><a class="header" href="#sorting-arrays">Sorting Arrays</a></h3>
<p>The <code>sort</code> method can be used to sort the elements of an array:</p>
<pre><code class="language-js">const tasks = ['Task 2', 'Task 1', 'Task 3'];
tasks.sort();
console.log(tasks); // [ 'Task 1', 'Task 2', 'Task 3' ]
</code></pre>
<p>The default sort order is ascending and elements are sorted by converting them to strings and then sorting the strings lexicographically.
However this may not be what you want, especially when you're trying to sort numbers:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.sort();
console.log(numbers); // [ 10, 12, 2, 4, 6, 8 ]
</code></pre>
<p>If you want to sort differently, you need to specify a <strong>comparison function</strong> <code>compareFn</code>.
This takes two arguments <code>a</code> and <code>b</code> and returns a number whose sign indicates the relative order of the elements in the sorted array.</p>
<p>If <code>compareFn(a, b)</code> is greater than <code>0</code> then <code>a</code> should be sorted after <code>b</code>.</p>
<p>If <code>compareFn(a, b)</code> is smaller than <code>0</code> then <code>a</code> should be sorted before <code>b</code>.</p>
<p>If <code>compareFn(a, b)</code> is equal than <code>0</code> then the original order of <code>a</code> and <code>b</code> should be kept.</p>
<p>For example, if you want to sort numbers in an ascending manner, you should specify the comparison function <code>(x, y) =&gt; x - y</code>.
After all, if <code>x - y</code> is greater than <code>0</code> then <code>y</code> will be sorted after <code>x</code> (which is exactly what you want).
Similarly, if <code>x - y</code> is smaller than <code>0</code> then <code>y</code> will be sorted before <code>x</code> (which is again what you want).</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.sort((x, y) =&gt; x - y);
console.log(numbers); // [ 2, 4, 6, 8, 10, 12 ]
</code></pre>
<p>If you would want to sort numbers in a descending manner, you would need to change your comparison function to <code>(x, y) =&gt; y - x</code>:</p>
<pre><code class="language-js">const numbers = [2, 8, 4, 12, 6, 10];
numbers.sort((x, y) =&gt; y - x);
console.log(numbers); // [ 12, 10, 8, 6, 4, 2 ]
</code></pre>
<p>You can use the comparison function to sort arbitrary objects as well.
For example, here is how you could sort the <code>tasks</code> array by the <code>timeLogged</code>:</p>
<pre><code class="language-js">tasks.sort((task1, task2) =&gt; task1.timeLogged - task2.timeLogged);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h2>
<div style="text-align: right"> <i> - proverb Ancient Chinese <br> is hard Asynchronous programming </i> </div>
<h3 id="why-asynchronous-programming"><a class="header" href="#why-asynchronous-programming">Why Asynchronous Programming?</a></h3>
<p>We often need to execute long-running operations (especially in web development).
For example, we might need to fetch a resource from a server or request camera access from a user.
In the first case, we need to wait for all the network packets to arrive, which might take a long time depending on your network connectivity.
In the second case, we need to wait for the user to grant us access to the resource we require.</p>
<p>We want do be able to do this without "blocking".
To accomplish this, we need to break up with our current "synchronous" programming model where statements are executed one after another.</p>
<p>Consider the following example:</p>
<pre><code class="language-js">function getTask(taskId) {
  return `Task with ID ${taskId}`;
}

const task = getTask(0);
console.log(task);
</code></pre>
<p>The <code>getTask</code> function is a <strong>synchronous function</strong>.
This means that the calling code (i.e. <code>const task = getTask(0)</code>) has to wait until <code>getTask</code> has finished its work to continue.
That is all fine and dandy here, given that <code>getTask</code> should (hopefully) complete its "work" very fast.</p>
<p>But what if <code>getTask</code> represents a long-running operation, like retrieving a task from a server?</p>
<pre><code class="language-js">function getTask(taskId) {
  return retrieveTaskFromServer(taskId);
}

const task = getTask(0);
console.log(task);
</code></pre>
<p>Now the calling code has to wait for the request to complete before it can do anything else.
This will become a huge problem in the browser environment, given that synchronous functions like <code>getTask</code> are "blocking".
Therefore as long as <code>getTask</code> is executing, no other code will be able to run, including code that handles user events.
This means that the user will not be able to select text, click buttons or do anything else with the website, i.e. the website "hangs".</p>
<p>Of course we want to avoid such a nuisance since this will result in the much dreaded <em>negative user experience</em>.</p>
<blockquote>
<p>If you ever clicked a button on a website and everything just freezes for three seconds, this is probably the result of synchronous function being used to handle a long-running task.</p>
</blockquote>
<p>We need a mechanism to start a (potentially) long-running task and still be able to do other things (like respond to user events) instead of blocking until the task is finished.
Once the task is completed, our program needs to be notified with result.</p>
<p>Here is a step-by-step breakdown of what we want to accomplish:</p>
<ol>
<li>Call a function that starts a long-running operation.</li>
<li>The function should return immediately, so that the "main" program is able to do something else.</li>
<li>Once the long-running operation is completed, the "main" program should be notified.</li>
</ol>
<blockquote>
<p>In case you think to yourself right now "this all sounds very complicated and when do I need long-running tasks anyway, maybe I'll skip this section" - don't.
Practically every project you'll write (essentially when doing web development) will contain asynchronous code.</p>
</blockquote>
<h3 id="promises"><a class="header" href="#promises">Promises</a></h3>
<p>The central object in asynchronous JavaScript is the <strong>promise</strong>.
A promise represents the eventual completion (or failure) of an asynchronous operation.
Now that you are sufficiently confused by this opaque definition, we can move on to an actually useful explanation.</p>
<p>Basically a promise is a like an IOU document - it "promises" you that it is currently working on some long-running operation and that it will eventually get back to you with the result of that long-running operation.</p>
<p>To give another metaphor, consider the process of ordering a hamburger at SyncMcBurgers.
For simplicity (and improved metaphormaking) we will pretend that SyncMcBurgers only has a single counter.</p>
<p>In a perfect “synchronous” world, you would walk up to the counter, tell your order to the hardworking employee of the restaurant and then he would immediately create the hamburger right then and there.
However, unless SyncMcBurgers has rediscovered the ancient secret art of instant burgermaking using dark magic, the preparation of a hamburger does not happen immediately (it's a "long-running operation").</p>
<p>Therefore, in reality the following process happens when you try to order something at SyncMcBurgers.
You walk up to the counter and the employee takes your order (a hamburger) and starts preparing the hamburger right there at the counter in front of you.
In the meantime, you have to wait at the counter until the hamburger is finished.</p>
<p>This process has an obvious problem - both you and the employee now block the entire restaurant from doing anything else (remember, there is only a single counter).
No other customer can try to order anything (because you are standing at the counter) and no other employee can take an order anyway (because the employee serving you is blocking the counter with his hamburger preparation).
This doesn't sound like a recipe for success.</p>
<p>After a while the restaurant owners realize this, there is a change in management and SyncMcBurgers rebrands as AsyncMcBurgers.
The important difference between SyncMcBurgers and the new and improved AsyncMcBurgers is a change in the burger ordering process.</p>
<blockquote>
<p>There is still only one counter though.
After all, the managers at AsyncMcBurgers want to respect our metaphor.</p>
</blockquote>
<p>The new process looks as follows.
You walk up to the counter, an employee takes your order and hands it to the kitchen.
Instead of the burger, he hands you receipt, which is a <em>promise</em> (get it?) that you will get your burger after some time.
Now you don't have to stand in front of the counter waiting for the employee to finish.
Instead you take your receipt, leave the counter and the next customer may order.</p>
<p>In case you missed it, this is how every normal fast food restaurant in the world operates - and for good reason (except that normal fast food restaurants usually have more than a single counter).</p>
<p>Armed with these examples, we can now actually understand the definition of a promise.
Again, a promise <em>represents the eventual completion (or failure) of an asynchronous operation</em>.</p>
<p>In this example, the asynchronous operation is the preparation of the hamburger.
This asynchronous operation will eventually complete (the hamburger will be prepared) or fail (there will a problem during the hamburger preparation).
The order receipt that you get represents the eventual (i.e. probably not immediate) completion of the burger prepartion.</p>
<p>Now that we made some sense of the definition, we can introduce the three states of a promise:</p>
<p>We say that a promise is <strong>pending</strong> when it has been created, but the asynchronous operation it represents has not been completed yet.
This would be the case when you already received the order receipt but you're still waiting for the hamburger.</p>
<p>We say that a promise is <strong>fulfilled</strong> when the asynchronous operation it represents has been successfully completed.
This would be the case when the hamburger is successfully prepared and handed to you.</p>
<p>We say that a promise is <strong>rejected</strong> when the asynchronous operation it represents has failed.
This would be the case when (for example) the kitchen spontaneously combusts due to the ongoing AsyncMcBurger dark magic experiments in the backroom lab.</p>
<p>Finally a promise is <strong>settled</strong> when is either fulfilled or rejected, but not pending.</p>
<p>Promises also allow us to associate <strong>handlers</strong> (also called handler functions) with the eventual success or failure.
For example, we could say that when the hamburger is prepared, we want to eat it (or throw it in the trash, which might actually be the preferrable alternative in some cases).</p>
<h3 id="working-with-promises-in-javascript"><a class="header" href="#working-with-promises-in-javascript">Working with Promises in JavaScript</a></h3>
<p>Let's work through an example - fetching a resource from a server via HTTP.
The HTTP protocol will be discussed in more detail later, but basically it enables us to send a request to a server and get a response.
Since network packets don't arrive immediately, this can take a while, so we are dealing with a "long-running operation".</p>
<p>Both the browser as well as Node.js allow us to retrieve a resource from the network via the asynchronous <code>fetch</code> function.
Consider this example:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url).then((response) =&gt; console.log(response));
</code></pre>
<p>This will log the response object we get from <code>https://jsonplaceholder.typicode.com/todos/1</code> to the console (we will learn how to deal with this response object in a second).</p>
<p>We can rewrite the above example in a more explicit manner:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
fetchPromise.then((response) =&gt; console.log(response));
console.log(fetchPromise);
</code></pre>
<p>This is what happens:</p>
<ol>
<li>We call <code>fetch</code> which <em>immediately</em> returns a <em>pending</em> promise.</li>
<li>We pass a handler function into the <code>then</code> method.
The handler function will be called when the <code>fetch</code> succeeds (i.e. the promise returned by <code>fetch</code> is fulfilled).</li>
<li>After a while the <code>fetch</code> succeeds, <code>fetchPromise</code> is fulfilled and the <code>response</code> object is logged.</li>
</ol>
<p>It is important to note <code>fetch</code> returns immediately.
The return value of <code>fetch</code> is a pending promise (that will eventually settle with either a response value or some kind of error).</p>
<p>This is why <code>console.log(fetchPromise)</code> is executed before <code>console.log(response)</code> and you see the following output in the console:</p>
<pre><code>Promise { &lt;pending&gt; }
Response {
    ...
}
</code></pre>
<p>Additionally the <code>then</code> method <em>also</em> returns immediately, after it has attached the handler function to the <code>fetchPromise</code>.
However the execution of the <em>handler function</em> happens only after the promise returned by fetch is fulfilled.</p>
<p>On one hand this is what we want - while we are waiting for the network request to complete, we can do other stuff (like logging <code>fetchPromise</code>).</p>
<p>On the other hand this is the reason why asynchronous programming is often so confusing to beginners - it "breaks" the regular programming model.
When we write synchronous code, we just execute statements one after another.
With asynchronous code this is no longer the case - here we "register" a function to be executed later, do something else, and then at some point the registered function is executed.</p>
<h3 id="chaining-promises"><a class="header" href="#chaining-promises">Chaining Promises</a></h3>
<p>The <code>response</code> object is not terribly useful by itself.
Let's retrieve the "actual" response which is a JSON object.
Here is how the JSON we get from <code>https://jsonplaceholder.typicode.com/todos/1</code> looks like:</p>
<pre><code class="language-json">{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
</code></pre>
<p>The <code>response</code> object has a <code>json</code> method to retrieve the JSON contained in a response.
However, the <code>json</code> method is also asynchronous, so we are again dealing with promises.</p>
<p>Your first instinct might be to write something like this:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
const jsonPromise = fetchPromise.then((response) =&gt; {
  const jsonPromise = response.json();
  jsonPromise.then((json) =&gt; console.log(json));
});
</code></pre>
<p>This is <em>technically</em> not wrong, but it's ugly.
Basically every time we need to add an asynchronous operation to our code that depends on the result of a previous asynchronous operation, we would need to add one level of nesting which will quickly become unreadable.</p>
<p>Luckily for us, the benevolent god-emperors of JavaScript have eliminated this problem by making <code>then</code> return a promise that "resolves" to the result of the handler function.
Therefore instead of nesting promises, we can <strong>chain</strong> promises:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
const fetchPromise = fetch(url);
const jsonPromise = fetchPromise.then((response) =&gt; response.json());
jsonPromise.then((json) =&gt; console.log(json));
</code></pre>
<p>This is (quite appropriately) called <strong>promise chaining</strong>.</p>
<p>Here is what happens, when we call this code:</p>
<ol>
<li>The <code>fetch</code> method immediately returns a pending promise <code>fetchPromise</code>.</li>
<li>The <code>then</code> method of <code>fetchPromise</code> attaches the handler function <code>(response) =&gt; response.json()</code> to the <code>fetchPromise</code> and also immediately returns.
This time the return value is the pending promise <code>jsonPromise</code>.</li>
<li>The <code>then</code> method of <code>jsonPromise</code> attaches the handler function <code>(json) =&gt; console.log(json)</code> and also immediately returns another pending promise (which we ignore here).</li>
<li>After a while the network request initiated by <code>fetch</code> finishes and <code>fetchPromise</code> is fulfilled (with a <code>Response</code> object as its fulfillment value).</li>
<li>Now that <code>fetchPromise</code> is fulfilled the handler function <code>(response) =&gt; response.json()</code> is kicked off and attempts to parse the response as a JSON object.</li>
<li>At some point the JSON parsing is finished and <code>jsonPromise</code> is fulfilled.</li>
<li>Now that <code>jsonPromise</code> is fulfilled the handler function <code>(json) =&gt; console.log(json)</code> is kicked off and the JSON object is logged to the console.</li>
</ol>
<p>A promise chain is basically executed in two stages.</p>
<p>In the first stage the promises are set up and the handler functions are attached using the <code>then</code> method.
This stage happens immediately.</p>
<p>In the second stage the promises are settled and the attached handler functions are actually executed.
This stage can take quite some time, depending on how long the tasks we want to accomplish take.</p>
<blockquote>
<p>This explanation is the most important part of this entire section.
You should pause and think about this promise chain for a second (or maybe even multiple seconds).
If you understand this point, you (mostly) understand asynchronous programming.</p>
</blockquote>
<p>Note that we can rewrite our promise chain to be a bit more elegant:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; response.json())
  .then((json) =&gt; console.log(json));
</code></pre>
<h3 id="handling-errors"><a class="header" href="#handling-errors">Handling Errors</a></h3>
<p>The above code is completely missing one very important point - error handling.
Most long-running operations (especially those that involve external resources like a network or a file system) can fail.
For example <code>fetch</code> will fail (and <code>fetchPromise</code> will thus be rejected) if your network is down.</p>
<p>You can test this - turn off your network and execute the above code again.
You will get a weird error that looks approximately like this:</p>
<pre><code>TypeError: fetch failed
    at Object.fetch (node:internal/deps/undici/undici:11457:11)
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5) {
  cause: Error: getaddrinfo EAI_AGAIN jsonplaceholder.typicode.com
      at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:107:26) {
    errno: -3001,
    code: 'EAI_AGAIN',
    syscall: 'getaddrinfo',
    hostname: 'jsonplaceholder.typicode.com'
  }
}
</code></pre>
<p>Additionally, we will usually want to throw an error if <code>fetch</code> itself succeeds, but the status of the response is "not ok" (we will return to this in more detail in the section about HTTP):</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response.json();
  })
  .then((json) =&gt; console.log(json));
</code></pre>
<p>We want to be able to catch all the errors that can happen and log an error message to the console.
The Promise API gives us the appropriately named <code>catch</code> method to accomplish this.
We simply add a catch handler to the end of our promise chain - it will be called when any of the asynchronous operations fail:</p>
<pre><code class="language-js">const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetch(url)
  .then((response) =&gt; {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response.json();
  })
  .then((json) =&gt; console.log(json))
  .catch((error) =&gt; console.error(error));
</code></pre>
<p>Turn off your network and try running the <code>fetch</code> again.
You will now see an appropriately logged error.
Instead of just crashing, you program can now do something else (like showing an error modal to the user and informing him that something went wrong).</p>
<h3 id="the-async-and-await-keywords"><a class="header" href="#the-async-and-await-keywords">The <code>async</code> and <code>await</code> Keywords</a></h3>
<p>Promises are great, but as discussed, the are not completely intuitive.
We can use <code>async</code> and <code>await</code> keywords to simplify asynchronous code and make it look more like synchronous code.</p>
<p>To this end, we can declare an <code>async</code> function and then use the <code>await</code> keyword to wait for a promise and get its fulfillment value:</p>
<pre><code class="language-js">async function fetchTask(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    const json = await response.json();
    return json;
  } catch (error) {
    console.error(`Could not fetch URL ${url}`);
  }
}

const url = 'https://jsonplaceholder.typicode.com/todos/1';
fetchTask(url).then((json) =&gt; console.log(json));
</code></pre>
<p>Note that for some runtimes you can only use <code>await</code> inside an <code>async</code> function.
This is why we use <code>then</code> with <code>fetchTask</code> instead of <code>await</code>ing the promise returned by <code>fetchTask</code>.</p>
<h2 id="the-void-operator"><a class="header" href="#the-void-operator">The <code>void</code> Operator</a></h2>
<p>The <code>void</code> operator evaluates an expression and returns <code>undefined</code>.
This can used with promises if you simply want to start an asynchronous operation, but you don't care about the result:</p>
<pre><code class="language-js">void fetchTask(url);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<div style="text-align: right"> <i> A wise coder knows that exporting too much is like opening all doors of the house; both invite unexpected guests. <br> — Ancient Chinese proverb </i> </div>
<h3 id="module-system"><a class="header" href="#module-system">Module System</a></h3>
<p>At the moment, the scripts we write are not large and easily fit into a single file.
However, as we begin writing our task application, we will run into the problem that if we try to fit our project into a single file, that file will quickly become unreadable and unmaintainable.</p>
<p>Additionally, we might often want to use third-party libraries (i.e. libraries written by someone else) in our project.
Copy and pasting the code from a third-party library seems like an obviously bad idea.
First, this would make our scripts even less readable.
Second, what do we do if the library receives an update?</p>
<p>Luckily, JavaScript provides us with a mechanism to use code from one file in another file - <strong>modules</strong>.</p>
<blockquote>
<p>Note that we will only discuss ECMAScript modules.
There are other module systems, but we won't cover them right now.</p>
</blockquote>
<h3 id="the-import-and-export-keywords"><a class="header" href="#the-import-and-export-keywords">The <code>import</code> and <code>export</code> Keywords</a></h3>
<p>Let's start our module discussion with a very simple example.
We will create a file containing a function and then try to use that function in another file.</p>
<p>Create a file <code>greeter.js</code> containing the following code:</p>
<pre><code class="language-js">export function greet(name) {
  return `Hello, ${name}`;
}
</code></pre>
<p>Note the <code>export</code> keyword here.
This <strong>exports</strong> the <code>greet</code> function, i.e. it tells JavaScript to make this function available to other files.</p>
<p>We can now <strong>import</strong> the <code>greet</code> function in another file.
Create a file <code>main.js</code> in which we try to use the <code>greet</code> function:</p>
<pre><code class="language-js">import { greet } from './greeter.js';

console.log(greet('John Doe'));
</code></pre>
<p>This is the basic setup, but in order to actually execute this in the browser or in Node.js we need to make some more adjustments.</p>
<h3 id="esm-in-the-browser"><a class="header" href="#esm-in-the-browser">ESM in the Browser</a></h3>
<p>Let's create a file named <code>index.html</code> in which we use <code>main.js</code> as a JavaScript module:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;ESM Demo&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;script type="module" src="main.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>If you just try to open <code>index.html</code> in the browser you will a CORS Error:</p>
<pre><code>Access to script at 'file:///.../main.js' from origin 'null' has been blocked by
CORS policy: Cross origin requests are only supported for protocol schemes:
http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.
</code></pre>
<p>We won't go into the details of CORS, but basically this error happens because ECMAScript modules are subject to the same-origin policy.
We therefore need to serve our files over a server instead of just trying to open them in our browser.</p>
<p>Let's install the <code>http-server</code> package:</p>
<pre><code class="language-sh">pnpm add -g http-server
</code></pre>
<p>Now enter the directory where you stored <code>index.html</code>, <code>main.js</code> and <code>greeter.js</code> and execute the following command:</p>
<pre><code class="language-sh">http-server .
</code></pre>
<p>Go to <code>http://localhost:8080</code>, open the console and you should see <code>Hello, John Doe</code> in your console.</p>
<h3 id="esm-in-nodejs"><a class="header" href="#esm-in-nodejs">ESM in Node.js</a></h3>
<p>To use <code>main.js</code> and <code>greeter.js</code> in Node.js, we will need to create a <strong>project</strong>.
Therefore you need to create the following <code>package.json</code> file in the same directory as <code>main.js</code> and <code>greeter.js</code>:</p>
<pre><code>{
  "name": "projectname",
  "version": "1.0.0",
  "main": "main.js",
  "type": "module"
}
</code></pre>
<blockquote>
<p>Note that it is very important that you specify <code>type</code> as <code>module</code>.
This tells node to interpret JavaScript files as using ESM syntax (which is what we use in this section).</p>
</blockquote>
<p>You can then execute <code>main.js</code> by running:</p>
<pre><code class="language-sh">node main.js
</code></pre>
<blockquote>
<p>We will return to the concept of <code>package.json</code> in more detail later.</p>
</blockquote>
<h3 id="named-exports-and-imports"><a class="header" href="#named-exports-and-imports">Named Exports and Imports</a></h3>
<p>The example above showcased the use of <strong>named exports</strong>.
Here each function is referred by its name when exporting and the same name is used when importing.
You can export multiple functions when performing named exports.</p>
<p>You can create a named export by prefixing a function with the <code>export</code> keyword:</p>
<pre><code class="language-js">export function getGreeting(name) {
  return `Hello ${name}`;
}

export function greet(name) {
  return `Hello ${name}`;
}
</code></pre>
<p>Alternatively you can use an <strong>export list</strong>:</p>
<pre><code class="language-js">function getGreeting(name) {
  return `Hello ${name}`;
}

function greet(name) {
  console.log(getGreeting(name));
}

export { getGreeting, greet };
</code></pre>
<blockquote>
<p>You should use named exports if you need to export several values/functions.</p>
</blockquote>
<p>Note that you can rename exports in an export list:</p>
<pre><code class="language-js">function getImportantGreeting(name) {
  return `Hello ${name}!`;
}

export { getImportantGreeting as getGreeting };
</code></pre>
<p>If you need to import multiple functions, you can do that as well:</p>
<pre><code class="language-js">import { getGreeting, greet } from './greet.js';
</code></pre>
<p>You can also rename imports:</p>
<pre><code class="language-js">import { getGreeting, greet as sayHello } from './greet.js';
</code></pre>
<p>This is useful if you have several modules that export functions with a same name.
For example if you had a module <code>greet</code> that exports the function <code>greet</code> and a module <code>other-greet</code> that exports the function <code>greet</code> as well, you would run into problems if you just tried to import <code>greet</code>:</p>
<pre><code class="language-js">import { greet } from './greet.js';
import { greet } from './other-greet.js';
</code></pre>
<p>Instead you could rename one or both greet functions:</p>
<pre><code class="language-js">import { greet } from './greet.js';
import { greet as otherGreet } from './other-greet.js';
</code></pre>
<h3 id="default-exports-and-imports"><a class="header" href="#default-exports-and-imports">Default Exports and Imports</a></h3>
<p>If you want to have a default function provided by your module, you can use a <strong>default export</strong>:</p>
<pre><code class="language-js">function getGreeting(name) {
  return `Hello ${name}`;
}

export default function greet(name) {
  console.log(getGreeting(name));
}
</code></pre>
<p>Alternatively you could write:</p>
<pre><code class="language-js">function getGreeting(name) {
  return `Hello ${name}`;
}

function greet(name) {
  console.log(getGreeting(name));
}

export default greet;
</code></pre>
<p>Or:</p>
<pre><code class="language-js">function getGreeting(name) {
  return `Hello ${name}`;
}

function greet(name) {
  console.log(getGreeting(name));
}

export { greet as default };
</code></pre>
<p>Note that you <em>can't have more than one default export</em>.</p>
<p>You import the default export like this:</p>
<pre><code class="language-js">import greet from './greet.js';

console.log(greet('John Doe'));
</code></pre>
<p>Alternatively you could use <code>default as</code>:</p>
<pre><code class="language-js">import { default as greet } from './greet.js';

console.log(greet('John Doe'));
</code></pre>
<p>Note that you can import the default export using any name you like:</p>
<pre><code class="language-js">import thingy from './greet.js';
</code></pre>
<blockquote>
<p>You should use default exports if you need to export one particularly import value/function.</p>
</blockquote>
<h3 id="namespace-imports"><a class="header" href="#namespace-imports">Namespace Imports</a></h3>
<p>If you wish to avoid name conflicts (like the <code>greet</code> situation presented previously) you can do even better with namespace imports:</p>
<pre><code class="language-js">import * as greet from './greet.js';

greet.getGreeting('Hello');
</code></pre>
<p>The <code>import * as</code> syntax retrieves all exports available in <code>greet.js</code>, creates a <strong>namespace object</strong> <code>greet</code> and makes all the exports available as a member of that object.
This means that the <code>greet</code> conflict can be resolved like this:</p>
<pre><code class="language-js">import * as greetModule from './greet.js';
import * as otherGreetModule from './other-greet.js';

greetModule.greet('John');
otherGreeetModule.greet('John');
</code></pre>
<h3 id="module-scope"><a class="header" href="#module-scope">Module Scope</a></h3>
<p>We already know the global scope, function scope and block scope.
Now that we've introduced modules, there is one more scope you should know about - the <strong>module scope</strong>.</p>
<p>Each module has it's own scope.
This means that variables and functions declared in a module are <em>not visible to code outside the module</em> unless they are explicitly exported.
Even if a variable or a function is explicitly exported it can't be used in outside code unless they are explicitly imported first.</p>
<p>This ensures that modules don't accidentally interfere with each other.</p>
<p>Consider this example:</p>
<pre><code class="language-js">function getGreeting(name) {
  return `Hello ${name}`;
}

export function greet(name) {
  console.log(getGreeting(name));
}
</code></pre>
<p>Here the <code>getGreeting</code> function is not exported, meaning that it will remain <em>completely private</em> to the module.
Only the <code>greet</code> function can be used (since it is <code>default</code> exported).</p>
<p>Let's try importing <code>getGreeting</code>:</p>
<pre><code class="language-js">import { greet, getGreeting } from './greet.js';
</code></pre>
<p>You will get the following error:</p>
<pre><code>import { greet, getGreeting } from './greet.js';
                ^^^^^^^^^^^
SyntaxError: The requested module './greet.js' does not provide an export named 'getGreeting'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="packages"><a class="header" href="#packages">Packages</a></h2>
<div style="text-align: right"> <i>A prudent developer tends node_modules as a garden, lest it overgrow and obscure the path to enlightenment. <br> — Ancient Chinese proverb </i> </div>
<h3 id="creating-a-package"><a class="header" href="#creating-a-package">Creating a Package</a></h3>
<p>The heart of any JavaScript package is the <code>package.json</code> file.
This should contain a JSON with important information about the package like the <code>name</code> and <code>version</code>.</p>
<p>Here is the minimal <code>package.json</code>:</p>
<pre><code class="language-json">{
  "name": "example-package",
  "version": "1.0.0"
}
</code></pre>
<p>The <code>version</code> field follows a convention called SemVer (short for Semantic Versioning).
This defines that any version of a package (or library) should have the format <code>MAJOR.MINOR.PATCH</code> where <code>MAJOR</code>, <code>MINOR</code> and <code>PATCH</code> are non-negative integers.
Whenever you update a package, you should make a change to the package version.</p>
<p>If you make backward incompatible API changes, you should increment the <code>MAJOR</code> number and reset the other numbers.
For example if you release a big update of a package with the version <code>1.32.2</code> where you change a lot of function signatures you should update the version to <code>2.0.0</code>.</p>
<p>If you add functionality in a backward compatible manner, you should increment the <code>MINOR</code> number and reset the <code>PATCH</code> number.
For example if you release an update of a package with the version <code>1.32.2</code> and you add a couple of new functions you should update the version to <code>1.33.0</code>.</p>
<p>If you just make backward compatible bug fixes, you should increment the <code>PATCH</code> number.
For example if you release an update of a package with the version <code>1.32.2</code> and you fix a bug in one of your functions you should update the version to <code>1.32.3</code>.</p>
<p>The <code>main</code> field can be used to specify the entry point of your package.
This is the primary file that will be loaded if your package is required by a Node.js application.
Since we use ESM for our modules, we will also need to specify <code>"type": "module"</code> in our <code>package.json</code>.</p>
<p>For example, if we want <code>index.js</code> to be the entry point of our package, we would need to specify the following <code>package.json</code> file:</p>
<pre><code class="language-json">{
  "name": "example-package",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js"
}
</code></pre>
<p>Next let's create an ESM module <code>index.js</code>:</p>
<pre><code class="language-js">export function greet(name) {
  console.log(`Hello ${name}`);
}
</code></pre>
<p>You can now use the <code>greet</code> function of your package in other packages that import it.</p>
<blockquote>
<p>We will show an example of this in a second.</p>
</blockquote>
<h3 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing Dependencies</a></h3>
<p>To install dependencies you will need a package manager like <code>npm</code> or <code>pnpm</code>.
The main difference between these is that <code>pnpm</code> stores packages globally meaning that if multiple projects use the same package, <code>pnpm</code> will only store it once and then link to it as needed.</p>
<p>There is also a difference between dependencies and "dev" dependencies.
Regular dependencies are packages that your project needs to run.
"Dev" dependencies are packages that are only needed during development or testing.
These will not be included in a production build.</p>
<p>You can install a dependency by running <code>pnpm add $PACKAGE_NAME</code>.
You can install a "dev" dependency by running <code>pnpm add --save-dev $PACKAGE_NAME</code>.</p>
<p>Let's install the <code>lodash</code> dependency which is a widely used utility library:</p>
<pre><code class="language-js">pnpm add lodash
</code></pre>
<p>The dependency now will appear in your <code>package.json</code>:</p>
<pre><code class="language-json">{
  "name": "example-package",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "lodash": "^4.17.21"
  }
}
</code></pre>
<p>You will also see a <code>pnpm-lock.yaml</code> which specifies the locked package versions:</p>
<pre><code class="language-yaml">lockfileVersion: '6.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

dependencies:
  lodash:
    specifier: ^4.17.21
    version: 4.17.21

packages:
  /lodash@4.17.21:
    resolution:
      {
        integrity: sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==,
      }
    dev: false
</code></pre>
<p>The actual package will be located in the <code>node_modules</code> directory (namely at <code>node_modules/lodash</code>).</p>
<blockquote>
<p>Don't be afraid of the <code>node_modules</code> directory.
There is no black magic there - <code>node_modules</code> simply contains the code of the dependencies you've installed.
In fact, we encourage you to browser through the <code>node_modules/lodash</code> directory and realize that it's just regular JavaScript code.</p>
</blockquote>
<p>Let's now use <code>lodash</code> in our <code>index.js</code>:</p>
<pre><code class="language-js">import _ from 'lodash';

console.log(_.capitalize('hello, world'));
</code></pre>
<p>Execute the file by running <code>node index.js</code>.
This should output:</p>
<pre><code>Hello, world
</code></pre>
<h3 id="scripts"><a class="header" href="#scripts">Scripts</a></h3>
<p>To simplify running scripts, the <code>package.json</code> allows you to define a <code>scripts</code> field:</p>
<pre><code class="language-json">{
  "name": "example-package",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "dependencies": {
    "lodash": "^4.17.21"
  },
  "scripts": {
    "greet": "node index.js"
  }
}
</code></pre>
<p>Now you can run:</p>
<pre><code>pnpm run greet
</code></pre>
<p>This will again output <code>Hello, world</code>.</p>
<p>The <code>scripts</code> mechanism becomes especially useful if you need to execute a long chain of commands.
Instead of repeating the chain of commands over and over again, you can specify a script and then just run that script.</p>
<h3 id="publishing-packages"><a class="header" href="#publishing-packages">Publishing Packages</a></h3>
<p>Let's return to our package from the beginning of this section.</p>
<p>We had this <code>package.json</code> file:</p>
<pre><code class="language-json">{
  "name": "example-package",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js"
}
</code></pre>
<p>And we had this ESM module <code>index.js</code>:</p>
<pre><code class="language-js">export function greet(name) {
  console.log(`Hello ${name}`);
}
</code></pre>
<p>What if we want to make this package available to other people?
We could <strong>publish</strong> our package to the npm repository.
This is in fact where we pulled the <code>lodash</code> package from earlier.</p>
<blockquote>
<p>Please don't actually publish this silly example package to the npm repository.
It is already plenty polluted as it is.
However the steps outlined below will be useful to you, if you plan to actually publish something interesting.</p>
</blockquote>
<p>The publishing process is pretty simple:</p>
<p>First, you need to create an account at <code>npmjs.com</code>.</p>
<p>Second, you need to log in to your account in your terminal by running:</p>
<pre><code class="language-sh">npm login
</code></pre>
<p>Third, you will need to publish the package by running:</p>
<pre><code class="language-sh">pnpm publish --access public
</code></pre>
<p>After you're done, you can verify that the package was published successfully by going to <code>https://www.npmjs.com/package/$YOUR_PACKAGE_NAME</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="writing-decent-code"><a class="header" href="#writing-decent-code">Writing Decent Code</a></h2>
<div style="text-align: right"> <i>He who writes JavaScript with simplicity, rides the dragon of efficiency; he who writes in confusion, invites the monkeys of bugs into his code. <br> — Ancient Chinese proverb </i> </div>
<h3 id="it-just-works"><a class="header" href="#it-just-works">It Just Works</a></h3>
<p>A common misunderstanding among beginner programmers is that if the program runs correctly, then the code must automatically be fine.
A correctly running program is indeed better than a crashing program (a truly shocking insight for some developers).
However code should not only work, but also be maintainable <em>in the future</em>.</p>
<p>This <strong>maintainability</strong> has two aspects:</p>
<ol>
<li>Code should be maintainable by future <em>you</em> in (let's say) six months.</li>
<li>Code should be maintanable by other people that are not you.</li>
</ol>
<blockquote>
<p>We wish to reiterate that there are indeed people that are not you in the world, some of which might even end up on your team.
There are programmers that tend to forget that.</p>
</blockquote>
<p>This section is aimed at giving you a few practical tips to achieve these goals.
It won't make you a great programmer, but it will help you to make your teammates hate you slightly less (which is why the section is called "writing decent code" and not "writing the greatest code of all time").</p>
<h3 id="sensible-naming"><a class="header" href="#sensible-naming">Sensible Naming</a></h3>
<p>The ultimate number one tip for writing better code is as obvious in theory, as it is complicated in practice:</p>
<p><strong>Your variables and functions should have sensible names that describe their purpose.</strong></p>
<p>Consider this simple example:</p>
<pre><code class="language-js">function f(a, s) {
  const r = [];
  for (const i of a) {
    if (i.st === s) {
      r.push(i.su);
    }
  }
  return r;
}
</code></pre>
<p>Well, this code clearly sucks.
It's absolutely unreadable and the unreadability is solely down to really terrible variable names.</p>
<p>Let's rewrite it:</p>
<pre><code class="language-js">function getTaskTitlesByStatus(tasks, status) {
  const taskTitles = [];
  for (const task of tasks) {
    if (task.status === status) {
      taskTitles.push(task.title);
    }
  }
  return taskTitles;
}
</code></pre>
<p>And suddenly the purpose of the code is clear as day.</p>
<p>The function <code>getTaskTitlesByStatus</code> gets all the titles of the tasks that have a certain status.
And we know that, because it is literally in the name of the function!</p>
<p>Not only does the function have a good name (which is important when trying to use this function), but so do the variables (which is important when we need to fix possible mistakes in this function).</p>
<p>Of course, this is a very extreme example (that's on purpose), but it's really incredible how often programmers give terrible names to functions and variables.</p>
<blockquote>
<p>This is the case even for developers that should know better.</p>
</blockquote>
<p>Of course, naming things is usually not as easy as in this example.
There are many legitimate cases where giving something a good name is not trivial, but you should at least always <em>try hard</em> to have sensible names.
The poor soul that will have to fix your bugs six months from now will really thank you for that.</p>
<blockquote>
<p>Note how we wrote <em>try hard</em> and not just <em>try</em>.
The worst code is code containing bad naming.
You should therefore absolutely invest time into thinking about good names for your variables and functions.</p>
</blockquote>
<h3 id="write-small-helper-functions"><a class="header" href="#write-small-helper-functions">Write Small Helper Functions</a></h3>
<p>Most of the time a function is not as simple as <code>getTaskTitlesByStatus</code>, which often leads to many lines of complex code that is hard to understand.
A common practice for such cases is this:</p>
<p><strong>Extract code from complicated functions into helper functions and then call the helper functions</strong>.</p>
<p>Consider a function that takes an array of tasks and returns an array of generated notifications to be shown to the user.</p>
<p>The notifications are generated for urgent tasks (i.e. tasks where the deadline is in the next two days).
Additionally, we generate a notification with the number of uncompleted tasks.</p>
<p>You might write the function like this:</p>
<pre><code class="language-js">function generateNotifications(tasks) {
  const urgentTasks = [];

  let uncompletedTaskCount = 0;

  tasks.forEach((task) =&gt; {
    const today = new Date();
    const twoDaysLater = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 2);

    if (task.deadline &lt;= twoDaysLater) {
      urgentTasks.push(task);
    }

    if (task.status === 'todo' || task.status === 'inprogress') {
      uncompletedTaskCount++;
    }
  });

  const notifications = [];
  if (urgentTasks.length &gt; 0) {
    notifications.push(
      `You have ${urgentTasks.length} urgent tasks. Here they are: ${urgentTasks}.`,
    );
  }

  if (uncompletedTaskCount &gt; 0) {
    notifications.push(`You have ${uncompletedTaskCount} uncompleted tasks.`);
  }

  return notifications;
}
</code></pre>
<p>Try to read this function and understand it - this will probably take up quite some time.</p>
<p>We can massively improve this code by splitting the function into small helper functions:</p>
<pre><code class="language-js">function findUrgentTasks(tasks) {
  const urgentTasks = [];

  const today = new Date();
  const twoDaysLater = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 2);

  tasks.forEach((task) =&gt; {
    if (task.deadline &lt;= twoDaysLater) {
      urgentTasks.push(task);
    }
  });

  return urgentTasks;
}

function countUncompletedTasks(tasks) {
  let uncompletedTaskCount = 0;
  tasks.forEach((task) =&gt; {
    if (task.status === 'todo' || task.status === 'inprogress') {
      uncompletedTaskCount++;
    }
  });
  return uncompletedTaskCount;
}

function generateNotifications(tasks) {
  const urgentTasks = findUrgentTasks(tasks);
  const uncompletedTaskCount = countUncompletedTasks(tasks);

  const notifications = [];
  if (urgentTasks.length &gt; 0) {
    notifications.push(
      `You have ${urgentTasks.length} urgent tasks. Here they are: ${urgentTasks}.`,
    );
  }

  if (uncompletedTaskCount &gt; 0) {
    notifications.push(`You have ${uncompletedTaskCount} uncompleted tasks.`);
  }

  return notifications;
}
</code></pre>
<p>The <code>generateNotification</code> function is now much simpler to read.
Instead of a multiple potentially complex calculations, it contains functions where each function is responsible for exactly one complex calculation.</p>
<p>Note that the loops didn't really change, but they now do isolated things inside helper functions with sensible names.
For example the for loop that calculates the <code>uncompletedTaskCount</code> is now isolated inside the <code>countUncompletedTasks</code> function and therefore its purpose is immediately clear - even before you've read the actual loop.</p>
<h3 id="make-functions-reusable"><a class="header" href="#make-functions-reusable">Make Functions Reusable</a></h3>
<p>There are still some potential improvements that we could make here, one of which is to make the helper functions more reusable.
A practical hint for making functions more reusable is this:</p>
<p><strong>Extract values from function bodies into (default) parameters.</strong></p>
<p>For example <code>findUrgentTasks</code> calculates the future date by adding <code>2</code>.
But what if that changes, or even worse, different users can set a different number of added days for their notifications?</p>
<p>Let's move the number of added days into a default parameter:</p>
<pre><code class="language-js">function findUrgentTasks(tasks, addedDays = 2) {
  const urgentTasks = [];

  const today = new Date();
  const laterDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + addedDays);

  tasks.forEach((task) =&gt; {
    if (task.deadline &lt;= laterDate) {
      urgentTasks.push(task);
    }
  });

  return urgentTasks;
}
</code></pre>
<p>Note how we also renamed <code>twoDaysLater</code> to <code>laterDate</code> since that variable now has a more general purpose.</p>
<h3 id="know-and-use-your-language-features"><a class="header" href="#know-and-use-your-language-features">Know and Use Your Language Features</a></h3>
<p>JavaScript has drastically changed for the better in the past decade - there is no need to write code like it's 2012.
For example <code>getTaskTitlesByStatus</code> could be rewritten in a functional style:</p>
<pre><code class="language-js">function getTaskTitlesByStatus(tasks) {
  return tasks.filter((task) =&gt; task.status === status).map((task) =&gt; task.title);
}
</code></pre>
<p>Same goes for <code>findUrgentTasks</code> and <code>countUncompletedTasks</code>.
You should in fact try to do that yourself.</p>
<p>Generally, the takeaway from the section is this:</p>
<p><strong>Programming languages have a wide variety of features, most of which can make your life easier. Use them.</strong></p>
<h3 id="avoid-deep-nesting"><a class="header" href="#avoid-deep-nesting">Avoid Deep Nesting</a></h3>
<p>Consider a function that filters tasks based on their status, user ID and days until deadline.
We could write it like this:</p>
<pre><code class="language-js">function filterTasks(tasks, status, userId, daysUntilDeadline) {
  const filteredTasks = [];

  for (let i = 0; i &lt; tasks.length; i++) {
    if (tasks[i].status === status) {
      if (tasks[i].assignee === userId) {
        const deadline = new Date(tasks[i].deadline);
        const today = new Date();
        const futureDate = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate() + daysUntilDeadline,
        );

        if (deadline &lt;= futureDate) {
          filteredTasks.push(tasks[i]);
        }
      }
    }
  }

  return filteredTasks;
}
</code></pre>
<p>This looks supremely ugly and hard to read due to the deep nesting of the code.
Luckily, this is pretty easy to fix using two very specific tricks:</p>
<p>First, we can extract the body of the for loop into a helper function:</p>
<pre><code class="language-js">function taskMatchesCriteria(task, status, userId, daysUntilDeadline) {
  if (task.status === status) {
    if (task.assignee === userId) {
      const today = new Date();
      const futureDate = new Date(
        today.getFullYear(),
        today.getMonth(),
        today.getDate() + daysUntilDeadline,
      );

      if (task.deadline &lt;= futureDate) {
        return true;
      }
    }
  }

  return false;
}

function filterTasks(tasks, status, userId, daysUntilDeadline) {
  return tasks.filter((task) =&gt; taskMatchesCriteria(task, status, userId, daysUntilDeadline));
}
</code></pre>
<p>One level of nesting gone already.</p>
<p>For the second trick, we can simplify the <code>taskMatchesCriteria</code> by either flattening the conditions or using early exits.</p>
<p>Flattening the condition is simple:</p>
<pre><code class="language-js">function taskMatchesCriteria(task, status, userId, daysUntilDeadline) {
  const today = new Date();
  const futureDate = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + daysUntilDeadline,
  );

  return task.status === status &amp;&amp; task.assignee === userId &amp;&amp; task.deadline &lt;= futureDate;
}
</code></pre>
<p>However sometimes this is not possible or leads to a very complex logical expression.
In this case we can check the "inverted" conditions one by one and "early exit" if something doesn't match:</p>
<pre><code class="language-js">function taskMatchesCriteria(task, status, userId, daysUntilDeadline) {
  // Early exit number 1
  if (task.status !== status) {
    return false;
  }

  // Early exit number 2
  if (task.assignee !== userId) {
    return false;
  }

  const today = new Date();
  const futureDate = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + daysUntilDeadline,
  );

  return task.deadline &lt;= futureDate;
}
</code></pre>
<p>The general takeaway is this:</p>
<p><strong>Flatten deeply nested code by extracting helper functions and simplifying conditions.</strong></p>
<h3 id="dont-repeat-yourself"><a class="header" href="#dont-repeat-yourself">Don't Repeat Yourself</a></h3>
<p>This is probably one of the most well-known idioms in software development:</p>
<p><strong>Don't repeat yourself.</strong></p>
<p>For example, if you write a book, you shouldn't repeat the subsection heading in your text - that looks ugly and doesn't make any sense.
Only a fool would do that.</p>
<p>The same principle goes for writing code.
Consider the following example:</p>
<pre><code class="language-js">function reportOverdueTasks(tasks) {
  const today = new Date();
  const overdueTasks = tasks.filter((task) =&gt; {
    return task.deadline &lt; today &amp;&amp; task.status !== 'done';
  });
  return overdueTasks.map((task) =&gt; `Task ID: ${task.id}, Title: ${task.title}`).join('\n');
}

function reportCompletedTasks(tasks) {
  const completedTasks = tasks.filter((task) =&gt; task.status === 'done');
  return completedTasks.map((task) =&gt; `Task ID: ${task.id}, Title: ${task.title}`).join('\n');
}
</code></pre>
<p>You might notice that the last line of both functions is essentially the same.
This leads to a problem: If the report format changes, we need to update it multiple times.</p>
<p>Not only does this mean more work, we might even forget to update the report format in some place, leading to inconsistencies in our code.</p>
<p>We can refactor <code>reportOverdueTasks</code> and <code>reportCompletedTasks</code> like this:</p>
<pre><code class="language-js">function formatReport(tasks) {
  return tasks.map((task) =&gt; `Task ID: ${task.id}, Title: ${task.title}`).join('\n');
}

function reportOverdueTasks(tasks) {
  const today = new Date();
  const overdueTasks = tasks.filter((task) =&gt; {
    return task.deadline &lt; today &amp;&amp; task.status !== 'done';
  });
  return formatReport(overdueTasks);
}

function reportCompletedTasks(tasks) {
  const completedTasks = tasks.filter((task) =&gt; task.status === 'done');
  return formatReport(completedTasks);
}
</code></pre>
<p>Again, this is a very simple example, but the general principle holds for more complex situations as well.
If you find yourself repeating very similar code over and over, you should probably extract it into a function.</p>
<p>Remember, that's why we introduced functions in the first place.</p>
<h3 id="think-about-edge-cases"><a class="header" href="#think-about-edge-cases">Think About Edge Cases</a></h3>
<p>One of the big differences between junior programmers and more senior developers is that juniors tend to ignore edge cases and just focus on the "happy path".</p>
<p>Consider this piece of code:</p>
<pre><code class="language-js">const task = tasks.find((task) =&gt; task.id === taskId);
task.assignee = userId;
task.status = 'inprogress';
</code></pre>
<p>This has a big problem: What if <code>taskId</code> is not present in the IDs of <code>tasks</code>?
Then <code>task</code> will be <code>undefined</code> and our program will crash when trying to assign the <code>assignee</code> property to <code>task</code>.</p>
<p>This edge case needs to be handled:</p>
<pre><code class="language-js">const task = tasks.find((task) =&gt; task.id === taskId);
if (task === undefined) {
  console.log(`Task with ID ${taskId} not present`);
} else {
  task.assignee = userId;
  task.status = 'inprogress';
}
</code></pre>
<p>Example operations which can lead to problems if you don't consider edge cases are:</p>
<ul>
<li>division (because you could divide by zero)</li>
<li>processing strings (because strings could be empty or have whitespace at the beginning or the end)</li>
<li>extracting elements from arrays by a condition (because there might be no elements present that match the condition)</li>
<li>processing user input (because users can and will type arbitrary garbage into your application)</li>
</ul>
<p>And of course every time you work with an external resource (like <code>fetch</code>ing something), you need to handle potential errors.</p>
<p>The main takeaway from this sections is:</p>
<p><strong>Don't be satisfied by just writing the happy path. Think about the edge cases.</strong></p>
<h3 id="additional-tips-for-large-projects"><a class="header" href="#additional-tips-for-large-projects">Additional Tips for Large Projects</a></h3>
<p>Now that we gave you a couple of tips for writing better code, there a few things to consider as your project gets larger.</p>
<p>You should try to keep the names in your codebase close to the application domain.
If the client and the project managers talk about tasks and notifications and the UI shows big, fat texts called "Tasks" and "Notifications", then your variable names should probably not be <code>jobs</code> and <code>reports</code>.
You will just needlessly confuse everyone.</p>
<p>Split your code into well structured modules.
Try to follow the <strong>Single Responsibility Principle</strong> where every module is responsible for a particular part of the application.</p>
<p>Document your most important functions using docstrings.</p>
<p>Generally try to not outsmart yourself and stick to writing actual features instead of fancy abstractions that might or might not come in handy later.
Remember, reading and fixing code is much harder than writing it in the first place.
This means that if you write code as smart as you can, you are not going to be able to fix it.</p>
<h3 id="final-remarks"><a class="header" href="#final-remarks">Final Remarks</a></h3>
<p>Well, now that you made it through this section, are you a great programmer?
Unfortunately, the answer is a hard <strong>no</strong>.</p>
<p>If you could become a great programmer by just reading a couple of pages, then there wouldn't be entire book shelves devoted to that topic.</p>
<p>There is only one way to become a good programmer:</p>
<p><strong>You need to actually go out and write projects.</strong></p>
<p>There is no way around it and in the end, experience is king.</p>
<p>But there is one important caveat - you have to actually <em>learn</em> from that experience and reflect on your mistakes.</p>
<p>So go out there, write features, make mistakes and learn something!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-leveling-up-with-typescript"><a class="header" href="#chapter-2-leveling-up-with-typescript">Chapter 2: Leveling Up with TypeScript</a></h1>
<div style="text-align: right"> <i> To employ TypeScript is to light a lantern on the dim path of JavaScript, revealing the stones upon which one may trip. <br> - Ancient Chinese proverb </i> </div>
<p>Now that we learned the basics of JavaScript, we could theoretically dive right into writing our application.
However, JavaScript as a language has a central problem - it does not come with type checking.
For example, there is nothing preventing you from trying to add two objects except the fact that - well - your application will crash and burn.</p>
<p>In general, one the most common error sources are what can be described as type errors: a certain kind of value was used where a different kind of value was expected.
This could be due to simple typos, a failure to understand how to use a library correctly, incorrect assumptions about runtime behavior etc.
The goal of TypeScript is to provide static type checking for JavaScript programs - in other words, TypeScript provides you with tooling that runs before your code is executed (static) and ensures that the types of the program are correct (typechecked).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-typescript"><a class="header" href="#why-typescript">Why TypeScript?</a></h2>
<div style="text-align: right"> <i> Better to wrangle with TypeScript's compiler today, than to wrestle with JavaScript bugs tomorrow. <br> - Ancient Chinese proverb </i> </div>
<h3 id="a-little-story"><a class="header" href="#a-little-story">A Little Story</a></h3>
<p>Consider the following scenario.
You have a JavaScript function <code>showTask(task)</code> which takes a <code>task</code> object and displays the task in a UI (or in the console).</p>
<p>Let's say your <code>task</code> object looks like this:</p>
<pre><code class="language-js">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>Can you pass this object to <code>showTask</code>?
Well, you can't really tell.</p>
<p><em>Maybe</em> the <code>showTask</code> function expects an object that has <code>id</code>, <code>title</code>, <code>description</code> <em>and</em> <code>status</code> fields.
The only way to find out if your <code>task</code> object is a valid input for <code>showTask</code> is to - well - actually pass it and find out.
This is obviously not the ideal workflow (especially if you happen to find out that your object lacked some important properties <em>in production</em>).</p>
<p>Additionally, if the author of the <code>showTask</code> function changes his function to expect additional properties on the <code>task</code> object, they would now have to check all the invocations of <code>showTask</code> to verify that they didn't accidentally break something.</p>
<p>This is where TypeScript comes in.
With TypeScript we would be able to <em>statically type</em> the function by adding <em>type annotations</em> like this:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  title: string;
  description: string;
};

function showTask(task: Task) {
  // Implementation here
}
</code></pre>
<p>Now we know <em>exactly</em> what kind of object <code>showTask</code> expects.
An object that is passed to the function must have an <code>id</code> property which is a <code>number</code>, a <code>title</code> property which is a <code>string</code> and a <code>description</code> property which is also a <code>string</code>.</p>
<p>For example we could call the function like this:</p>
<pre><code class="language-ts">showTask({
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
});
</code></pre>
<p>If we would pass an object that lacks some of the expected properties and run <em>type checks</em> (more on that later) we will get an error long before the bad code can make it anywhere near production.
Even better - your editor will be able to show you that you might have a problem during development:</p>
<pre><code class="language-ts">showTask({
  id: 1,
  title: 'Read the Next.js book',
});
// Most editors will now show a squiggly red line somewhere around here and
// politely scream at you that the object is missing the description property.
</code></pre>
<p>Better still (TypeScript just keeps giving), you now get <em>autocompletion</em> - editors will show possible suggestions for the property names your object should have <em>while you are typing</em>.
This saves an enormous amount of time and effort when writing code.</p>
<p>To summarize, using TypeScript massively enhances your developer workflow which is why nowadays most large projects use TypeScript instead of vanilla JavaScript.</p>
<h3 id="installing-typescript"><a class="header" href="#installing-typescript">Installing TypeScript</a></h3>
<p>You can install the TypeScript compiler by running the following command:</p>
<pre><code class="language-sh">pnpm add -g typescript
</code></pre>
<blockquote>
<p>The <code>-g</code> flag tells <code>pnpm</code> to install the package globally and not just for a particular project.</p>
</blockquote>
<p>Let's see how we can use the TypeScript compiler.
First, create a file <code>index.ts</code>:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  title: string;
  description: string;
};

function showTask(task: Task) {
  console.log(
    `Task with ID=${task.id} has the title ${task.title} and description ${task.description}`,
  );
}

showTask({
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
});
</code></pre>
<p>We can't execute TypeScript files in the browser or in Node.js directly.
Instead we need to first <em>compile</em> the TypeScript code to JavaScript - which is why we installed the compiler.
Finally we can execute the resulting JavaScript code same as usual.</p>
<p>Here is how we can compile the <code>index.ts</code> file:</p>
<pre><code class="language-sh">tsc --strict index.ts
</code></pre>
<blockquote>
<p>Note that the <code>--strict</code> turns on certain "strict" type checks.
We will basically always do this.</p>
</blockquote>
<p>Since there were no type errors, nothing is logged on the console and we get a file <code>index.js</code> which looks (approximately) as follows:</p>
<pre><code class="language-js">function showTask(task) {
  console.log(
    'Task with ID='
      .concat(task.id, ' has the title ')
      .concat(task.title, ' and description ')
      .concat(task.description),
  );
}
showTask({
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
});
</code></pre>
<p>Note that all the type annotations are gone and all we get is vanilla JavaScript that we can execute.
Additionally the TypeScript compiler <em>downleved</em> our code so that it can be executed by older platforms.
Here the template string syntax (which is not supported by very old browsers) was replaced by a series of <code>concat</code> calls.</p>
<blockquote>
<p>Note that by the time you're reading this the default target settings might be different and you might not see this particular downleveling anymore.</p>
</blockquote>
<p>What if there is an error in <code>index.ts</code>?</p>
<pre><code class="language-ts">type Task = {
  id: number;
  title: string;
  description: string;
};

function showTask(task: Task) {
  console.log(
    `Task with ID=${task.id} has the title ${task.title} and description ${task.description}`,
  );
}

showTask({
  id: 1,
  title: 'Read the Next.js book',
});
</code></pre>
<p>Now we get an error if we try to run <code>tsc --strict index.ts</code>:</p>
<pre><code>index.ts:13:10 - error TS2345: Argument of type '{ id: number; title: string; }' is not assignable to parameter of type 'Task'.
  Property 'description' is missing in type '{ id: number; title: string; }' but required in type 'Task'.
13 showTask({
            ~
14   id: 1,
   ~~~~~~~~
15   title: 'Read the Next.js book',
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
16 });
   ~
  index.ts:4:3
    4   description: string;
        ~~~~~~~~~~~
    'description' is declared here.
Found 1 error in index.ts:13
</code></pre>
<p>The compiler correctly informed us that if we were to run this code it would probably result in bad things happening due to the missing <code>description</code> property.
We now know that the code is probably wrong long before it made it anywhere near production and can fix it accordingly.</p>
<h3 id="executing-typescript-directly-with-tsx"><a class="header" href="#executing-typescript-directly-with-tsx">Executing TypeScript Directly with <code>tsx</code></a></h3>
<p>Sometimes you want to execute a TypeScript file directly (especially during development) and not go throught the "compile and run" cycle manually.
There a couple of tools that allow you to do that - here we will introduce <code>tsx</code> (short for "TypeScript Execute").</p>
<p>Install <code>tsx</code>:</p>
<pre><code class="language-sh">pnpm add -g tsx
</code></pre>
<p>You can execute a TypeScript file <code>index.ts</code> by running:</p>
<pre><code class="language-sh">tsx index.ts
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<div style="text-align: right"> <i> Use TypeScript, find enlightenment. Ignore TypeScript, trip over undefined. <br> - Ancient Chinese proverb </i> </div>
<h3 id="annotating-variables"><a class="header" href="#annotating-variables">Annotating Variables</a></h3>
<p>You can annotate variables by adding a <strong>type annotation</strong>:</p>
<pre><code class="language-ts">let task: string = 'Read the Next.js book';
</code></pre>
<p>You can annotate constants in a similar fashion:</p>
<pre><code class="language-ts">const name: string = 'Read the Next.js book';
</code></pre>
<p>Note that explicit type annotations are usually is not needed, since TypeScript can perform <strong>type inference</strong> tp <em>automatically</em> infer the type of a variable or a constant.</p>
<p>In this example, the variable <code>name</code> will <em>automatically</em> be inferred to have the type <code>string</code>:</p>
<pre><code class="language-ts">let name = 'Read the Next.js book';
</code></pre>
<p>We will very rarely write explicit type annotations (only if we really need them) and instead let TypeScript infer as much as it can.
You will be suprised by how few type annotations you need to get completely type checked code!</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<p>The primitive types that are present in TypeScript should already be familiar to you from the chapter on JavaScript.
TypeScript has the <code>number</code> type:</p>
<pre><code class="language-ts">const id: number = 1;
</code></pre>
<p>TypeScript also has the <code>string</code> type:</p>
<pre><code class="language-ts">const task: string = 'Read the Next.js book';
</code></pre>
<p>It also has the <code>boolean</code> type:</p>
<pre><code class="language-ts">const inProgress: boolean = true;
</code></pre>
<p>Additionally TypeScript has the <code>null</code> and <code>undefined</code> types:</p>
<pre><code class="language-ts">const undefinedTask: undefined = undefined;
const nullTask: null = null;
</code></pre>
<p>Remember that in a real codebase we would let TypeScript infer the variables:</p>
<pre><code class="language-ts">const id = 1;
const task = 'Read the Next.js book';
const inProgress = true;
const undefinedTask = undefined;
const nullTask = null;
</code></pre>
<p>In this example, TypeScript will infer that <code>id</code> has the type <code>number</code>, <code>task</code> has the type <code>string</code>, <code>inProgress</code> has the type <code>boolean</code>, <code>undefinedTask</code> has the type <code>undefined</code> and that <code>nullTask</code> has the type <code>null</code>.</p>
<h3 id="the-any-and-unknown-types"><a class="header" href="#the-any-and-unknown-types">The <code>any</code> and <code>unknown</code> Types</a></h3>
<p>TypeScript also has the <code>any</code> type.
When a value is of the type <code>any</code>, you can access its properties, call it, or assign it freely, and basically do <em>any</em>thing (get it?) that's syntactically correct.
Also note that any property that you access will in turn have the type <code>any</code>.</p>
<p>Let's say you have a <code>task</code> variable of type <code>any</code> - then these are all legal:</p>
<pre><code class="language-ts">let task: any;

console.log(task.title);
task();
task.thingy();
</code></pre>
<p>Basically using <code>any</code> is a way to tell the compiler to "shut up" and skip type checking altogether.
This is also the reason why using <code>any</code> is generally a terrible idea since it defeats the purpose of using TypeScript in the first place!</p>
<p>However sometimes you do find yourself in a situation where you really don't know much or don't particularly care about a variable type.
In this case it's better to use the <code>unknown</code> type.</p>
<p>Anything is assignable to <code>unknown</code> (just as with <code>any</code>), however no operations are allowed on an <code>unknown</code> variable without further assurances about the type of the variable.</p>
<p>For example, if you have a <code>task</code> variable of type <code>unknown</code>, then these are all no longer legal:</p>
<pre><code class="language-ts">let task: unknown;

console.log(task.title);
task();
task.thingy();
</code></pre>
<h3 id="typing-arrays"><a class="header" href="#typing-arrays">Typing Arrays</a></h3>
<p>You can type arrays as <code>T[]</code> where <code>T</code> is the type of the elements of the array.
For example here is how you would type an array of numbers:</p>
<pre><code class="language-ts">const evenNumbers: number[] = [1, 2, 3, 4];
</code></pre>
<p>Here is how you would an array of strings:</p>
<pre><code class="language-ts">const tasks: string[] = ['First task', 'Second task', 'Third task'];
</code></pre>
<p>Note that for these simple examples we could again have TypeScript infer the types for use.
In this example <code>evenNumbers</code> would have the type <code>number[]</code> and <code>tasks</code> would have the type <code>string[]</code>:</p>
<pre><code class="language-ts">const evenNumbers = [1, 2, 3, 4];
const tasks = ['First task', 'Second task', 'Third task'];
</code></pre>
<h3 id="typing-objects"><a class="header" href="#typing-objects">Typing Objects</a></h3>
<p>You can type an object by writing the property keys and types of its properties inside curly braces <code>{}</code>.
For example here is how you could declare an object that has the properties <code>id</code> of type <code>number</code>, <code>title</code> of type <code>string</code> and <code>description</code> of type <code>string</code>:</p>
<pre><code class="language-ts">const task: { id: number; title: string; description: string } = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>As usual, you don't need to manually specify object types.
In this example, <code>task</code> will be inferred to have the type <code>{ id: number; title: string; description: string }</code>:</p>
<pre><code class="language-ts">const task = {
  id: 1,
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
};
</code></pre>
<p>You can mark properties as <em>optional</em> by using the question mark <code>?</code>.
If a property is marked as optional, you can assign <code>undefined</code> to it or even not specify it altogether.
For example, this is valid:</p>
<pre><code class="language-ts">const task: { id: number; title: string; description?: string } = {
  id: 1,
  title: 'Read the Next.js book',
};

const task2: { id: number; title: string; description?: string } = {
  id: 1,
  title: 'Read the Next.js book',
  description: undefined,
};
</code></pre>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h3>
<p>The object type syntax we just introduced is often quite verbose.
This is why TypeScript gives you the possibility to specify a <strong>type alias</strong> (i.e. another name) for an object type:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  title: string;
  description: string;
};
</code></pre>
<p>Note that you can specify type aliases for more than just object types since type aliases are basically just different names for types.
For example, we could specify a type alias for the primitive type <code>string</code>:</p>
<pre><code class="language-ts">type ID = string;
</code></pre>
<p>Another important point to make about type aliases is that two type aliases are exactly the same as long as the underlying types are the same.
For example this is valid even though it doesn't look like it:</p>
<pre><code class="language-ts">type MyString = string;

function getMyString(): MyString {
  return 'My string';
}

const s: string = getMyString();
</code></pre>
<p>This is because TypeScript uses a <em>structural type system</em> - it doesn't matter what the types are named (except for the primitive types of course), it only matters what their <em>structure</em> looks like.</p>
<p>Note that you can also use the <code>interface</code> keyword to achieve a similar effect:</p>
<pre><code class="language-ts">interface Task {
  id: number;
  title: string;
  description: string;
}
</code></pre>
<p>We will stick to always using <code>type</code>.
The <code>interface</code> keyword is out of scope for this book and will not be discussed further.</p>
<blockquote>
<p>We briefly note that <code>type</code> and <code>interface</code> are not exactly the same and have a few subtle, but important differences.
Again, we will not discuss this further.</p>
</blockquote>
<h2 id="type-assertions"><a class="header" href="#type-assertions">Type Assertions</a></h2>
<p>Sometimes you know more about the type of a variable than TypeScript.
For example, let's say that you have a function that returns an <code>any</code> value, but for some reason you know that in fact that value is definitely going to be a <code>string</code> in your case.
Then you can use a <strong>type assertion</strong> (also called a type cast) to force TypeScript to treat that value as a <code>string</code>.</p>
<p>Here is a (slightly contrived) example:</p>
<pre><code class="language-ts">const str: any = 'This is a string';
const strLength = (str as string).length;
</code></pre>
<p>You should use type assertions <em>extremely sparingly</em> since you give up some of the benefits of using TypeScript.
Usually there are better ways.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="annotating-functions"><a class="header" href="#annotating-functions">Annotating Functions</a></h2>
<div style="text-align: right"> <i> The function without types is like a river without banks: boundless, yet directionless. <br> - Ancient Chinese proverb </i> </div>
<h3 id="annotating-parameters"><a class="header" href="#annotating-parameters">Annotating Parameters</a></h3>
<p>We can annotate functions in TypeScript by annotating their parameters.
Consider a function <code>greet</code> that takes a parameter <code>name</code> of type <code>string</code> and simply outputs a greeting to the console.
Here is how we would annotate the function:</p>
<pre><code class="language-ts">function greet(name: string) {
  console.log(`Hello, ${name}`);
}
</code></pre>
<p>Now arguments to the function are checked:</p>
<pre><code class="language-ts">greet(false);
// This will result in a type error
</code></pre>
<p>You can annotate functions that expect arrays and/or objects by simply using the syntax you learned in the previous section:</p>
<pre><code class="language-ts">function showTask(task: { id: number; summary: string; description: string }) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}
</code></pre>
<p>This is not particularly readable.
Luckily, this is where type aliases come in really handy:</p>
<pre><code class="language-ts">type Task = {
  id: number;
  summary: string;
  description: string;
};

function showTask(task: Task) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}
</code></pre>
<p>Note that TypeScript will not just check that the passed arguments have the correct types, but also check that the correct number of arguments was passed.
This has an interesting side effect - introducing the TypeScript compiler in a JavaScript codebase can reveal bugs without any further work:</p>
<pre><code class="language-js">function showTask(task) {
  console.log(
    `Task with ID=${task.id} has the summary ${task.summary} and description ${task.description}`,
  );
}

// Uh-oh, we are passing multiple variables instead of a single object!
showTask(1, 'Read the Next.js book', 'Read and understand the Next.js book.');
</code></pre>
<p>If we run <code>tsc --strict</code> on this code, we will get the following error:</p>
<pre><code>index.ts:8:13 - error TS2554: Expected 1 arguments, but got 3.

8 showTask(1, 'Read the Next.js book', 'Read and understand the Next.js book.');
</code></pre>
<p>TypeScript is quite useful indeed!</p>
<h3 id="return-type-annotations"><a class="header" href="#return-type-annotations">Return Type Annotations</a></h3>
<p>We can also annotate the return types of our functions:</p>
<pre><code class="language-ts">function getGreeting(name: string): string {
  return `Hello, ${name}`;
}
</code></pre>
<p>Note that you usually don't need a return type annotation because TypeScript can do type inference for them:</p>
<pre><code class="language-ts">function getGreeting(name: string) {
  return `Hello, ${name}`;
}
</code></pre>
<p>Nevertheless, return types are often typed explicitly to avoid accidentally returning a type you didn't want to return or to prevent accidental changes to the return type.</p>
<h3 id="optional-parameters"><a class="header" href="#optional-parameters">Optional Parameters</a></h3>
<p>Similar to object properties, function parameters can be marked as <em>optional</em>.
In this case we can, but don't need to pass the corresponding argument to the function.
If a parameter is marked as optional, the corresponding argument might also be <code>undefined</code>:</p>
<pre><code class="language-ts">function getGreeting(name: string, message?: string): string {
  return `${message !== undefined ? message : 'Hello'}, ${name}`;
}

// These are all valid
getGreeting('John Doe');
getGreeting('John Doe', undefined);
getGreeting('John Doe', 'Welcome');
</code></pre>
<h3 id="function-type-expressions"><a class="header" href="#function-type-expressions">Function Type Expressions</a></h3>
<p>Sometimes you need to create a type that specifies the function itself, instead of just its parameters or its return type.
For example, you might want to say that <code>f</code> is a function that takes two strings and returns a string.</p>
<p>You can achieve this with a <strong>function type expression</strong>:</p>
<pre><code class="language-ts">let f: (x: string, y: string) =&gt; string;
</code></pre>
<p>The parameter names are required here, if you write <code>(string, string) =&gt; string</code> then TypeScript will think that you have a function with two parameters named <code>string</code> of type <code>any</code>.</p>
<p>This syntax is very useful for typing higher-order functions:</p>
<pre><code class="language-ts">function getGreeting(name: string, greeter: (name: string) =&gt; string) {
  return greeter(name);
}

const myName = 'John Doe';
const greeter = (name: string) =&gt; `Hello ${name}`;

console.log(getGreeting(myName, greeter));
</code></pre>
<p>One interesting consequence of the way TypeScript inference works, is that parameters of functions can often be inferred.
Let's change this example and make an anonymous function out of <code>greeter</code>:</p>
<pre><code class="language-ts">function getGreeting(name: string, greeter: (name: string) =&gt; string) {
  return greeter(name);
}

const myName = 'John Doe';

console.log(getGreeting(myName, (name) =&gt; `Hello ${name}`));
</code></pre>
<p>Note how we no longer need to explicitly specify the type of <code>name</code> in the anonymous function - TypeScript has automatically inferred it to be of type <code>string</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="union-types"><a class="header" href="#union-types">Union Types</a></h2>
<h3 id="literal-types"><a class="header" href="#literal-types">Literal Types</a></h3>
<p>A <strong>literal type</strong> is a type whose only value is a literal.
Here is how we could define a literal type <code>'Todo'</code>:</p>
<pre><code class="language-ts">type TodoType = 'Todo';
</code></pre>
<p>Here is how we can use it:</p>
<pre><code class="language-ts">let todo: TodoType = 'Todo';
</code></pre>
<p>Note that we can't assign any other value to <code>todo</code> including other strings.
For example this is not possible:</p>
<pre><code class="language-ts">let todo: TodoType = 'Done';
// This will result in a type error
</code></pre>
<p>We could also skip declaring the type alias and just use the literal type directly:</p>
<pre><code class="language-ts">let todo: 'Todo' = 'Todo';
</code></pre>
<p>It should be noted that if we declare a variable, then by default TypeScript will infer it as a <code>string</code>.
This makes sense since we could change the variable later:</p>
<pre><code class="language-ts">let todo = 'Todo';
// Without the explicit type annotation, todo is a string
</code></pre>
<p>However if we declare a constant, then by default TypeScript will infer a literal type.
This also makes sense since we can't change the constant later:</p>
<pre><code class="language-ts">const todo = 'Todo';
// Even without the explicit type annotation,
// todo now has the literal type 'Todo'
</code></pre>
<p>While literal types by themselves are not very helpful, they are extremely useful in the context of union types.</p>
<h3 id="unions-of-literal-types"><a class="header" href="#unions-of-literal-types">Unions of Literal Types</a></h3>
<p>A <strong>union type</strong> is a type that represents a value which may be one of multiple values.
Consider a type <code>TaskState</code> which represents one of the following states:</p>
<ul>
<li>Todo</li>
<li>InProgress</li>
<li>Done</li>
</ul>
<p>Here is how we would define the <code>TaskState</code> type:</p>
<pre><code class="language-ts">type TaskState = 'Todo' | 'InProgress' | 'Done';
</code></pre>
<p>The <code>TaskState</code> type is a union type and each of the literal types <code>'Todo'</code>, <code>'InProgress'</code> and <code>'Done'</code> is a member of the union.
A variable of type <code>TaskState</code> can only be of one of these literal types, i.e. it can only have one of the respective values.
For example these are all valid:</p>
<pre><code class="language-ts">const state: TaskState = 'Todo';
const state2: TaskState = 'InProgress';
const state3: TaskState = 'Done';
</code></pre>
<p>But this is not:</p>
<pre><code class="language-ts">const invalidState: TaskState = 'Dropped';
</code></pre>
<h3 id="other-union-types"><a class="header" href="#other-union-types">Other Union Types</a></h3>
<p>We can also declare unions of arbitrary types.
The general syntax for declaring a union type is <code>Type1 | Type2 | Type3 | ...</code> and a value of this union type can have the type <code>Type1</code> or <code>Type2</code> or <code>Type3</code> etc.
The various types <code>Type1</code>, <code>Type2</code>, <code>Type3</code> etc are called members of the union.</p>
<p>One particularly common union type is <code>T | undefined</code>, for example:</p>
<pre><code class="language-ts">function getTaskId(taskName: string): string | undefined {
  // Implementation here
}
</code></pre>
<p>This function takes a <code>taskName</code> and returns the corresponding ID.
Because we might discover that no task with the given name is present, we return either a <code>string</code> or <code>undefined</code>.</p>
<h3 id="working-with-a-union-type"><a class="header" href="#working-with-a-union-type">Working with a Union Type</a></h3>
<p>It should be clear by now how we can define a union type, but how can we work with a union type?
Consider the following function:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined) {
  console.log({
    taskName,
    taskNameLength: taskName.length,
  });
}
</code></pre>
<p>Compiling this example will result in the following error:</p>
<pre><code>index.ts:4:21 - error TS18048: 'taskName' is possibly 'undefined'.
4     taskNameLength: taskName.length,
                      ~~~~~~~~
Found 1 error in index.ts:4
</code></pre>
<p>TypeScript will only allow to do something with the value of a union type if that something is valid for every member of the union.
Since <code>taskName</code> can be either a <code>string</code> or <code>undefined</code>, we can't access <code>.length</code> on it, because <code>.length</code> is not a valid property of <code>undefined</code>!</p>
<p>Instead we need to perform <strong>type narrowing</strong> where we <em>narrow</em> the type of a variable with code.</p>
<p>Basically, TypeScript can look at our code and try to understand that in certain code parts a value of a union type can only have the type of a particular member of the union.</p>
<p>The simplest way of narrowing a type is <strong>equality narrowing</strong>.
Here we can use the <code>===</code> or <code>!==</code> operators to narrow a type.</p>
<p>Consider this example:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined) {
  if (taskName !== undefined) {
    console.log({
      taskName,
      taskNameLength: taskName.length,
    });
  } else {
    console.log('the task is not defined');
  }
}
</code></pre>
<p>We narrow the type of <code>taskName</code> in the <code>taskName !== undefined</code> branch.
TypeScript will inspect our code and realize that since <code>taskName</code> had the <code>string | undefined</code> type and <code>taskName !== undefined</code> in the truthy branch of the if statement, <code>taskName</code> must be of type <code>string</code> inside that branch (there is simply no other way).
Similarly, in the falsy branch of the if statement (i.e. the <code>else</code> branch), TypeScript will know that <code>taskName</code> must be <code>undefined</code>.</p>
<p>This example also showcases a very important concept: The same variable can have a different type depending on the part of the code we are.
This is not the case in many other programming languages, where a variable will always have the same type once it has been initialized.</p>
<p>Another (similar) way of narrowing a type is <strong>truthiness narrowing</strong>.
Here we use the fact that certain values are truthy or falsy to narrow a type.</p>
<p>Consider this example:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined | null) {
  if (taskName) {
    console.log({
      taskName,
      taskNameLength: taskName.length,
    });
  } else {
    console.log('the task is not defined');
  }
}
</code></pre>
<p>Since <code>undefined</code> and <code>null</code> are both falsy, the <code>taskName</code> in the truthy branch of the <code>if</code> statement can only have the type <code>string</code> and we can use the <code>.length</code> property.</p>
<p>However truthiness narrowing can lead to bugs and indeed the function <code>logTaskName</code> has a subtle error.
Can you spot it?</p>
<p>That's right - it doesn't correctly handle the case of the empty string - after all, the empty string <code>''</code> is also falsy, therefore <code>logTaskName("")</code> would print that the task not defined, which is probably not what we were going for.
We could fix the function like this:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined | null) {
  if (taskName === '') {
    console.log('the task is empty');
  } else if (taskName) {
    console.log({
      taskName,
      taskNameLength: taskName.length,
    });
  } else {
    console.log('the task is not defined');
  }
}
</code></pre>
<p>You should generally be careful when relying on truthiness or falsiness.
The way these concepts work in JavaScript can be a bit confusing and it's easy to miss and edge case.</p>
<p>Some people prefer to avoid these concepts altogether and instead provide explicit checks, for example:</p>
<pre><code class="language-ts">function logTaskName(taskName: string | undefined | null) {
  if (taskName !== undefined &amp;&amp; taskName !== null) {
    console.log({
      taskName,
      taskNameLength: taskName.length,
    });
  } else {
    console.log('the task is not defined');
  }
}
</code></pre>
<p>The last way of narrowing a type that we will discuss here is <code>typeof</code> narrowing.
TypeScript knows how the <code>typeof</code> operator works and you can use it to narrow a type as you would expect:</p>
<pre><code class="language-ts">function processInput(value: string | number): number {
  if (typeof value === 'string') {
    // value must be a string here
    return value.length;
  } else {
    // value must be a number here
    return value;
  }
}
</code></pre>
<h3 id="the-non-null-assertion-operator"><a class="header" href="#the-non-null-assertion-operator">The Non-Null Assertion Operator</a></h3>
<p>You can use the non-null assertion operator to tell TypeScript that a value is definitely not <code>undefined</code> or <code>null</code>:</p>
<pre><code class="language-ts">let input: string | undefined = 'Some string';
let trimmedInput: string = input!.trim();
</code></pre>
<p>Just as with type assertions, you should use this <em>extremely sparingly</em> and usually there is a better way.</p>
<h3 id="type-predicates"><a class="header" href="#type-predicates">Type Predicates</a></h3>
<p>We can write user-defined <strong>type guards</strong> by utilizing <strong>type predicates</strong>.
Consider the following example:</p>
<pre><code class="language-ts">const array = ['Hello', undefined, 'World', undefined];
const filteredArray = array.filter((val) =&gt; val !== undefined);
</code></pre>
<p>Here <code>array</code> is a <code>(string | undefined)[]</code> and <code>filteredArray</code> removes the <code>undefined</code> elements.
However the inferred type of <code>filteredArray</code> would still be <code>(string | undefined)[]</code> because TypeScript can't easily inspect the contents of the filter function to realize that we remove the <code>undefined</code> elements.</p>
<p>We could theoretically use a type assertion here:</p>
<pre><code class="language-ts">const array = ['Hello', undefined, 'World', undefined];
const filteredArray = array.filter((val) =&gt; val !== undefined) as string[];
</code></pre>
<p>However instead of yelling at the TypeScript compiler that we know better, we can choose a better way and write a user-defined type guard:</p>
<pre><code class="language-ts">function isString(val: string | undefined): val is string {
  return typeof val === 'string';
}
</code></pre>
<p>The <code>isString</code> function is a type guard, because it's return type is the type predicate <code>val is string</code>.
Generally, a type predicate must have the form <code>parameter is Type</code> where <code>parameter</code> is the name of a parameter from the function signature.</p>
<p>We can use the type guard like this:</p>
<pre><code class="language-ts">const array = ['Hello', undefined, 'World', undefined];
const filteredArray = array.filter(isString);
</code></pre>
<p>Now the inferred type of <code>filteredArray</code> will be <code>string[]</code> - and all that without using a single type assertion.
Hooray!</p>
<h3 id="discriminated-unions"><a class="header" href="#discriminated-unions">Discriminated Unions</a></h3>
<p>A particularly important union type is the <strong>discriminated union</strong>.
This is a union where a property is used to discriminate between union members.
Consider the following classical example:</p>
<pre><code class="language-ts">type Square = {
  kind: 'square';
  size: number;
};

type Rectangle = {
  kind: 'rectangle';
  width: number;
  height: number;
};

type Shape = Square | Rectangle;
</code></pre>
<p>We can now narrow values of the discriminated union based on the <strong>discriminant property</strong> (which in this case is <code>kind</code>):</p>
<pre><code class="language-ts">function getArea(shape: Shape) {
  if (shape.kind === 'square') {
    // Here shape must be of type Square
    return shape.size * shape.size;
  } else {
    // Here shape must be of type Rectangle
    return shape.width * shape.height;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<div style="text-align: right"> <i> Generics are the invisible hat of the TypeScript sage, fitting the heads of both the giant and the dwarf. <br> - Ancient Chinese proverb </i> </div>
<h3 id="why-generics"><a class="header" href="#why-generics">Why Generics?</a></h3>
<p>Generics allow us to write code that is type-safe, yet independent of specific types.</p>
<p>Consider the example of retrieving the first element of an array:</p>
<pre><code class="language-js">function getFirstElement(arr) {
  return arr[0];
}
</code></pre>
<p>How would we type this?
We could use <code>any</code>:</p>
<pre><code class="language-ts">function getFirstElement(arr: any): any {
  return arr[0];
}
</code></pre>
<p>However using <code>any</code> is - as we already mentioned - a bad idea since we lose all the type information even if we pass in an array of a known type.
For example all these constants would be inferred to have type <code>any</code>:</p>
<pre><code class="language-ts">const num = getFirstElement([1, 2, 3]);
const str = getFirstElement(['a', 'b', 'c']);
</code></pre>
<p>We also can't use the <code>unknown</code> type since it doesn't permit any operations:</p>
<pre><code class="language-ts">function getFirstElement(arr: unknown) {
  return arr[0];
  // This will result in a type error
}
</code></pre>
<p>We could also make use of <em>function overloads</em> and write something like this:</p>
<pre><code class="language-ts">function getFirstElement(arr: number[]): number;
function getFirstElement(arr: string[]): string;
function getFirstElement(arr: undefined[]): undefined;
// More overloads and implementation here
</code></pre>
<blockquote>
<p>We will not discuss function overloads in more detail as it's out of scope for this book.</p>
</blockquote>
<p>But this obviously gets very tedious and error-prone for most cases.
Instead TypeScript allows us to use <strong>generics</strong> to specify that some code does not depend on the concrete types and only cares about the relation between certain types.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Consider the identity function that simply takes an argument <code>arg</code> and returns it unchanged.
We can use a <strong>type variable</strong> <code>Type</code> and type it like this:</p>
<pre><code class="language-ts">function identity&lt;Type&gt;(arg: Type): Type {
  return arg;
}
</code></pre>
<p>This basically says that the <code>identity</code> function takes an argument of type <code>Type</code> and that its return type is of the same type as the argument.
Now we get proper type inference:</p>
<pre><code class="language-ts">let val = 'Hello, world!';
let val2 = identity&lt;string&gt;(val); // val2 is of type string
</code></pre>
<p>We dont actually have to manually specify the type <code>string</code> when calling the function and can instead rely the inference capabilities of TypeScript once again:</p>
<pre><code class="language-ts">let val = 'Hello, world!';
let val2 = identity(val); // val2 is of type string
</code></pre>
<blockquote>
<p>There is no single convention for naming type parameters.
Common names include <code>T</code>, <code>Type</code> and <code>TType</code>.
We will stick to the <code>Type</code> convention throughout this book.</p>
</blockquote>
<p>Similarly, we can type the <code>getFirstElement</code> function using type parameters:</p>
<pre><code class="language-ts">function getFirstElement&lt;Type&gt;(arr: Type[]): Type {
  return arr[0];
}

const num = getFirstElement([1, 2, 3]);
const str = getFirstElement(['a', 'b', 'c']);
</code></pre>
<p>Unlike in the <code>getFirstElement</code> example that was typed using <code>any</code>, we now get meaningful type inference.
For example <code>num</code> will have the type <code>number</code> (instead of <code>any</code>) and <code>str</code> will have the type <code>string</code>.</p>
<p>You can use any number of type parameters you want.
For example here is how we could write a correctly annotated <code>map</code> function:</p>
<pre><code class="language-ts">function map&lt;In, Out&gt;(array: In[], f: (value: In) =&gt; Out): Out[] {
  return array.map(f);
}
</code></pre>
<p>Here, we have two type parameters <code>In</code> and <code>Out</code>.
The type parameter <code>In</code> indicates the types of the elements of the original array.
The type parameter <code>Out</code> indicates the types of the elements of the result array.</p>
<p>Note how the type of the parameter <code>f</code> makes uses of both the <code>In</code> and <code>Out</code> parameter types.
This makes sense since <code>f</code> transforms an element of the original array (<code>In</code>) into an element of the result array (<code>Out</code>).</p>
<p>Again, we will get proper type inference:</p>
<pre><code class="language-ts">const arr = map([1, 2, 3, 4], (x) =&gt; x % 2 === 0);
</code></pre>
<p>Here <code>arr</code> will have the type <code>boolean[]</code>.</p>
<h3 id="generic-object-types"><a class="header" href="#generic-object-types">Generic Object Types</a></h3>
<p>Just like with functions, we can use type parameters with objects:</p>
<pre><code class="language-ts">type Box&lt;Type&gt; = {
  content: Type;
};
</code></pre>
<p>Now we can use the <code>Box</code> type with any type:</p>
<pre><code class="language-ts">// box has the type Box&lt;number&gt;
const box = {
  content: 0,
};

// box2 has the type Box&lt;string&gt;
const box2 = {
  content: 'Hello, world!',
};
</code></pre>
<p>We can also use generic functions and objects together:</p>
<pre><code class="language-ts">function extractContent&lt;Type&gt;(box: Box&lt;Type&gt;): Type {
  return box.content;
}
</code></pre>
<h3 id="important-builtin-generics"><a class="header" href="#important-builtin-generics">Important Builtin Generics</a></h3>
<p>Generic object types are often useful for collections (and containers), since collection logic is often independent of the specific item types.
For example, retrieving the first element of an array or finding an element of a set by value using the <code>===</code> operator will work the same way regardless of the types of the array or set elements.</p>
<p>You already learned about generic arrays (note that you can use <code>Array&lt;T&gt;</code> in place of <code>T[]</code>).</p>
<p>If you have an object type where the property keys have a certain known type and the property values have a certain known type, you can use the generic type <code>Record&lt;Key, Value&gt;</code></p>
<pre><code class="language-ts">const ScoreRecord: Record&lt;string, number&gt; = {
  Alice: 50,
  Bob: 60,
  Charlie: 70,
};
</code></pre>
<p>Two other generic data structures that you already know about are sets and maps:</p>
<pre><code class="language-ts">const mySet: Set&lt;number&gt; = new Set([1, 2, 3]);
const myMap: Map&lt;string, number&gt; = new Map([
  ['Item 1', 1],
  ['Item 2', 2],
]);
</code></pre>
<p>This example can also be written like this:</p>
<pre><code class="language-ts">const mySet = new Set&lt;number&gt;([1, 2, 3]);
const myMap = new Map&lt;string, number&gt;([
  ['Item 1', 1],
  ['Item 2', 2],
]);
</code></pre>
<p>One other very important generic type is the <code>Promise&lt;Type&gt;</code> type which is most commonly used to annotate asynchronous functions.
For example, if we have an asynchronous function <code>f</code> that returns a promise that will eventuell fulfill with a <code>string</code>, we would annotate it like this:</p>
<pre><code class="language-ts">async function f(): Promise&lt;string&gt; {
  // Implementation here
}
</code></pre>
<h3 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h3>
<p>Often, we don't want to pass <em>completely arbitrary</em> type parameters.</p>
<p>Consider this example:</p>
<pre><code class="language-ts">function getLength&lt;Type&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<p>This will throw the following error:</p>
<pre><code>index.ts:2:14 - error TS2339: Property 'length' does not exist on type 'Type'.
2   return arg.length;
               ~~~~~~
Found 1 error in index.ts:2
</code></pre>
<p>This makes sense since <code>arg</code> can be of literally any type and there is no guarantee that <code>arg</code> will actually have the property <code>length</code>.
To change this, we need to constrain the type <code>Type</code> and make sure that <code>arg</code> must have the <code>length</code> property:</p>
<pre><code class="language-ts">function getLength&lt;Type extends { length: number }&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<p>As usual, we can use a type alias here:</p>
<pre><code class="language-ts">type HasLength = {
  length: number;
};

function printLength&lt;Type extends HasLength&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="configuring-typescript"><a class="header" href="#configuring-typescript">Configuring TypeScript</a></h2>
<div style="text-align: right"> <i> "Like the ancient master who chooses his brush, the wise coder sets 'strict' with care, for clarity is the first step to wisdom." <br> - Ancient Chinese proverb </i> </div>
<h3 id="creating-a-typescript-project"><a class="header" href="#creating-a-typescript-project">Creating a TypeScript Project</a></h3>
<p>We already learned how to create and run individual TypeScript files.
However, as with JavaScript, we will usually be working with larger projects.</p>
<p>Let's create a JavaScript project and add TypeScript support to it.</p>
<p>First, we create a directory where our project will reside:</p>
<pre><code class="language-sh">mkdir example
cd example
</code></pre>
<p>Next we need to create the <code>package.json</code> file to indicate that this directory should be a JavaScript project:</p>
<pre><code class="language-sh">pnpm init
</code></pre>
<p>This will create a <code>package.json</code> file containing the project settings:</p>
<pre><code class="language-json">{
  "name": "example",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</code></pre>
<p>Next let's create a <code>tsconfig.json</code> to indicate that this particular project will use TypeScript:</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "strict": true
  }
}
</code></pre>
<p>Setting the <code>strict</code> option in <code>compilerOptions</code> is equivalent to running <code>tsc</code> with the <code>--strict</code> flag.
We will talk about this option in some more detail later.</p>
<blockquote>
<p>We could have also created the <code>tsconfig.json</code> file by running <code>tsc --init</code>, however this will add a lot of options that we really don't care about at the moment.</p>
</blockquote>
<p>Now let us create an <code>index.ts</code> file:</p>
<pre><code class="language-ts">function getGreeting(name: string): string {
  return `Hello, ${name}!`;
}

console.log(getGreeting('World'));
</code></pre>
<p>Finally we can compile the code:</p>
<pre><code class="language-sh">tsc
</code></pre>
<p>This will create approximately the following <code>index.js</code> file:</p>
<pre><code class="language-js">'use strict';
function getGreeting(name) {
  return 'Hello, '.concat(name, '!');
}
console.log(getGreeting('World'));
</code></pre>
<p>We can execute this file the same way we would execute any other JavaScript file:</p>
<pre><code class="language-sh">node index.js
</code></pre>
<p>There is one small modification we need to make to this process.
While using the globally installed TypeScript compiler is fine if you have a single project, you often might need to work on multiple projects at the same time.
Since these projects might use different TypeScript versions, we usually want to install <code>tsc</code> on a per-project basis.</p>
<p>Let's therefore install <code>tsc</code> as a dev (development) dependency (since we will not need it in the final code output):</p>
<pre><code class="language-sh">pnpm add --save-dev typescript
</code></pre>
<p>This will install TypeScript only for this particular project.
We can now run the <code>tsc</code> that was installed for this project using the following command:</p>
<pre><code class="language-sh">pnpm tsc
</code></pre>
<h3 id="using-modules-in-a-typescript-project"><a class="header" href="#using-modules-in-a-typescript-project">Using Modules in a TypeScript Project</a></h3>
<p>Now that we know how to create TypeScript projects in general, let's quickly talk about how we can use modules in TypeScript projects.
This process will be very similar to what we learned about JavaScript modules, except that we may need to make minor modifications to the <code>tsconfig.json</code> file.</p>
<p>Create a <code>src</code> directory containing the files <code>greet.ts</code> and <code>index.ts</code>.
You overall project structure should now look as follows:</p>
<pre><code>.
├── package.json
├── pnpm-lock.yaml
├── tsconfig.json
├── node_modules/
└── src/
    ├── index.ts
    └── greet.ts
</code></pre>
<p>Add the following exported function to <code>greet.ts</code>:</p>
<pre><code class="language-ts">export function getGreeting(name: string): string {
  return `Hello, ${name}!`;
}
</code></pre>
<p>Now let's use <code>getGreeting</code> in <code>index.ts</code>:</p>
<pre><code class="language-ts">import { getGreeting } from './greet';

console.log(getGreeting('World'));
</code></pre>
<p>We could theoretically compile our project using this setup already.
However we will make a small modification to our <code>tsconfig.json</code> to avoid polluting the <code>src</code> directory with our compilation outputs.
To this end, we utilize the <code>outDir</code> option, which specifies the output directory, where TypeScript will put the compilation result.</p>
<p>Change your <code>tsconfig.json</code> file to be as follows:</p>
<pre><code class="language-ts">{
  "compilerOptions": {
    "strict": true,
    "outDir": "./dist"
  }
}
</code></pre>
<p>We can now compile again:</p>
<pre><code class="language-sh">pnpm tsc
</code></pre>
<p>Now the project structure looks like this:</p>
<pre><code>.
├── package.json
├── pnpm-lock.yaml
├── tsconfig.json
├── node_modules/
├── src/
│   ├── index.ts
│   └── greet.ts
└── dist/
    ├── index.js
    └── greet.js
</code></pre>
<p>The files from <code>src</code> were successfully compiled and the compilation output is in <code>dist</code>.
We can now execute <code>index.js</code> by running:</p>
<pre><code class="language-sh">node ./dist/index.js
</code></pre>
<p>You should see <code>"Hello, World!"</code> logged to the console.</p>
<h3 id="including-and-excluding-files"><a class="header" href="#including-and-excluding-files">Including and Excluding Files</a></h3>
<p>Sometimes you want to include or exclude certain files from being processed by the TypeScript compiler.
To accomplish this, you can specify the <code>include</code> or <code>exclude</code> parameters in the <code>tsconfig.json</code>.</p>
<p>The <code>include</code> option takes an array of filenames or patterns to include in the program (relative to the directory containing the <code>tsconfig.json</code> file).
For example we could include all files in <code>src</code> directory by setting <code>include</code> to <code>["src/**/*"]</code>.</p>
<p>The <code>src/**/*</code> notation is a so called glob pattern.
Here <code>*</code> matches zero or more characters (excluding directory separators) and <code>**/</code> matches any directory (with arbitrary nesting).
Thefore <code>src/**/*</code> means "match any file in the directory <code>src</code> and all its subdirectories (no matter how deeply nested)".</p>
<blockquote>
<p>Note that by default <code>include</code> is set to <code>["**/*"]</code> (i.e. match all files including arbitrarily nested subdirectories).</p>
</blockquote>
<p>The <code>exclude</code> parameter specifies an array of filenames or patterns that should be skipped when resolving <code>include</code>.
It is important to note that the <code>exclude</code> parameter does not necessarily exclude the file from your codebase - a file specified by <code>exclude</code> can still become part of your codebase if you import it somewhere.
The <code>exclude</code> parameter only changes which files are found by the <code>include</code> option finds.</p>
<p>Consider the following example.
Let's say that you have a bunch of <code>*.test.ts</code> files containing tests, like the following <code>greet.test.ts</code>:</p>
<pre><code class="language-ts">import { getGreeting } from './greet';

function testGreeting() {
  if (getGreeting('World') !== 'Hello, World!') {
    throw new Error('Test failed');
  }
}
</code></pre>
<blockquote>
<p>This is not how we would really write a test, but that is irrelevant for now.</p>
</blockquote>
<p>If we would run <code>pnpm tsc</code> right now, we would see the we have <code>greet.test.js</code> in the output which is probably not desirable, since the tests probably shouldn't be part of the final compilation output.</p>
<p>Therefore we could write the following <code>tsconfig.json</code>:</p>
<pre><code class="language-json">{
  "include": ["src/**/*"],
  "exclude": ["src/**/*.test.ts"],
  "compilerOptions": {
    "strict": true,
    "outDir": "./dist"
  }
}
</code></pre>
<p>If we delete the <code>dist</code> directory and run <code>pnpm tsc</code> again, <code>greet.test.js</code> is no longer present.</p>
<h3 id="compiler-options"><a class="header" href="#compiler-options">Compiler Options</a></h3>
<p>There a lot of compiler options that we can set in the <code>compilerOptions</code> section of <code>tsconfig.json</code> besides <code>strict</code> and <code>outDir</code>.
Let's discuss some of them.</p>
<h4 id="the-strict-option"><a class="header" href="#the-strict-option">The <code>strict</code> Option</a></h4>
<p>The <code>strict</code> option enables a wide range of - well - strict type checking.</p>
<p>Here is some example code that contains a few type issues:</p>
<pre><code class="language-ts">function getNumber(): number | undefined {
  return Math.random() &gt; 0.5 ? 0 : undefined;
}

function logNumber(n: number) {
  console.log(n);
}

function logAny(x) {
  console.log(x);
}

const number = getNumber();
logNumber(number);
logAny(number);
</code></pre>
<p>If we set <code>strict</code> to <code>false</code> (which it is by default), this code will (surprisingly) compile.</p>
<p>However if we turn <code>strict</code> on, we get the errors that you would expect from what you learned in the previous sections of the TypeScript chapter:</p>
<pre><code class="language-ts">src/index.ts:9:17 - error TS7006: Parameter 'x' implicitly has an 'any' type.

9 function logAny(x) {
                  ~

src/index.ts:14:11 - error TS2345: Argument of type 'number | undefined' is not assignable to parameter of type 'number'.
  Type 'undefined' is not assignable to type 'number'.

14 logNumber(number);
             ~~~~~~


Found 2 errors in the same file, starting at: src/index.ts:9
</code></pre>
<p>You should <em>always</em> turn <code>strict</code> on, unless you have a really good reason not to (for example because you are migrating from a JavaScript or a very old TypeScript codebase).</p>
<h4 id="the-target-option"><a class="header" href="#the-target-option">The <code>target</code> Option</a></h4>
<p>Remember how we talked about downleveling in the first section of this chapter?
The <code>target</code> options changes which JS features are downleveled and which are left as is.
For example if <code>target</code> is <code>es5</code> template strings will be downleveled, but if it is <code>es2015</code> (equivalent to <code>es6</code>) they won't be, because template strings were introduced in ES2015.</p>
<p>Take this code:</p>
<pre><code class="language-ts">const world = 'World';
console.log(`Hello ${world}`);
</code></pre>
<p>If <code>target</code> is set to <code>es5</code>, it would compile to this:</p>
<pre><code class="language-js">'use strict';
var world = 'World';
console.log('Hello '.concat(world));
</code></pre>
<p>If <code>target</code> is set to <code>es2015</code>, the compilation output would look like this:</p>
<pre><code class="language-js">'use strict';
const world = 'World';
console.log(`Hello ${world}`);
</code></pre>
<p>This is because with <code>target</code> set to <code>es5</code> the template string had to be downleveled.</p>
<p>Some valid targets are:</p>
<ul>
<li><code>es5</code></li>
<li><code>es2015</code> (equivalent to <code>es6</code>)</li>
<li><code>es2016</code> up to <code>es2022</code></li>
</ul>
<p>There is also the <code>esnext</code> target which refers to the highest version of TypeScript.
This target should be used with caution since it means different things between different TypeScript versions.</p>
<p>Modern browsers support all <code>es6</code> features, so <code>es6</code> is often a good choice.
You might choose to set a lower target though if your code is deployed to older environments.
Alternatively you might choose a higher target if your code is guaranteed to run in newer environments.</p>
<h4 id="the-lib-option"><a class="header" href="#the-lib-option">The <code>lib</code> Option</a></h4>
<p>The <code>lib</code> option allows you specify libraries to be included in the compilation.
Basically, you can use this to let TypeScript know which APIs will be available in the runtime environment.</p>
<p>For example let's say we have this code which would only work in the browser since it attaches an event listener to the browser <code>document</code>:</p>
<pre><code class="language-ts">document.addEventListener('DOMContentLoaded', () =&gt; {
  console.log('DOM has loaded');
});
</code></pre>
<p>If we only have <code>lib</code> equal to <code>["es2015"]</code>, we will get a bunch of compilation errors:</p>
<pre><code>src/index.ts:1:1 - error TS2584: Cannot find name 'document'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'.

1 document.addEventListener('DOMContentLoaded', () =&gt; {
  ~~~~~~~~

src/index.ts:2:5 - error TS2584: Cannot find name 'console'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'.

2     console.log("DOM has loaded");
      ~~~~~~~


Found 2 errors in the same file, starting at: src/index.ts:1
</code></pre>
<p>But if we set <code>lib</code> to <code>["es2015", "dom"]</code> the compilation errors go away since TypeScript know introduces the DOM types into the compilation process.</p>
<h4 id="the-noemit-option"><a class="header" href="#the-noemit-option">The <code>noEmit</code> Option</a></h4>
<p>The <code>noEmit</code> option can be set to <code>true</code> to not produce JavaScript output.
This makes room for another tool to convert the TypeScript files to something that can be run inside a JavaScript environment.</p>
<p>This is often done when we only want to use TypeScript as a type checker (as is common in projects) or to provide suggestions in your coding editor.</p>
<h3 id="an-example-tsconfigjson"><a class="header" href="#an-example-tsconfigjson">An Example <code>tsconfig.json</code></a></h3>
<p>You now learned about some of the most important <code>tsconfig.json</code> settings!
Here is an example <code>tsconfig.json</code> to summarize your newfound knowledge:</p>
<pre><code class="language-json">{
  "include": ["src/**/*"],
  "exclude": ["src/**/*.test.ts"],
  "compilerOptions": {
    "strict": true,
    "noEmit": true,
    "target": "es2015",
    "lib": ["es2015", "dom"]
  }
}
</code></pre>
<p>In this case, we don't produce compilation output, but only type check the code (due to <code>noEmit</code> being <code>true</code>).
We only look at the files in <code>src</code> and its subdirectories, ignoring the <code>*.test.ts</code> file (because of the <code>include</code> and <code>exclude</code> setting).</p>
<p>Finally, the type checking process is strict (due to <code>noEmit</code> being <code>true</code>), all features that are not available before ES2015 will be downleveled (since <code>target</code> is <code>es2015</code>) and we can use the DOM API types.</p>
<h3 id="reusing-a-tsconfigjson"><a class="header" href="#reusing-a-tsconfigjson">Reusing a <code>tsconfig.json</code></a></h3>
<p>The <code>extends</code> option can be used to inherit from another configuration file.</p>
<p>For example we might have a <code>base.json</code> configuration file like this:</p>
<pre><code class="language-json">{
  "compilerOptions": {
    "strict": true
  }
}
</code></pre>
<p>Now the <code>tsconfig.json</code> could extend this file:</p>
<pre><code class="language-json">{
  "extends": "base.json",
  "include": ["src/**/*.ts"],
  "compilerOptions": {
    "noEmit": true
  }
}
</code></pre>
<p>The resulting configuration would be strict and not emit JavaScript files.</p>
<p>This feature is particularly useful because it allows someone to write a TypeScript configuration file that specifies the settings that should be applied to TypeScript codebases in a company/project and then everyone can simply extend this configuration file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-networking-fundamentals"><a class="header" href="#chapter-3-networking-fundamentals">Chapter 3: Networking Fundamentals</a></h1>
<p>This chapter explains the networking fundamentals that we will need for the later sections.
It is not intended to be a complete primer - we will only touch the concepts that are absolutely necessary to understand the later sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ips-ports-and-domains"><a class="header" href="#ips-ports-and-domains">IPs, Ports and Domains</a></h2>
<h3 id="the-ip-protocol"><a class="header" href="#the-ip-protocol">The IP Protocol</a></h3>
<p>An IP address is a label that is assigned to a network interface on your computer.
For example, your wireless network interface might have an IP address that it can use to communicate with other computers on the same wireless network.</p>
<p>Such an address consists of 4 numbers between 0 and 255, separated by dots.
Examples addresses might be <code>123.56.1.17</code> or <code>192.168.178.47</code>.</p>
<p>A particularly important IP address is <code>127.0.0.1</code> which can be used to identify the machine you're currently on.
For example, if you run a web server on your computer, you could access it at <code>127.0.0.1</code>.</p>
<p>Note that instead of saying that a network interface has a particular IP, we will often say that a computer has some IP.
This is because often we only really care about a particular interface (usually your wireless interface).
However, it is important to understand that diffent network interfaces can have different IP addresses even if they are located on the same machine.</p>
<h3 id="ports"><a class="header" href="#ports">Ports</a></h3>
<p>Usually you want to be able to run multiple networking services on your machine.
This is enabled by ports.</p>
<p>A <strong>port</strong> is simply a number assigned to uniquely identify a connection endpoint on a machine.
For example, I might have a web service running on port <code>443</code> and an ssh service on port <code>22</code>.</p>
<blockquote>
<p>The <code>ssh</code> protocol allows you to remotely log in to a computer and execute commands on it.</p>
</blockquote>
<p>These two services might run on the same computer with the same IP, because they can be distinguished by their port numbers.</p>
<h3 id="domains"><a class="header" href="#domains">Domains</a></h3>
<p>While IP addresses are great, they are very unwieldy and hard to remember for humans.
Indeed, in real life, we never tell someone to go to <code>142.251.37.14</code>, instead we tell them to "go to Google".</p>
<p>This is possible because of <strong>domains</strong>.
A domain (or <em>domain name</em>) is a string that identifies some network resource and usually has a corresponding IP address.</p>
<p>For example, the domain <code>google.com</code> might correspond to the IP address <code>142.251.37.14</code>.
That is, you can identify the resource either via <code>google.com</code> or via <code>142.251.37.14</code>.</p>
<p>The translation of domains to IP adresses is handled by the <strong>Domain Name System</strong> (DNS) protocol.
If you type <code>google.com</code> into your browser address bar, DNS will translate it to the correct IP under the hood.</p>
<blockquote>
<p>The reality is much more complicated.
A single domain usually corresponds to many IP addresses for load balancing reasons etc.
Nevertheless, this is a useful mental model to have.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="an-http-primer"><a class="header" href="#an-http-primer">An HTTP Primer</a></h2>
<h3 id="servers-and-clients"><a class="header" href="#servers-and-clients">Servers and Clients</a></h3>
<p><strong>Servers</strong> and <strong>clients</strong> are nothing more than regular programs (like the ones you saw in the first chapter).
For example, a server might be a JavaScript program that waits for HTTP requests and sends back responses.
A client might be a browser on your laptop or your phone - it might even be a regular script.</p>
<blockquote>
<p>Often, the term "server" is also used to refer to the actual machine the software is running on.</p>
</blockquote>
<p>When writing a web application, the most common way to get data from a server to a client and vice versa is by using the HTTP procotol.
HTTP is a <strong>request/response protocol</strong>, i.e. HTTP clients send requests to an HTTP server and receive a response in return.</p>
<p>You have in fact already used the HTTP protocol.
Every time you browse the internet, HTTP requests are sent under the hood.</p>
<p>We should mention that nowadays developers rarely use plain HTTP in production.
Instead, they use HTTPS, which is encrypted HTTP.
However, we won't cover HTTPS in detail, since that will automatically be handled for us by our deployment process.</p>
<h3 id="http-and-express"><a class="header" href="#http-and-express">HTTP and Express</a></h3>
<p>We could use the built-in HTTP module of Node.js, but this is not terribly convenient.
Instead we will use an extremely popular framework called <strong>Express</strong>.
While Express builds on top of the HTTP module, it provides a lot of additional useful functionality.</p>
<p>Create a new Node.js project inside some directory:</p>
<pre><code class="language-shell">pnpm init
</code></pre>
<p>Install Express:</p>
<pre><code class="language-shell">pnpm add express
</code></pre>
<p>Now create a file named <code>app.js</code> inside the directory.
As usual the name of the file is up to you, but it should be something meaningful.
In the file we will create an Express application and then make that application listen for connections on a specified host and port.</p>
<p>This is how you can create an Express application and make it listen on port <code>3000</code>:</p>
<pre><code class="language-javascript">const express = require('express');
const app = express();
const PORT = 3000;

app.listen(PORT, () =&gt; {
  console.log(`Server listening on port ${PORT}...`);
});
</code></pre>
<p>This application is not very useful, so let's add a <strong>route</strong> to it.
Add this above the call to <code>listen</code>:</p>
<pre><code class="language-javascript">app.get('/', (req, res) =&gt; {
  res.send('Hello, world!');
});
</code></pre>
<p>Start the application:</p>
<pre><code class="language-sh">node app.js
</code></pre>
<p>If you open a browser and navigate to <code>http://localhost:3000</code> you will see</p>
<pre><code>Hello, world!
</code></pre>
<p>You can also use cURL, which includes a command-line tool for transferring data on a network.
Among other things it supports HTTP and is available on both Windows and most Linux distributions.
Open a command line and run:</p>
<pre><code class="language-shell">curl http://localhost:3000/
</code></pre>
<p>The will output the following:</p>
<pre><code>Hello, world!
</code></pre>
<h3 id="http-urls"><a class="header" href="#http-urls">HTTP URLs</a></h3>
<p>The string <code>http://localhost:3000/</code> is a so called URL.
You have probably seen URLs before.
Navigate to Google and search for "Next.js" - you will notice that the URL in your browser looks like this:</p>
<pre><code>https://www.google.com/search?q=nextjs
</code></pre>
<p>For didactic reasons we will include the port:</p>
<pre><code>https://www.google.com:443/search?q=nextjs
</code></pre>
<p>Generally speaking, a typical HTTP(s) URL has the following form:</p>
<pre><code>scheme://host:port/path?key1=value1&amp;key2=value2#fragment
</code></pre>
<blockquote>
<p>Note the word <em>typical</em> here.
HTTP URLs (and especially more general URLs) can become <em>much more</em> complicated, but we will not cover all the little details in this book.
In fact the complexity of URLs is often a source of subtle bugs and browser crashes.
For example - at some point Android Chrome would <a href="https://news.ycombinator.com/item?id=28639708">crash</a> when trying to open <code>http://../foo</code>.</p>
</blockquote>
<p>The <strong>scheme</strong> usually indicates the protocol which describes how information should be transmitted.
We will almost exclusively use HTTP or HTTPS (which is just secure HTTP) in this book.
Therefore the scheme will almost always be either <code>http</code> or <code>https</code>.
In the above Google URL the scheme is clearly <code>https</code>.</p>
<p>You already learned about the <strong>host</strong> and the <strong>port</strong> - the host identifies the device you wish to connect to and the port is the communication endpoint on that device.
Note that the host could be a domain name (like <code>www.google.com</code>) or an IP address (like <code>142.251.36.238</code>).
Usually we will work with domain names since they are stable (unlike a lot of IP addresses).</p>
<blockquote>
<p>At the time of this writing 142.251.36.238 is one of Google's IP addresses.
This may of course change by the time you are reading this book.</p>
</blockquote>
<p>The next part is the <strong>path</strong>.
Assuming it is not empty, the path begins with a forward slash ("/") and uniquely identifies the resource we want to query.
In the Google URL the path is "/search".
Often paths will be hierarchical.
In this case the different components of the hierarchy are generally separated by slashes - for example "/path/to/resource".</p>
<p>The path can be followed by a <strong>query</strong>.
The query begins with a question mark and is followed by key-value pairs.
In the Google URL this is "?q=nextjs".
Here the query provides information about your search.
If there are multiple key-value pairs, they are separated by ampersands ("&amp;").
For example the query could be "?key1=value1&amp;key2=value2".</p>
<p>The query can be followed by a <strong>fragment</strong>.
This is used for navigation by the client and is not sent to server.</p>
<h3 id="get-and-post-requests"><a class="header" href="#get-and-post-requests">GET and POST requests</a></h3>
<p>HTTP knows multiple <strong>request methods</strong>.
We primarily care about two request methods for now - namely <strong>GET</strong> and <strong>POST</strong>.
GET requests are generally used to retrieve data.</p>
<p>Recall out route from above:</p>
<pre><code class="language-javascript">app.get('/', (req, res) =&gt; {
  res.send('Hello world!');
});
</code></pre>
<p>This indicates that if a GET request is sent to the path '/', we would like to return 'Hello, world!' to the client.
The <code>req</code> variable represents the <strong>request object</strong> and <code>res</code> represents the <strong>respose object</strong>.
If we want to send a HTTP response to the client we therefore use <code>res.send</code>.</p>
<p>POST requests are generally used to send information to the server that tell it to create a new resource or update an existing resource.
For example a login request will generally be a POST request since it tells the server that a user has logged in to the application.
Similarly, if you submit a web form, there will usually be a POST request attached to that, since form submissions carry new information.</p>
<p>With POST requests, we are more interested in telling the server that something happened than in the data the server returns to us.</p>
<p>POST requests usually need to send much more information to the server than GET requests.
Therefore, POST requests can have a <strong>request body</strong> which allows us to carry this additional data when sending a request.</p>
<p>Let's have a look at an example.
Note that we need to enable some middleware (we will return to the concept of middleware later):</p>
<pre><code class="language-javascript">app.use(express.text());
</code></pre>
<p>Consider the following route which simply returns the request body back to the client:</p>
<pre><code class="language-javascript">app.post('/post-example', (req, res) =&gt; {
  res.send(req.body);
});
</code></pre>
<p>How do we test this?
You cannot simply send a POST request in a browser the way you would send a GET request.
This is where <code>curl</code> comes in really handy.
We need to specify that we want to send a POST request using the <code>-X</code> flag.
In addition we specify the data that we want to send in the <em>body</em> of the POST request using the <code>-d</code> flag.
Finally we specify a header called <code>Content-Type</code> and set it to <code>text/plain</code>.
This indicates that the data we want to send is plain text.</p>
<p>The final command looks like this:</p>
<pre><code>curl -X POST -H "Content-Type: text/plain" -d 'haha' http://localhost:3000/post-example
</code></pre>
<p>Generally speaking GET requests transmit information using the querystring, while POST requests transmit information in the request body.</p>
<p>Note that we will rarely send plain text in the request.
Instead we will use a special format called JSON.
This is a file format that supports a bunch of primitive values, arrays and dictionaries.
A typical JSON object could look like this:</p>
<pre><code class="language-json">{
  "tasks": ["Task 1", "Task 2", "Task 3"],
  "date": {
    "year": 2022,
    "month": 06,
    "date": 18
  }
}
</code></pre>
<p>In order to accept JSON requests, we need to replace the <code>express.text</code> middleware with the <code>express.json</code> middleware:</p>
<pre><code class="language-json">app.use(express.json());
</code></pre>
<p>Now we can curl the same path like this:</p>
<pre><code>curl -X POST -H "Content-Type: application/json" -d '{ "key": "value" }' http://localhost:3000/post-example
</code></pre>
<p>Note that here we specify the <code>application/json</code> content type.</p>
<blockquote>
<p>This is all fine and dandy, but how do client and server know how to interpret all these things?
The answer to that question is the IETF (short for Internet Engineering Task Force).
This is an organization that sets standards for the Internet (hence the name).
Among other things it is responsible for creating the various RFCs (Request for Comments) that outline the workings of HTTP.
For example HTTP 1.1 (which is the most common HTTP version you will encounter at the time of this writing) is outlined in RFCs 7230-7235.
URIs on the other hand are outlined in RFC 3986.
We encourage you to have a quick look at the respective RFCs.
You should <em>definitely not</em> read them all at this stage, but just understand the sheer complexity of the things we are discussing here.
We are really just scratching a very tiny part of the surface of it all.
Lucky for you, most of the RFCs will probably not be terribly relevant in your day-to-day life.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="more-on-http"><a class="header" href="#more-on-http">More on HTTP</a></h2>
<h3 id="status-codes"><a class="header" href="#status-codes">Status Codes</a></h3>
<p>Responses can have status codes attached to them.
These indicate the status of a request.</p>
<p>For example, a status <code>400</code> means <code>Bad Request</code>, the famous status <code>404</code> means <code>Not Found</code> and <code>500</code> stands for <code>Internal Server Error</code>.</p>
<p>Here is how you can manually return a status code in Express:</p>
<pre><code class="language-js">app.post('/', (req, res) =&gt; {
  const data = req.body;

  // If the request body is empty, we return status code 400 (Bad Request)
  if (Object.keys(data).length === 0) {
    res.status(400).send('Bad Request: No data provided');
  } else {
    res.status(201).send(`Received data: ${JSON.stringify(data)}`);
  }
});
</code></pre>
<h3 id="headers"><a class="header" href="#headers">Headers</a></h3>
<p>Both requests and responses can have <strong>headers</strong> which provide important information that is not part of the main request or response content.
For example, request headers might contain the version of the browser that is making the request, what languages are accepted, what encodings are accepted etc.</p>
<p>Similarly, response headers might contain the type of the content, the date of the response etc.</p>
<p>Here is how you can set response headers in Express:</p>
<pre><code class="language-js">app.post('/', (req, res) =&gt; {
  const data = req.body;

  // Add a custom header
  res.set('X-Custom-Header', 'MyHeaderValue');

  res.status(201).send(`Received data: ${JSON.stringify(data)}`);
});
</code></pre>
<h3 id="cookies"><a class="header" href="#cookies">Cookies</a></h3>
<p>HTTP <strong>cookies</strong> are pieces of data that are created by the server, sent to the browser and then saved on the browser.
Cookies can be used for things like authentication.</p>
<p>For example, the server might generate a cookie for a logged in user, send it to the browser and then the browser could send the cookie with each request (avoiding the need for the user to log in on every request).</p>
<p>Note that cookies are simply set as part of the headers.
For example, a request might contain a "Cookie" header containing the cookies it has currently stored.
A response might contain a "Set-Cookie" header which contains the cookies that the browser should set (or clear).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-a-vanilla-client"><a class="header" href="#chapter-4-a-vanilla-client">Chapter 4: A Vanilla Client</a></h1>
<div style="text-align: right"> <i> Whenever you write a web app in vanilla JavaScript, you end up creating your own framework. <br> And who in their right mind wants another JavaScript framework? <br> - Common programmer idiom </i> </div>
<p>In this chapter we will write a client in <em>vanilla</em> HTML and JavaScript (i.e. without using any frameworks).
Then we will realize why this is not such a great idea and why we might want to consider using a library (spoiler: it's going to be React) to help us out.</p>
<p>If this sounds like a pointless exercise - it's not.
You need to know the basics of HTML anyway (even if you will use React for everything later).
Additionally, web development shouldn't consists of stapling a bunch of magic together and praying that it works.
In order to accomplish this, you will need a solid foundation to build on.</p>
<p>This chapter presents that solid foundation.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hypertext-markup-language"><a class="header" href="#hypertext-markup-language">Hypertext Markup Language</a></h2>
<div style="text-align: right"> <i> Hey guys, how do I parse HTML with a regular expression? <br> - Seconds before disaster </i> </div>
<h3 id="a-minimal-html-file"><a class="header" href="#a-minimal-html-file">A Minimal HTML File</a></h3>
<p>Create a project directory (<em>easy-opus</em> for example).
From here on, all work will be done within the <em>easy-opus</em> directory.</p>
<p>Now, let's create a webpage using <strong>HTML</strong>, a markup language designed for defining documents to be displayed in a browser.
We briefly touched on HTML in section 1.1, but now we will look at HTML a bit more in detail.</p>
<blockquote>
<p>Markup languages provide rules for defining the type of information contained in a document.
Markup languages differ from programming languages - while markup languages enable the creation of displayable documents, programming languages offer much more powerful capabilities.
Therefore HTML is a markup language and JavaScript is a programming language.</p>
</blockquote>
<p>Create a file named <code>index.html</code> in the project directory.
Now write some minimal useful HTML to display two hardcoded tasks:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Easy Opus&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;div&gt;
        &lt;h1&gt;My tasks&lt;/h1&gt;
        &lt;div id="taskList"&gt;
          &lt;p&gt;Read the Next.js book&lt;/p&gt;
          &lt;p&gt;Write a website&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>When you open the HTML file in your browser you should see a heading and two tasks.</p>
<p>Hooray, you've created a simple HTML document!
Now you can close this book and go procrastinate.</p>
<p>What's that?
You're not budging?
Hm, that's weird.
Oh we see, you've <em>unfortunately</em> been <em>forced</em> to read this book (blink <em>once</em> for help).</p>
<p>Well, since both of us have to be here anyway, let's march onwards and dissect the masterpiece you've just created!</p>
<h3 id="html-elements"><a class="header" href="#html-elements">HTML Elements</a></h3>
<p>HTML is comprised of <strong>HTML elements</strong> used to specify the type of content you want to render.
For example, the <code>p</code> element represents a paragraph:</p>
<pre><code class="language-html">&lt;p&gt;Read the Next.js book&lt;/p&gt;
</code></pre>
<p>An HTML element usually has some <strong>content</strong> between an <strong>opening tag</strong> and a <strong>closing tag</strong>.
The opening tag is the name of the element wrapped in angle brackets (like <code>&lt;p&gt;</code>).
The closing tag is the name of the element wrapped in angle brackets with a <em>forward slash before the element name</em> (like <code>&lt;/p&gt;</code>).</p>
<p>There are various HTML elements with different purposes, such as <code>p</code> for paragraphs and <code>div</code> for generic containers.
We will discuss a few important HTML elements in the following sections.</p>
<p>HTML's power lies in the fact that most elements can be nested.
For example, you could nest paragraphs within a generic container:</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;Read the Next.js book&lt;/p&gt;
  &lt;p&gt;Create a website&lt;/p&gt;
  &lt;p&gt;???&lt;/p&gt;
  &lt;p&gt;Profit!&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>The nesting can go as many levels as you want.
For example, we could use the <code>&lt;em&gt;</code> element to emphasize some of the words in the previous example:</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;p&gt;Read the &lt;em&gt;Next.js&lt;/em&gt; book&lt;/p&gt;
  &lt;p&gt;Create a &lt;em&gt;website&lt;/em&gt;&lt;/p&gt;
  &lt;p&gt;???&lt;/p&gt;
  &lt;p&gt;Profit!&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>Note that to do nesting correctly, the tags of the element being nested must be inside the tags of the element it is being nested in.
For example the tags of the element <code>&lt;em&gt;Next.js&lt;/em&gt;</code> are inside the element <code>&lt;p&gt;Read the &lt;em&gt;Next.js&lt;/em&gt; book&lt;/p&gt;</code>.</p>
<h3 id="html-attributes"><a class="header" href="#html-attributes">HTML Attributes</a></h3>
<p>Elements can also have <strong>HTML attributes</strong>.
Attributes contain further information about the element.
Two particularly important attributes are <code>id</code> and <code>class</code>.</p>
<p>The <code>id</code> attribute is used to specify a <strong>unique identity</strong> for an HTML element.
You can use that attribute to - well - uniquely identify an element.
This allows us to reference that element using JavaScript or CSS.</p>
<p>Here is how we can create an element with an <code>id</code> attribute:</p>
<pre><code class="language-html">&lt;p id="readBook"&gt;Read the Next.js book&lt;/p&gt;
</code></pre>
<p>Generally speaking, you can specify attributes by writing the attribute name, followed by an equal sign, followed by the attribute value wrapped inside double quotes.</p>
<p>The <code>class</code> attribute is used to specify a <strong>class</strong> for an HTML element.
Unlike unique identifiers, multiple HTML elements can share the same class, which is useful for applying consistent styles to multiple elements.
For example you could color all HTML elements of class <code>blue-text</code> blue.</p>
<p>Here is how we can create an element with a <code>class</code> attribute:</p>
<pre><code class="language-html">&lt;p class="blue-text"&gt;Read the Next.js book&lt;/p&gt;
</code></pre>
<p>There are many more attributes and different HTML elements often have different attributes.</p>
<p>We will cover some of the most important elements together with their attributes in the next section.</p>
<h3 id="structure-of-an-html-document"><a class="header" href="#structure-of-an-html-document">Structure of an HTML Document</a></h3>
<p>Let's have a look at <code>index.html</code> again and examine its structure in more detail:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Easy Opus&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;div&gt;
        &lt;h1&gt;My tasks&lt;/h1&gt;
        &lt;div id="taskList"&gt;
          &lt;p&gt;Read the Next.js book&lt;/p&gt;
          &lt;p&gt;Write a website&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The document begins with <code>&lt;!doctype html&gt;</code> which is a <em>document type declaration</em>.
It is there mainly for historical reasons - in the <em>olden days</em> of HTML the doctype specified which rules the HTML page followed.
Nowadays, we just use the shortest valid doctype which happens to be <code>&lt;!doctype html&gt;</code>.</p>
<p>The doctype is followed by an <code>&lt;html&gt;</code> element which contains all the content of the document.
This element is usually called the <strong>root element</strong>.</p>
<p>The <code>&lt;head&gt;</code> element includes important information about the page that doesn't appear on the page itself.
Here is where we could specify how our page would appear in search results, which character encoding our website uses and more.</p>
<p>In our example the <code>&lt;head&gt;</code> element includes a <code>&lt;meta&gt;</code> element with a <code>charset</code> attribute and a <code>&lt;title&gt;</code> element.
This particular <code>&lt;meta&gt;</code> element describes the character encoding for the HTML document (we will return to this later in more detail) and the <code>&lt;title&gt;</code> element sets the title of the page.
This title is displayed in the browser tab and is also used when you save the page in your bookmarks.</p>
<p>Finally the <code>&lt;body&gt;</code> element contains all the content that will actually be rendered on the page.
In our example, the heading and the task list are within the <code>&lt;body&gt;</code> element.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="marking-up-text"><a class="header" href="#marking-up-text">Marking Up Text</a></h2>
<div style="text-align: right"> <i> Who needs semantic HTML anyway? <br> - Seconds before disaster </i> </div>
<h3 id="the-paragraph-element"><a class="header" href="#the-paragraph-element">The Paragraph Element</a></h3>
<p>The most basic element for marking up text is the paragraph element <code>&lt;p&gt;</code>:</p>
<pre><code class="language-html">&lt;p&gt;This is the first paragraph of many, many paragraphs.&lt;/p&gt;
&lt;p&gt;This is the second paragraph of many, many paragraphs.&lt;/p&gt;
&lt;p&gt;This is the third paragraph of many, many paragraphs.&lt;/p&gt;
</code></pre>
<p>Visually paragraphs are represented as text blocks separated from surrounding content by blank lines.
Paragraphs are commonly used to group related text.</p>
<h3 id="breaking-up-text"><a class="header" href="#breaking-up-text">Breaking Up Text</a></h3>
<p>You can break up text with the line break element <code>&lt;br&gt;</code>:</p>
<pre><code class="language-html">There is a line break here. &lt;br /&gt;
This is some text after the line break.
</code></pre>
<p>Additionally you can use the <code>&lt;hr&gt;</code> element for a thematic break of some text.
It will usually be visually presented as a horizontal line.</p>
<pre><code class="language-html">Here is some text. &lt;hr /&gt; Here some text about something totally different.
</code></pre>
<p>Often the <code>&lt;hr /&gt;</code> element is used to introduce thematic breaks between paragraphs.</p>
<h3 id="heading-elements"><a class="header" href="#heading-elements">Heading Elements</a></h3>
<p>There are six heading elements, <code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>.
The different heading elements represent different "heading levels", e.g. <code>&lt;h1&gt;</code> is the main heading, <code>&lt;h2&gt;</code> a subheading and so on:</p>
<pre><code class="language-html">&lt;h1&gt;Main heading&lt;/h1&gt;

&lt;h2&gt;Subheading 1&lt;/h2&gt;
&lt;h3&gt;Subsubheading 1.1&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 1.1&lt;/p&gt;
&lt;h3&gt;Subsubheading 1.2&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 1.2&lt;/p&gt;

&lt;h2&gt;Subheading 2&lt;/h2&gt;

&lt;h3&gt;Subsubheading 2.1&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 2.1&lt;/p&gt;
&lt;h3&gt;Subsubheading 2.2&lt;/h3&gt;
&lt;p&gt;Some content related to subheading 2.2&lt;/p&gt;
</code></pre>
<p>You will rarely need <code>&lt;h4&gt;</code> to <code>&lt;h6&gt;</code> - very few documents require such an amount of heading levels.</p>
<blockquote>
<p>Always try to use a single <code>&lt;h1&gt;</code> per page since this is the top level heading.</p>
</blockquote>
<h3 id="emphasis-and-importance"><a class="header" href="#emphasis-and-importance">Emphasis and Importance</a></h3>
<p>If we want to emphasize a part of a text (like an important word) we can use the <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> elements.
The <code>&lt;em&gt;</code> element marks that a text should be emphasized, for example:</p>
<pre><code class="language-html">The weather today is &lt;em&gt;very&lt;/em&gt; hot.
</code></pre>
<p>The <code>&lt;strong&gt;</code> element marks that a text has strong importance, for example:</p>
<pre><code class="language-html">The weather today is not just hot, it's &lt;strong&gt;scorching&lt;/strong&gt;.
</code></pre>
<p>As you probably guessed, deciding which of these two elements is appropriate is largely on you.
If you want to emphasize some part of a text, but it doesn't have strong urgency you should use <code>&lt;em&gt;</code>.
If a text is very important, you should use <code>&lt;strong&gt;</code></p>
<blockquote>
<p>There are also <code>&lt;i&gt;</code> and <code>&lt;b&gt;</code>, however we will rarely use them, since <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> have a semantic meaning (see below for what this means).</p>
</blockquote>
<h3 id="other-text-elements"><a class="header" href="#other-text-elements">Other Text Elements</a></h3>
<p>We only scratched the surface of the kind of text markup you can perform with HTML.
There are many, many other elements you can use.
For example, you can mark up subscripts and superscripts with <code>&lt;sub&gt;</code> and <code>&lt;sup&gt;</code> respectively:</p>
<pre><code class="language-html">The chemical formula for water is H&lt;sub&gt;2&lt;/sub&gt;O.
&lt;p&gt;The equation for energy is E = mc&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;
</code></pre>
<p>You can add quotes - both blockquotes (with <code>&lt;blockquote&gt;</code>) and inline quotes (with <code>&lt;q&gt;</code>):</p>
<pre><code class="language-html">&lt;p&gt;As the famous physicist once said:&lt;/p&gt;

&lt;blockquote cite="https://some-random-quotes.com/"&gt;
  "Stop believing quotes you found on the internet"
&lt;/blockquote&gt;

&lt;p&gt;
  As Einstein once said,
  &lt;q&gt;people who build their lifes around random internet quotes are stupid.&lt;/q&gt;
&lt;/p&gt;
</code></pre>
<p>The point here is not to learn everything single HTML element for marking up text (you can look these up with a simple Google search anyway), but to be aware that when it comes to marking up text there might be an HTML element for your use case.</p>
<h3 id="semantic-html"><a class="header" href="#semantic-html">Semantic HTML</a></h3>
<p>In a few chapters, we will introduce you to CSS, which will allow you to style your HTML elements however you like.
At this point most people forget that there are any elements besides the generic containers <code>&lt;div&gt;</code> and <code>&lt;span&gt;</code> since they can now just <em>style</em> a <code>&lt;span&gt;</code> to look like an <code>&lt;h1&gt;</code>.</p>
<p>This is a <em>really bad idea</em>.</p>
<p>The reason this is bad is that <em>looking</em> at a page is not the only way to browse the web.</p>
<p>First of all, there are a lot of visually impaired people in the world who use screen readers to navigate the internet.
Screen readers tend to focus on the HTML elements and not the styles (which makes sense, since reading out styles is not really something you want to do).</p>
<p>If you write a heading as a styled <code>&lt;span&gt;</code> instead of an <code>&lt;h1&gt;</code> you are not only doing more (unneccessary) work, you also give visually impaired people a worse experience.
Screen readers often interpret headings in a special way - for example you can ask most screen readers to read all headings on a page out loud and then jump to some heading you care about.
This is of course not possible with <code>&lt;span&gt;</code>s.</p>
<p>Second, your page will also be consumed by programs responsible for indexing and ranking.
If your website contains generic containers only, it will usually be downgraded resulting in (shock and horror) <em>bad Search Engine Optimization</em>.</p>
<p>Therefore you should <em>absolutely not</em> forget about the <em>semantically correct</em> HTML element we presented in this section.</p>
<blockquote>
<p>Also, if you don't use semantically correct HTML, your fellow developers will let you know about this in the <em>smuggest</em> way possible which will feel bad for you.
After all, <em>you</em> want to be one smuggly telling your collegue - "you know, I don't think that this is semantically correct".</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hyperlinks-and-images"><a class="header" href="#hyperlinks-and-images">Hyperlinks and Images</a></h2>
<div style="text-align: right"> <i> Who uses `alt` tags on images? They're just decorations, right? <br> - Seconds before disaster </i> </div>
<h3 id="hyperlinks"><a class="header" href="#hyperlinks">Hyperlinks</a></h3>
<p>One of the most important HTML elements is the <strong>hyperlink</strong>.
You are probably already familiar with hyperlinks - they allow you to link web pages, documents or other resources from your page.
If the link is clicked, the linked page is typically opened in your browser for you to see.</p>
<p>Here is how you can create a hyperlink:</p>
<pre><code class="language-html">&lt;a href="https://example.com"&gt;Example&lt;/a&gt;
</code></pre>
<p>This creates a link with the text "Example" that links the resource mentioned in the <code>href</code> attribute (which in this case is <code>"https://example.com"</code>).
By default the text becomes blue and is underlined.
If you click the text, the web browser opens the page located at <code>https://example.com</code>.</p>
<p>Note that HTML elements can also be made into links, for example:</p>
<pre><code class="language-html">&lt;a href="https://example.com"&gt;
  &lt;h1&gt;Example&lt;/h1&gt;
&lt;/a&gt;
</code></pre>
<h3 id="images"><a class="header" href="#images">Images</a></h3>
<p>To show an image, you can use the <code>&lt;img&gt;</code> element:</p>
<pre><code class="language-html">&lt;img src="cat.jpg" alt="A cute cat" /&gt;
</code></pre>
<blockquote>
<p>Notice that the <code>img</code> element is a self-closing HTML element, since it doesn't contain any content.
Instead of <code>&lt;img&gt;&lt;/img&gt;</code> we write <code>&lt;img /&gt;</code>.</p>
</blockquote>
<p>The <code>src</code> attribute contains the path to the image you want to show.
The <code>alt</code> attribute holds a textual replacement for the image and is necessary in case the image can't be shown.
Try misspelling the filename on purpose and you will see the textual replacement.</p>
<p>In practice the textual replacement is useful if, for example:</p>
<ul>
<li>there is a network error and the image can't be fetched</li>
<li>the user is using a screen reader (in this case the textual replacement may be read out loud to him)</li>
<li>the browser doesn't support the image type</li>
<li>the user has turned off images to reduce data transfer</li>
</ul>
<p>Additionally search engines will usually look at the <code>alt</code> attributes of images when processing your web page.</p>
<p>You should therefore <em>always</em> include the <code>alt</code> attribute for every image you serve.</p>
<blockquote>
<p>The <code>alt</code> attribute is a typical example of semantically correct HTML.
Sure, your page will usually look right even if you don't use it, but the user experience for some users will be much worse.</p>
</blockquote>
<h3 id="image-links"><a class="header" href="#image-links">Image Links</a></h3>
<p>You can use the fact that HTML elements can be made into links to create image links:</p>
<pre><code class="language-html">&lt;a href="https://example.com"&gt;
  &lt;img src="example.png" alt="An example image" /&gt;
&lt;/a&gt;
</code></pre>
<p>This will show a clickable image - if the image is clicked, the browser will open <code>https://example.com</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-document-object-model"><a class="header" href="#the-document-object-model">The Document Object Model</a></h2>
<div style="text-align: right"> <i> Well, DOM and HTML are baaaasically the same thing. <br> - Seconds before disaster </i> </div>
<h3 id="html-and-dom"><a class="header" href="#html-and-dom">HTML and DOM</a></h3>
<p>When you open an HTML document in a browser, it is represented by the <strong>Document Object Model</strong> (DOM for short).
Essentially, the DOM is a model for documents which represent <em>editable logical trees</em>.
This sounds <em>way</em> scarier than it really is, so let's consider the following example:</p>
<pre><code class="language-html">&lt;div id="taskList"&gt;
  &lt;p&gt; Read the Next.js book: Read and understand the Next.js book. &lt;/p&gt;
  &lt;p&gt; Write a website: Create a new and cool website. &lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>Here we have a <code>&lt;div&gt;</code> element (the generic container) and two <code>&lt;p&gt;</code> (paragraph) elements inside it.
The <code>&lt;div&gt;</code> element is the <em>parent</em> of the <code>&lt;p&gt;</code> elements and the <code>&lt;p&gt;</code> elements are the <em>children</em> of the <code>&lt;div&gt;</code> element.
The elements form a (very small) <em>tree</em>:</p>
<p><img src="chapter4/images/small_tree.png" alt="" /></p>
<p>Let's take a look at a bigger document:</p>
<pre><code class="language-html">&lt;div id="app"&gt;
  &lt;h1&gt;My tasks&lt;/h1&gt;
  &lt;div id="taskList"&gt;
    &lt;p&gt; Read the Next.js book: Read and understand the Next.js book. &lt;/p&gt;
    &lt;p&gt; Write a website: Create a new and cool website. &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>You can visualize this document in the following way:</p>
<p><img src="chapter4/images/tree.png" alt="" /></p>
<p>It's crucial to distinguish between HTML and the DOM, as they are <em>absolutely</em> not the same thing.
The DOM is a <em>language-agnostic model</em> that represents the structure of a document.
On the other hand, HTML is a <em>specific language</em> that encodes a particular kind of DOM into text usable by web browsers.</p>
<p>To simplify, <em>you</em> write HTML, the browser parses that and then <em>the browser</em> displays a DOM tree.</p>
<h2 id="manipulating-the-dom-using-javascript"><a class="header" href="#manipulating-the-dom-using-javascript">Manipulating the DOM using JavaScript</a></h2>
<p>Whenever you write applications which have a lot of logic in the client, you will need to manipulate the DOM (i.e. add, remove, change or retrieve elements).
This can be done by using JavaScript functions that exist on the <code>document</code> object, which is is a global variable that refers to the currently rendered DOM tree.</p>
<p>For the rest of this section, we will consider the following document:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Easy Opus&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;
      &lt;h1&gt;My tasks&lt;/h1&gt;
      &lt;div id="taskList"&gt;
        &lt;p id="firstParagraph" class="task"&gt; Read the Next.js book &lt;/p&gt;
        &lt;p id="secondParagraph" class="task"&gt; Write a website &lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>If you want to follow along, you can open this document in a browser, open the JavaScript console and then write the code in the console.</p>
</blockquote>
<p>First let's talk about how to <em>retrieve</em> elements.</p>
<p>The <code>document.getElementById(id)</code> function allows you to select an element by its unique ID:</p>
<pre><code class="language-js">const paragraph = document.getElementById('firstParagraph');
console.log(paragraph); // &lt;p id="firstParagraph" class="task"&gt;
</code></pre>
<p>Note that <code>paragraph</code> is just a regular JavaScript object.</p>
<p>For example, you could access various properties like the element ID and class or the HTML markup contained within the element:</p>
<pre><code class="language-js">console.log(paragraph.id); // firstParagraph
console.log(paragraph.className); // task
console.log(paragraph.innerHTML); // Read the Next.js book
</code></pre>
<p>We can also get all the elements that have a certain class using <code>document.getElementsByClassName(className)</code>:</p>
<pre><code class="language-js">const tasks = document.getElementsByClassName('task');
console.log(tasks); // HTMLCollection { 0: p#firstParagraph.task, 1: p#secondParagraph.task, length: 2, … }
</code></pre>
<p>Note that <code>tasks</code> is an <code>HTMLCollection</code> which is an array-like object.
This means that it behaves similar to an array (for example you can index it), but doesn't have most of the array methods we learned in the first chapter:</p>
<pre><code class="language-js">console.log(tasks.length); // 2
console.log(tasks[0]); // &lt;p id="firstParagraph" class="task"&gt;

// This will throw a TypeError: tasks.map is not a function
const ids = tasks.map((task) =&gt; task.id);
</code></pre>
<p>You can also retrieve all elements with a certain tag by using <code>document.getElementsByTagName(tagName)</code>.
Consider this example:</p>
<pre><code class="language-js">const paragraphs = document.getElementsByTagName('p');
console.log(paragraphs); // HTMLCollection { 0: p#firstParagraph.task, 1: p#secondParagraph.task, length: 2, … }
</code></pre>
<p>Note how this is again an <code>HTMLCollection</code>.</p>
<p>The two most important and modern JavaScript methods for element retrieval are <code>document.querySelector(selector)</code> and <code>document.querySelectorAll(selector)</code> which returns the first and all elements that match a certain CSS selector respectively.
Here is how we could use these methods to accomplish our tasks from before:</p>
<pre><code class="language-js">// The hash (#) indicates an ID selector
const paragraph = document.querySelector('#firstParagraph');
// The period (.) indicates a class selector
const tasks = document.querySelectorAll('.task');
const paragraphs = document.querySelectorAll('p');
</code></pre>
<p>Note that this time <code>tasks</code> will be a <code>NodeList</code> (instead of an <code>HTMLCollection</code>).
However it is still an array-like object that you can index with <code>[]</code>.</p>
<p>JavaScript also allows us to create elements and append them to other elements.
You can create elements using <code>document.createElement(tagName)</code>.</p>
<p>This is how you could create a paragraph with an ID, a class and some text:</p>
<pre><code class="language-js">const element = document.createElement('p');
element.id = 'thirdParagraph';
element.classList.add('task');
element.innerHTML = 'New task';
</code></pre>
<p>You can append an element as a last child of a parent element using <code>parentElement.appendChild(childElement)</code>.
For example to append the newly created <code>element</code> to another element <code>taskList</code> you would write this:</p>
<pre><code class="language-js">// Retrieve the taskList element
const taskList = document.querySelector('#taskList');

// Append element to taskList
taskList.appendChild(element);
</code></pre>
<p>Let's put all of this together and add a button to our page that allows us to add a new task.</p>
<p>This is the JavaScript that we would like to execute if the button is clicked:</p>
<pre><code class="language-javascript">const paragraph = document.createElement('p');
paragraph.id = 'thirdParagraph';
paragraph.classList.add('task');
paragraph.innerHTML = 'New task';
const taskList = document.querySelector('#taskList');
taskList.appendChild(paragraph);
</code></pre>
<p>We would now have to add a <code>button</code> element and execute this code whenever the button is clicked by registering a <code>click</code> event listener on the button:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Easy Opus&lt;/title&gt;
    &lt;script&gt;
      function addTask() {
        const paragraph = document.createElement('p');
        paragraph.id = 'thirdParagraph';
        paragraph.classList.add('task');
        paragraph.innerHTML = 'New task';
        const taskList = document.querySelector('#taskList');
        taskList.appendChild(paragraph);
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="taskList"&gt;
      &lt;button id="addTask" onclick="addTask()"&gt;Add a task&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>Note that if we want this code to work correctly when clicking the button multiple times, we should change the ID on each button click.
Try doing this by yourself.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="web-forms"><a class="header" href="#web-forms">Web Forms</a></h2>
<div style="text-align: right"> <i> A 10-page registration form seems reasonable, right? <br> - Seconds before disaster </i> </div>
<h3 id="why-web-forms"><a class="header" href="#why-web-forms">Why Web Forms?</a></h3>
<p><strong>Web forms</strong> (or just <strong>forms</strong> for short) provide a tool for accepting user input.
They are one of the key components that make your pages interactive.
A web form contains one or more <strong>form controls</strong> which are usually paired with text labels that describe the purpose of the control.
For example a textual form control for providing a message might be paired with a label explaining that the textual form control represents a message.</p>
<p>Consider a very common example - the contact form.</p>
<p>Such a contact form should probably have:</p>
<ul>
<li>a text input for the name of the user submitting the form</li>
<li>a text input for the email of the user submitting the form</li>
<li>a multiline text input for the message to submit</li>
<li>a submit button</li>
</ul>
<h3 id="creating-a-form"><a class="header" href="#creating-a-form">Creating a Form</a></h3>
<p>Forms can be created using the <code>&lt;form&gt;</code> element:</p>
<pre><code class="language-html">&lt;form&gt; ... &lt;/form&gt;
</code></pre>
<blockquote>
<p>Note that usually <code>&lt;form&gt;</code> elements contain an <code>action</code> attribute which defines the URL where the form's data should be submitted.
However, in this book we will handle form submissions manually, so we won't go into detail on the <code>action</code> attribute.</p>
</blockquote>
<p>Let's now add the form control for the username along with a label (note that the elements should go in between the <code>&lt;form&gt;&lt;/form&gt;</code> tags):</p>
<pre><code class="language-html">&lt;!-- The label --&gt;
&lt;label for="name"&gt;Name:&lt;/label&gt;
&lt;!-- The form control--&gt;
&lt;input type="text" id="name" name="name" /&gt;
</code></pre>
<p>There are two HTML elements at play here - <code>&lt;input&gt;</code> and <code>&lt;label&gt;</code>.</p>
<p>The form control is represented by the <code>&lt;input&gt;</code> element.
It has a lot of various attributes, but the two most important ones (apart from the <code>id</code> attribute) are the <code>type</code> and <code>name</code> attribute.
The <code>type</code> attribute represents the type of the form control.
For example a plaintext input field would have the type <code>text</code> while a checkbox would have the type <code>checkbox</code> (big surprise).
The <code>name</code> attribute specifies a name for the form control.
This attribute is important when submitting the form (usually by clicking the submit button) as it will identify the submitted value.</p>
<p>The label is represented by the <code>&lt;label&gt;</code> element.
The <code>for</code> attribute of the label must be an ID for a form control.
In this case the ID of the <code>&lt;input&gt;</code> element is <code>name</code> and therefore the <code>for</code> attribute of the <code>&lt;label&gt;</code> element has <code>name</code> as its value.</p>
<p>Now let's add the form control for the email.
We could theoretically use the <code>text</code> type again, however HTML provides us a custom email type called <code>email</code>.
This field looks like a regular text input, but has a few additional nice properties - for example the email is validated on submission:</p>
<pre><code class="language-html">&lt;!-- The label --&gt;
&lt;label for="email"&gt;Email:&lt;/label&gt;
&lt;!-- The form control--&gt;
&lt;input type="email" id="email" name="email" /&gt;
</code></pre>
<p>Finally, for the multiline text, we will use the <code>&lt;textarea&gt;</code> element:</p>
<pre><code class="language-html">&lt;!-- The label --&gt;
&lt;label for="message"&gt;Message:&lt;/label&gt;
&lt;!-- The form control--&gt;
&lt;textarea id="message" name="message"&gt;&lt;/textarea&gt;
</code></pre>
<p>The last element we need is the submit button:</p>
<pre><code class="language-html">&lt;button type="submit"&gt;Send&lt;/button&gt;
</code></pre>
<p>Here is how the final form will look like:</p>
<pre><code class="language-html">&lt;form id="contact"&gt;
  &lt;label for="name"&gt;Name:&lt;/label&gt;
  &lt;input type="text" id="name" name="name" /&gt;
  &lt;label for="email"&gt;Email:&lt;/label&gt;
  &lt;input type="email" id="email" name="email" /&gt;
  &lt;label for="message"&gt;Message:&lt;/label&gt;
  &lt;textarea id="message" name="message"&gt;&lt;/textarea&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<h3 id="structuring-forms-with-fieldset-and-legend"><a class="header" href="#structuring-forms-with-fieldset-and-legend">Structuring Forms with <code>&lt;fieldset&gt;</code> and <code>&lt;legend&gt;</code></a></h3>
<p>We can use the <code>&lt;fieldset&gt;</code> and <code>&lt;legend&gt;</code> attrributes to further improve our form:</p>
<pre><code class="language-html">&lt;form id="contact"&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;Message Form&lt;/legend&gt;
    &lt;label for="name"&gt;Name:&lt;/label&gt;
    &lt;input type="text" id="name" name="name" /&gt;
    &lt;label for="email"&gt;Email:&lt;/label&gt;
    &lt;input type="email" id="email" name="email" /&gt;
    &lt;label for="message"&gt;Message:&lt;/label&gt;
    &lt;textarea id="message" name="message"&gt;&lt;/textarea&gt;
    &lt;button type="submit"&gt;Send&lt;/button&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<h2 id="handling-a-form-submission"><a class="header" href="#handling-a-form-submission">Handling a Form Submission</a></h2>
<p>If you click the button right now, the page will refresh, the URL will change and your inputs will be cleared.
This is the default behaviour of a form submission, however we often want to intercept and modify this.</p>
<p>To achieve this, let's add an event listener to the form that will listen for submit events.</p>
<p>This can be done via the <code>addEventListener</code> function which takes two arguments.
The first argument is the event to listen to (which is <code>'submit'</code> in this case).
The second argument is a function that takes the specific event and handles it.</p>
<blockquote>
<p>The <code>addEventListener</code> is a typical example of a higher-order function since it takes a function as one of its arguments.</p>
</blockquote>
<p>We will just log the <code>currentTarget</code> of the event for now.
This property identifies the element to which the event handler has been attached (in this case it's the form).</p>
<pre><code class="language-js">const contactForm = document.getElementById('contact');
contactForm.addEventListener('submit', function (event) {
  // Prevent default form submission behaviour
  event.preventDefault();

  console.log({ currentTarget: event.currentTarget });
});
</code></pre>
<p>Note how the <code>event.currentTarget</code> object contains our inputs (among other properties).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-simple-client"><a class="header" href="#a-simple-client">A Simple Client</a></h2>
<div style="text-align: right"> <i> Why use a framework? I'll just write my own in a weekend. <br> - Seconds before disaster </i> </div>
<h3 id="the-requirements"><a class="header" href="#the-requirements">The Requirements</a></h3>
<p>One day you sit around and dream about some sunshine as suddently the dreaded <em>Project Manager</em> approaches you and asks you to build a small task application.
The application should consist of a list showing the current tasks.
Additionally, a web form should allow the user to create a new task (which should then be displayed in the list of current tasks).</p>
<h3 id="the-initial-html"><a class="header" href="#the-initial-html">The Initial HTML</a></h3>
<p>You get to work and quickly come up with the initial document:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;Task List App&lt;/title&gt;
    &lt;!-- JavaScript will go here --&gt;
    &lt;script&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Task List&lt;/h1&gt;

    &lt;!-- Task List --&gt;
    &lt;ul id="taskList"&gt; &lt;/ul&gt;

    &lt;!-- Form to Add Tasks --&gt;
    &lt;h2&gt;Add a Task&lt;/h2&gt;
    &lt;form id="taskForm"&gt;
      &lt;label for="taskInput"&gt;Task:&lt;/label&gt;
      &lt;input type="text" id="taskInput" placeholder="Enter your task" /&gt;
      &lt;button type="submit"&gt;Add Task&lt;/button&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>You now have a heading, a list and a form.
However if you click the submit button, not a whole lot happens - this is because we haven't added any submit logic to the form yet.</p>
<h3 id="grabbing-the-items"><a class="header" href="#grabbing-the-items">Grabbing the Items</a></h3>
<p>Lets first grab the relevant items (remember that the code goes between the <code>&lt;script&gt;&lt;/script&gt;</code> tags).
This can be done using the <code>querySelector</code> method.
In this case we want to select by ID, so we use the <code>#</code> selector:</p>
<pre><code class="language-js">const taskList = document.querySelector('#taskList');
const taskForm = document.querySelector('#taskForm');
</code></pre>
<h3 id="adding-an-event-listener"><a class="header" href="#adding-an-event-listener">Adding an Event Listener</a></h3>
<p>Next, we need to add an event listener to <code>taskForm</code>.</p>
<p>The <code>event.currentTarget</code> will have the property <code>elements</code> which contains <code>taskInput</code> whose property <code>value</code> contains our input:</p>
<pre><code class="language-js">taskForm.addEventListener('submit', function (event) {
  // Prevent default form submission
  event.preventDefault();

  console.log({ inputValue: event.currentTarget.taskInput.value });
});
</code></pre>
<p>This should log the input.</p>
<p>Lets now store it in a variable and use <code>trim</code> to remove whitespace from both ends:</p>
<pre><code class="language-js">taskForm.addEventListener('submit', function (event) {
  // Prevent default form submission
  event.preventDefault();

  const task = event.currentTarget.taskInput.value.trim();
});
</code></pre>
<p>Finally we will use the <code>createElement</code> method to create a new <code>li</code> element and the <code>appendChild</code> method to add the newly created element to our task list:</p>
<pre><code class="language-js">taskForm.addEventListener('submit', function (event) {
  // Prevent default form submission
  event.preventDefault();

  const task = event.currentTarget.taskInput.value.trim();

  const li = document.createElement('li');
  li.textContent = task;
  taskList.appendChild(li);

  // Clear the input field
  event.currentTarget.taskInput.value = '';
});
</code></pre>
<p>When you now click the button, you will see that a new task will be added.</p>
<h3 id="adding-a-delete-button"><a class="header" href="#adding-a-delete-button">Adding a Delete Button</a></h3>
<p>As you complete the project, the <em>Project Manager</em> once again walks up to you and remembers that it might be a good idea to allow the user to delete tasks.
So now you need to add a delete button.</p>
<p>This means that whenever you create a new element, you need to add a delete button to it.
To accomplish this we first need to create the delete button:</p>
<pre><code class="language-js">const li = document.createElement('li');
li.textContent = task;

// New code starts here

const deleteButton = document.createElement('button');
deleteButton.textContent = 'Delete';
</code></pre>
<p>Then we need to attach an event listener to the delete button:</p>
<pre><code class="language-js">deleteButton.addEventListener('click', function () {
  taskList.removeChild(li);
});
</code></pre>
<p>Finally we need to add the delete button to the task item:</p>
<pre><code class="language-js">li.appendChild(deleteButton);
</code></pre>
<p>Quite a lot of work to just add a little delete button.
Additionally our code is now all over the place and not really reusable.
This doesn't seem like it will scale to a larger application.</p>
<p>To simplify our lives, we will use a library called <strong>React</strong>.
The idea behind React is to create declarative UIs with nicely separated components.
Basically we only define how the application should look like (hence the <em>declarative</em> aspect) and React takes care of the rest, such as determining the necessary DOM manipulations.
As you will see soon, this is an incredibly useful feature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-adding-spice-with-react"><a class="header" href="#chapter-5-adding-spice-with-react">Chapter 5: Adding Spice with React</a></h1>
<div style="text-align: right"> <i> This website needs to work on Internet Explorer 6.0 <br> - Famous last words </i> </div>
<p>In this chapter we will create a simple (website) client using React. This client will allow us to add and delete tasks. Each task will have a summary and a description.</p>
<p>Create a directory which will contain your project or just keep working with the <em>easy-opus</em> directory from the previous chapter (however you should delete it's contents). Of course, feel free to give your directory any <em>meaningful</em> name.</p>
<p>Let's begin.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="react-components"><a class="header" href="#react-components">React Components</a></h2>
<div style="text-align: right"> <i> Why do React components have great self-esteem? <br> Because they keep getting props. <br> - From "1000 programming dad-jokes" </i> </div>
<h3 id="why-react-components"><a class="header" href="#why-react-components">Why React Components?</a></h3>
<p>The idea behind React is that you can think about a page in terms of isolated <strong>components</strong>, where every component is an <em>independent and reusable piece of the UI</em>.</p>
<p>Consider a potential first version of our easy-opus app, which would need to display a bunch of tasks.</p>
<p>Every task could be its own component containing the task title, description and a button to delete the task (which are again components).
These tasks might then be grouped in a task list component, which in addition to the tasks, should have a button to add a new task.</p>
<p>Here is a simple mockup of the website structure:</p>
<p><img src="chapter5/images/components.png" alt="" /></p>
<p>Now comes the interesting part about React.
In terms of implementation, a component is just a <em>regular JavaScript function</em> that takes the <em>data it should render as input</em> and returns the <em>UI representation of the data as output</em>.</p>
<p>Here is an example of how the first Task component could look like:</p>
<pre><code class="language-jsx">function Task({ title, description }: { title: string, description: string }) {
  return (
    &lt;div&gt;
      &lt;p&gt;{title}&lt;/p&gt;
      &lt;p&gt;{description}&lt;/p&gt;
      &lt;button&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>This component takes a <code>title</code> and a <code>description</code> as input, and produces a <code>div</code> containing the <code>title</code>, <code>description</code> and a button as output.</p>
<blockquote>
<p>Note that the button currently doesn't do much.
We will change this later.</p>
</blockquote>
<p>To see components in action, let's actually create a simple React project.</p>
<h3 id="create-a-react-project"><a class="header" href="#create-a-react-project">Create a React Project</a></h3>
<p>To create a React project, we will use a tool called Vite, which provides various frontend tooling (including a development server and optimized builds).</p>
<p>First let's create a new <code>vite</code> project:</p>
<pre><code class="language-sh">pnpm create vite
</code></pre>
<p>You will be asked to select various options.
For the framework select <code>React</code> and for the variant you will select <code>TypeScript + SWC</code>.</p>
<p>After you've created the new project, the tool will even output the commands you should execute afterwards (quite helpful).</p>
<p>First, navigate to the newly created directory, where your project resides:</p>
<pre><code class="language-sh">cd easy-opus
</code></pre>
<p>You will see a couple of familiar files, including a <code>package.json</code> which - among other things - includes the dependencies of the project.
Let's install those dependencies:</p>
<pre><code class="language-sh">pnpm install
</code></pre>
<p>Finally, you can run a development server:</p>
<pre><code class="language-sh">pnpm dev
</code></pre>
<p>If you go to <code>http://localhost:5173</code> and observe the result, you will see a page with some demo content.
Let's replace this demo content with our own components!</p>
<p>First, you can remove <code>App.tsx</code>, <code>App.css</code>, <code>index.css</code> and the <code>assets/</code> folder.
We will not need these right now.</p>
<p>Now replace the code in <code>main.tsx</code> with the following very simple task list:</p>
<pre><code class="language-jsx">import ReactDOM from 'react-dom/client';

function App() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;Read the Next.js book&lt;/li&gt;
        &lt;li&gt;Write a website&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

ReactDOM.createRoot(document.getElementById('root')!).render(&lt;App /&gt;);
</code></pre>
<p>Save the file and again navigate to <code>http://localhost:5173</code>.
You will now see our component rendered.
This is actually one of the main features of the development server - it will automatically recreate the page when you edit your code.</p>
<p>If you've paid attention so far, there should a big question mark in your head now: Why are we allowed to write HTML in our JavaScript?</p>
<p>The answer is simple: The syntax is not actually HTML (queue ominous music here).</p>
<h3 id="introducing-jsx"><a class="header" href="#introducing-jsx">Introducing JSX</a></h3>
<p>Consider our <code>App</code> function:</p>
<pre><code class="language-jsx">function App() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;Read the Next.js book&lt;/li&gt;
        &lt;li&gt;Write a website&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>While this might look like HTML, it is important to emphasize that this is <em>emphatically not</em> HTML.
Instead this syntax is JSX, which is a <em>syntax extension</em> to JavaScript that can be transpiled to <em>normal</em> JavaScript.</p>
<p>To be precise, the JSX will be transpiled to calls to the <code>React.createElement</code> function which will return regular JavaScript objects.
The root object will be dynamically added to the DOM using this line of code:</p>
<pre><code class="language-jsx">ReactDOM.createRoot(document.getElementById('root')!).render(&lt;App /&gt;);
</code></pre>
<p>The difference between JSX and HTML is not just a nitpick.
For example, in JSX we can (and will) use and nest our own components exactly like we would use and nest HTML elements.</p>
<p>Here is an example of a <code>TaskList</code> component rendered inside the <code>App</code> component:</p>
<pre><code class="language-jsx">import ReactDOM from 'react-dom/client';

function App() {
  return &lt;TaskList /&gt;;
}

function TaskList() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;Read the Next.js book&lt;/li&gt;
        &lt;li&gt;Write a website&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

ReactDOM.createRoot(document.getElementById('root')!).render(&lt;App /&gt;);
</code></pre>
<blockquote>
<p>While possible, it's much more complicated (and relatively rare) to add your own custom tags in HTML.</p>
</blockquote>
<p>Additionally, you can include JavaScript expressions in JSX by wrapping them in curly braces <code>{}</code>:</p>
<pre><code class="language-jsx">const x = 2;
const y = 2;

function Example() {
  return &lt;p&gt;{x + y}&lt;/p&gt;;
}
</code></pre>
<h3 id="add-props-to-a-react-component"><a class="header" href="#add-props-to-a-react-component">Add Props to a React Component</a></h3>
<p>JSX is great, but our current <code>TaskList</code> function is not.
The main problem is that the data it represents is hardcoded into the component.</p>
<p>Let us fix that by passing properties (<code>props</code>) into the component.
This is simply a JavaScript object containing the data the component should render.
In our case we will simply pass an array of strings named <code>tasks</code> containing our - well - tasks.
We can then use <code>map</code> to create a list item <code>li</code> for each element of that array:</p>
<pre><code class="language-jsx">type TaskListProps = {
  tasks: string[],
};

function TaskList(props: TaskListProps) {
  return (
    &lt;ul&gt;
      {props.tasks.map((task) =&gt; (
        &lt;li&gt;{task}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<p>This is already not too bad, but of course we want to take advantage of the latest and greatest JavaScript syntax there is.
Writing <code>props.tasks</code> is annoying.
This will become even more annoying when we have a lot of props.</p>
<p>We can use object destructuring to alleviate this:</p>
<pre><code class="language-jsx">function TaskList({ tasks }: TaskListProps) {
  return (
    &lt;ul&gt;
      {tasks.map((item) =&gt; (
        &lt;li&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<blockquote>
<p>You can hopefully see how all the concepts from chapters 1 and 2 are coming together quite nicely.</p>
</blockquote>
<p>Excellent! We can use the new component like this:</p>
<pre><code class="language-jsx">function App() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;TaskList items={['Read the Next.js book', 'Write a website']} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>Quite nice.
Note that there is a problem with the current implementation of our component.
You can see this by opening your browser console.
An error "Warning: Each child in a list should have a unique 'key' prop." will appear.</p>
<p>The reason for that is that React needs a way to identify which items in a list have changed or have been added or removed.
It does that by looking at the keys of the items.
These basically give the elements a stable identity.</p>
<p>Let's add IDs to the tasks (we will need them anyway later) and use the task IDs as keys for the component:</p>
<pre><code class="language-jsx">function App() {
  const tasks = [
    {
      id: 'TSK-1',
      title: 'Read the Next.js book',
    },
    {
      id: 'TSK-2',
      title: 'Write a website',
    },
  ];

  return (
    &lt;div&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;TaskList tasks={tasks} /&gt;
    &lt;/div&gt;
  );
}

function TaskList({ tasks }: TaskListProps) {
  return (
    &lt;ul&gt;
      {tasks.map((item) =&gt; (
        &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<p>There is one final improvement we can make:
The <code>div</code> element in <code>App</code> is pretty useless, since it only serves the purpose of wrapping the <code>h1</code> and <code>TaskList</code> (since a component can only return a single JSX element).
Luckily, there is a special component called a React <strong>fragment</strong> which allows us to wrap multiple JSX elements without showing up in the DOM later.</p>
<p>You can create a fragment using the <code>&lt;&gt;&lt;/&gt;</code> syntax:</p>
<pre><code class="language-jsx">function App() {
  const tasks = [
    {
      id: 'TSK-1',
      title: 'Read the Next.js book',
    },
    {
      id: 'TSK-2',
      title: 'Write a website',
    },
  ];

  return (
    &lt;&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;TaskList tasks={tasks} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="improve-project-structure"><a class="header" href="#improve-project-structure">Improve Project Structure</a></h3>
<p>We should note that it is common practice to put components into separate files (unless two components are heavily related to each other).</p>
<p>In this example, we might put the <code>TaskList</code> component into a file <code>task-list.tsx</code>:</p>
<pre><code class="language-jsx">type Task = {
  id: string,
  title: string,
};

type TaskListProps = {
  tasks: Task[],
};

export function TaskList({ tasks }: TaskListProps) {
  return (
    &lt;ul&gt;
      {tasks.map((item) =&gt; (
        &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<p>Note that we have to <code>export</code> the <code>TaskList</code> component so that we can <code>import</code> it in our <code>index.tsx</code> file:</p>
<pre><code class="language-jsx">import { TaskList } from 'task-list';

function App() {
  const tasks = [
    {
      id: 'TSK-1',
      title: 'Read the Next.js book',
    },
    {
      id: 'TSK-2',
      title: 'Write a website',
    },
  ];

  return (
    &lt;div&gt;
      &lt;h1&gt;Tasks&lt;/h1&gt;
      &lt;TaskList tasks={tasks} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.createRoot(document.getElementById('root')!).render(&lt;App /&gt;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="react-state"><a class="header" href="#react-state">React State</a></h2>
<div style="text-align: right"> <i> Why was the useState hook feeling nostalgic? <br>
Because every time it was called, it brought back memories! <br> - From "1000 programming dad-jokes" </i> </div>
<h3 id="why-state"><a class="header" href="#why-state">Why State?</a></h3>
<p>In the previous section we learned how to render components.
However, these components are completely "static" right now.
But in reality, you often need to have "dynamic" components that change based on some action.</p>
<p>For example, clicking a button might update a counter and typing into a form might update the input field.
This means that components need to be able to "remember" things (like the current counter or the current input field value).</p>
<p>To "remember" something, you can use state, which serves as a sort of memory for your component.</p>
<h3 id="a-simple-example"><a class="header" href="#a-simple-example">A Simple Example</a></h3>
<p>Let's create a simple counter component.
This component will have a button that increments a value:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          setCount(count + 1);
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Try clicking the "Increment" button - it will increment the count by 1 each time you click it.</p>
<p>This example is simple, but it still shows exactly how to use state in React.</p>
<p>State is provided by the <code>useState</code> hook (a hook is basically just a special function).</p>
<p>This hook returns an array with two elements - a <strong>state variable</strong> and a <strong>state setter function</strong>.
The state variable (<code>count</code> in this case) will be the value that you want to remember.
The state setter function (<code>setCount</code> in this case) can be used to update the state variable.
The <code>useState</code> hook takes a single argument - the initial value of the state variable (which is <code>0</code> in this case).</p>
<p>Note that we make use of array destructuring here (which you should remember from chapter 1):</p>
<pre><code class="language-ts">const [count, setCount] = React.useState(0);
</code></pre>
<p>Alternatively we could have written:</p>
<pre><code class="language-ts">const countState = React.useState(0);
const count = countState[0];
const setCount = countState[1];
</code></pre>
<p>Please don't do that though - it will result in confusion since it's very unconventional to manually destructure the value returned from a hook.</p>
<h3 id="state-vs-regular-variables"><a class="header" href="#state-vs-regular-variables">State vs Regular Variables</a></h3>
<p>You should have a big question in the back of your head right now.
<em>Why do we need to go through all this pain?</em>
<em>Why not just use a regular variable?</em></p>
<p>After all, this is how we always remembered values before.
We simply assigned them to variables.</p>
<p>Let's have a look at why this doesn't work with React:</p>
<pre><code class="language-jsx">export default function Counter() {
  let count = 0;

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          count += 1;
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Try clicking the button know - nothing will happen.
But why?</p>
<p>The problem lies in the fact that, while we do update the local variable, React doesn't actually rerender the component to show the change.
You can verify this by adding a few <code>console.logs</code>:</p>
<pre><code class="language-jsx">export default function Counter() {
  let count = 0;

  console.log('Rendered counter component');

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          count += 1;
          console.log(`New value of count is ${count}`);
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>If you open the component and click the button a few times, you will see the following logs:</p>
<pre><code>Rendered counter component
New value of count is 1
New value of count is 2
New value of count is 3
</code></pre>
<p>So the local variable is indeed updated - but this doesn't rerender the component.
We begin to see the purpose of the <code>useState</code> hook - to define a state whose <em>updates will trigger a rerender</em>.</p>
<p>This explanation should have immediately raised another question.
What happens if we skip the state setter function and just set the state variable directly?</p>
<pre><code class="language-jsx">export default function Counter() {
  let [count, setCount] = React.useState(0);

  console.log('Rendered counter component');

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          count += 1;
          console.log(`New value of count is ${count}`);
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>If you click the button a few times, you will see the exact same behaviour as with the previous example:</p>
<pre><code>Rendered counter component
New value of count is 1
New value of count is 2
New value of count is 3
</code></pre>
<p>Therefore if you need to update the UI of your component, you can't use local variables and you can't update the state variables directly.
You need to use the state setter function to not only update the state variable, but also to rerender the component.</p>
<p>Let's verify that using the state setter function does what we expect:</p>
<pre><code class="language-jsx">export default function Counter() {
  let [count, setCount] = React.useState(0);

  console.log(`Rendered counter component with count=${count}`);

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          setCount(count + 1);
          console.log(`New value of count is ${count}`);
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>We will now see that the component rerenders if we click the "Increment" button:</p>
<pre><code>Rendered counter component with count=0
New value of count is 0
Rendered counter component with count=1
</code></pre>
<p>Note that the value of <code>count</code> only changes on the <em>next render</em>.
Here is what happens:</p>
<p>The component renders for the first time.
Because the initial value of <code>count</code> is set to <code>0</code>, it will render with <code>count</code> being equal to <code>0</code>.</p>
<p>You click the button and <code>setCount</code> is called with <code>count + 1</code> (which will be <code>0 + 1</code>, i.e. <code>1</code>).
React rerenders the component while remembering that the new <code>count</code> should be <code>1</code>.</p>
<p>The component renders for the second time.
Because React remembered that <code>count</code> was set to <code>1</code>, the component will render with <code>count</code> set to <code>1</code>.</p>
<h3 id="using-state-with-a-form"><a class="header" href="#using-state-with-a-form">Using State with a Form</a></h3>
<p>Let us return to our task management application and add the form for creating a new task.
Enter the <code>task-list.tsx</code> file and import React at the top:</p>
<pre><code class="language-js">import * as React from 'react';
</code></pre>
<p>Next we add the form containing inputs for the ID and the title, as well as an "Add task" button below the task list:</p>
<pre><code class="language-jsx">export function TaskList({ tasks }: TaskListProps) {
  return (
    &lt;&gt;
      &lt;ul&gt;
        {tasks.map((item) =&gt; (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;form&gt;
        &lt;label htmlFor="taskId"&gt;Task ID:&lt;/label&gt;
        &lt;input type="text" id="taskId" /&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" /&gt;
        &lt;br /&gt;
        &lt;button type="submit"&gt;Add task&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Now we need to create a <code>handleSubmit</code> function, which will just log something to the console for now.
Remember from chapter 4 that we need to call the <code>preventDefault</code> function to prevent the default behaviour of a form submission (which includes a page refresh):</p>
<pre><code class="language-js">function handleSubmit(event) {
  event.preventDefault();
  const taskId = event.currentTarget.taskId.value.trim();
  const title = event.currentTarget.title.value.trim();
  console.log(`Submitted ${taskId}, ${title}`);
}
</code></pre>
<p>Next we need to make sure that the <code>handleSubmit</code> function is called when the button is clicked.
To accomplish that, we set the <code>onSubmit</code> property of the form to the <code>handleSubmit</code> function:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit}&gt;{/*Additional JSX here*/}&lt;/form&gt;
</code></pre>
<p>If you click the button, you should now see the title logged to the console.</p>
<p>Again we use the <code>useState</code> hook:</p>
<pre><code class="language-js">const [tasks, setTasks] = React.useState&lt;Task[]&gt;([]);
</code></pre>
<p>We now want to add the task to the end when the form is submitted:</p>
<pre><code class="language-js">function handleSubmit(event) {
  event.preventDefault();
  const taskId = event.currentTarget.taskId.value.trim();
  const title = event.currentTarget.title.value.trim();
  setTasks([
    ...previousTasks,
    {
      id: taskId,
      title,
    },
  ]);
}
</code></pre>
<p>This is what the full code looks like:</p>
<pre><code class="language-jsx">import * as React from "react";

type Task = {
  id: string;
  title: string;
};

export default function TaskList() {
  const [tasks, setTasks] = React.useState&lt;Task[]&gt;([]);

  function handleSubmit(event) {
    event.preventDefault();
    const taskId = event.currentTarget.taskId.value.trim();
    const title = event.currentTarget.title.value.trim();
    setTasks([
      ...tasks,
      {
        id: taskId,
        title,
      },
    ]);
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {tasks.map((item) =&gt; (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label htmlFor="taskId"&gt;Task ID:&lt;/label&gt;
        &lt;input type="text" id="taskId" /&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" /&gt;
        &lt;br /&gt;
        &lt;button type="submit"&gt;Add task&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}

</code></pre>
<p>Try clicking the button - a new task should appear.</p>
<h3 id="when-to-use-state"><a class="header" href="#when-to-use-state">When to use State</a></h3>
<p>There is a common theme regarding state in React - a lot of beginners <em>heavily overuse</em> it.
This is usually because they misunderstand the purpose of state and what it actually does.</p>
<p>Before we give specific examples of when to and when not to use state, we want to reiterate two things we already discussed:</p>
<p>First, state should only be used if your component needs to remember something.</p>
<p>Second, state updates are expensive, because a state update will rerender your component.</p>
<p>The corollary to these two things is that <strong>you should only use state when you absolutely need it</strong>, i.e. <strong>you should keep state to a minimum</strong>.</p>
<p>First, you should never ever store static data in state.
For example, this is completely unnecessary:</p>
<pre><code class="language-jsx">export default function BadTaskList() {
  const tasks = React.useState([
    {
      id: 'TSK-1',
      title: 'Read the Next.js book',
    },
    {
      id: 'TSK-2',
      title: 'Write a website',
    },
  ]);

  return (
    &lt;ul&gt;
      {tasks.map((task) =&gt; (
        &lt;li key={task.id}&gt;{task.summary}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<p>Just use a local variable instead:</p>
<pre><code class="language-jsx">export default function GoodTaskList() {
  const tasks = [
    {
      id: 'TSK-1',
      title: 'Read the Next.js book',
    },
    {
      id: 'TSK-2',
      title: 'Write a website',
    },
  ];

  return (
    &lt;ul&gt;
      {tasks.map((task) =&gt; (
        &lt;li key={task.id}&gt;{task.summary}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
<blockquote>
<p>Of course, in this particular example, the <code>tasks</code> variable should really be passed as a prop to the component.
We just want to show you when to and when not to use state here.</p>
</blockquote>
<p>Second, you should never store data in state that you can derive from other state (or props).
For example, this is a bad idea:</p>
<pre><code class="language-jsx">import * as React from 'react';

type Task = {
  id: string;
  title: string;
};

export default function TaskList() {
  const [tasks, setTasks] = React.useState&lt;Task[]&gt;([]);
  const [numTasks, setNumTasks] = React.useState(0);

  function handleSubmit(event) {
    event.preventDefault();
    const taskId = event.currentTarget.taskId.value.trim();
    const title = event.currentTarget.title.value.trim();
    setTasks([
      ...tasks,
      {
        id: taskId,
        title,
      },
    ]);
    setNumTasks(numTasks + 1);
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {tasks.map((item) =&gt; (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;You have {numTasks} tasks&lt;/p&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label htmlFor="taskId"&gt;Task ID:&lt;/label&gt;
        &lt;input type="text" id="taskId" /&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" /&gt;
        &lt;br /&gt;
        &lt;button type="submit"&gt;Add task&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>In this example, you really do need the <code>tasks</code> state (since you need to remember the tasks that have been added so far).
However, you really don't need the <code>numTasks</code> state, because you can derive it from the value of the <code>tasks</code> state.</p>
<p>After all, <code>numTasks</code> is simply equal to <code>tasks.length</code>.</p>
<p>Here is how we can fix the component:</p>
<pre><code class="language-jsx">import * as React from "react";

type Task = {
  id: string;
  title: string;
};

export default function TaskList() {
  const [tasks, setTasks] = React.useState&lt;Task[]&gt;([]);

  function handleSubmit(event) {
    event.preventDefault();
    const taskId = event.currentTarget.taskId.value.trim();
    const title = event.currentTarget.title.value.trim();
    setTasks([
      ...tasks,
      {
        id: taskId,
        title,
      },
    ]);
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {tasks.map((item) =&gt; (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;You have {tasks.length} tasks&lt;/p&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label htmlFor="taskId"&gt;Task ID:&lt;/label&gt;
        &lt;input type="text" id="taskId" /&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" /&gt;
        &lt;br /&gt;
        &lt;button type="submit"&gt;Add task&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="react-effects"><a class="header" href="#react-effects">React Effects</a></h2>
<div style="text-align: right"> <i> Why can't React effects keep a secret? <br> Because as soon as something changes, they just have to run and tell everyone! <br> - From "1000 programming dad-jokes" </i> </div>
<h3 id="why-effects"><a class="header" href="#why-effects">Why Effects?</a></h3>
<p><strong>Effects</strong> are useful if you want to synchronize React with some <em>external system</em> (like a server).</p>
<p>Consider a component which, upon rendering, needs to fetch a task title and display it to the user.
While your first instinct might be to use an event handler together with state, this is not possible.
After all, there is no real user event here.
Instead we need to execute something <em>because the component is rendering</em>.</p>
<p>This is where effects come in handy.</p>
<h3 id="the-useeffect-hook"><a class="header" href="#the-useeffect-hook">The <code>useEffect</code> Hook</a></h3>
<p>Here is the simplest possible example for a <code>useEffect</code> hook.
This hook takes a function which is executed when the component is first rendered or rerendered:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleComponent() {
  React.useEffect(() =&gt; {
    console.log('Effect runs');
  });

  return &lt;div&gt;Hello, World!&lt;/div&gt;;
}
</code></pre>
<p>If you display this component on a page, here is what you will see in the console:</p>
<pre><code>Effect runs
</code></pre>
<p>Let's add some state to the component so that we can see what happens when the component rerenders:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleCounter() {
  const [count, setCount] = React.useState(0);

  React.useEffect(() =&gt; {
    console.log(`Effect runs (currently count=${count})`);
  });

  return (
    &lt;&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          setCount(count + 1);
        }}
      &gt;
        Increment
      &lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Open the page containing the component again and you will see the following log:</p>
<pre><code>Effect runs (currently count=0)
</code></pre>
<p>Now click the button a few times - you will see that on each rerender the effect is executed:</p>
<pre><code>Effect runs (currently count=1)
Effect runs (currently count=2)
Effect runs (currently count=3)
Effect runs (currently count=4)
</code></pre>
<p>Additionally we can return a cleanup function, which will run when the component is destroyed (<em>unmounted</em>), and before every <em>rerun</em> of the useEffect. We will examine when exactly an useEffect reruns in the <a href="chapter5/03-react-effects.html#the-dependency-array">next section</a>.
Consider this example:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleComponent() {
  React.useEffect(() =&gt; {
    console.log('Effect runs');

    return () =&gt; {
      console.log('Component destroyed');
    };
  });

  return &lt;div&gt;Hello, World!&lt;/div&gt;;
}
</code></pre>
<p>If the component is destroyed (for example, because you refresh the page or navigate away from the current page), you will see the following log:</p>
<pre><code>Component destroyed
</code></pre>
<p>Usually you would use the cleanup function to do some cleanup (<em>no way</em>).
For example, if you've connected to an external system, here is were you would disconnect.</p>
<h3 id="the-dependency-array"><a class="header" href="#the-dependency-array">The Dependency Array</a></h3>
<p>The <code>useEffect</code> hook also takes a second argument - a <strong>dependency array</strong>.
This allows you to specify that the effect should run only if a particular value changes.</p>
<p>Consider this (slightly constructed) example:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Counter() {
  const [firstCount, setFirstCount] = React.useState(0);
  const [secondCount, setSecondCount] = React.useState(0);

  React.useEffect(() =&gt; {
    console.log(`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`);
  }, [firstCount]);

  return (
    &lt;div&gt;
      &lt;p&gt;{`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`}&lt;/p&gt;
      &lt;button onClick={() =&gt; setFirstCount(firstCount + 1)}&gt;Increment first count&lt;/button&gt;
      &lt;button onClick={() =&gt; setSecondCount(secondCount + 1)}&gt;Increment second count&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>As usual, the effect runs on the initial render:</p>
<pre><code>Current counts: firstCount=0, secondCount=0
</code></pre>
<p>If you click the "Increment first count" button, you will see that the effect runs again:</p>
<pre><code>Current counts: firstCount=1, secondCount=0
Current counts: firstCount=2, secondCount=0
Current counts: firstCount=3, secondCount=0
Current counts: firstCount=4, secondCount=0
</code></pre>
<p>However, if you click the "Increment second count" button, you will see that the effect doesn't run (and nothing is logged to the console).</p>
<p>This is because <code>firstCount</code> is in the dependency array, but <code>secondCount</code> isn't.
Therefore, an update to <code>firstCount</code> (via the <code>setFirstCount</code> setter function) will trigger the effect.
But an update to <code>secondCount</code> (via the <code>setSecondCount</code> setter function) won't.</p>
<p>If you want to trigger the effect when <code>secondCount</code> is updated, you will need to add <code>secondCount</code> to the dependency array:</p>
<pre><code class="language-js">React.useEffect(() =&gt; {
  console.log(`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`);
}, [firstCount, secondCount]);
</code></pre>
<p>Note that if the dependency array is empty, the effect will run only once - when the component is first rendered.
This directly follows from the explanation above - an empty dependency array contains no values that would trigger the effect again.</p>
<p>Consider this example:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Counter() {
  const [firstCount, setFirstCount] = React.useState(0);
  const [secondCount, setSecondCount] = React.useState(0);

  React.useEffect(() =&gt; {
    console.log(`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`);
  }, []);

  return (
    &lt;div&gt;
      &lt;p&gt;{`Current counts: firstCount=${firstCount}, secondCount=${secondCount}`}&lt;/p&gt;
      &lt;button onClick={() =&gt; setFirstCount(firstCount + 1)}&gt;Increment first count&lt;/button&gt;
      &lt;button onClick={() =&gt; setSecondCount(secondCount + 1)}&gt;Increment second count&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>The effect will run on the initial render:</p>
<pre><code>Current counts: firstCount=0, secondCount=0
</code></pre>
<p>But it won't run again, no matter how often you click the buttons.</p>
<p>Here is a bonus tip regarding effects: <strong>You should always explicitly specify the dependency array</strong>.</p>
<p>Remember, if you don't specify the dependency array, the effect will rerun on every render, which is rarely the desired behaviour.
In fact this can result in catastrophic behaviour, like in the following example:</p>
<pre><code class="language-jsx">export default function ExampleComponent() {
  const [count, setCount] = React.useState(0);

  React.useEffect(() =&gt; {
    setCount(count + 1);
  });

  return (
    &lt;div&gt;
      &lt;h1&gt;Example Component&lt;/h1&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>If you run this, you will see that the counter just keeps incrementing in an infinite loop.
This is because, the effect calls <code>setCount</code>, which will trigger a rerender, which will trigger the effect again, which will call <code>setCount</code> etc.</p>
<p>React is actually smart enough to realize the problem and will log the following warning to the console:</p>
<pre><code>Maximum update depth exceeded.
This can happen when a component calls setState inside useEffect,
but useEffect either doesn't have a dependency array,
or one of the dependencies changes on every render.
</code></pre>
<h3 id="using-fetch-and-useeffect-together"><a class="header" href="#using-fetch-and-useeffect-together">Using <code>fetch</code> and <code>useEffect</code> Together</a></h3>
<p>One of the most common usages of <code>useEffect</code> is to synchronize your component with an external API.</p>
<p>Let's return to our motivation for this section, where we wanted to fetch a task title and display it to the user.
Since the task title is held by the API (i.e. an external system), this seems like a perfect use case for an effect:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function ExampleTask() {
  const [title, setTitle] = React.useState('');

  React.useEffect(() =&gt; {
    fetch('https://jsonplaceholder.typicode.com/todos/1')
      .then((response) =&gt; {
        if (!response.ok) {
          throw new Error(`Response status was ${response.status}`);
        }
        return response.json();
      })
      .then((json) =&gt; setTitle(json.title))
      .catch((error) =&gt; console.log(error));
  }, []);

  return &lt;p&gt;{title}&lt;/p&gt;;
}
</code></pre>
<p>This code should be pretty clear if you understand the <code>fetch</code> function and the <code>useEffect</code> hook.</p>
<p>Our effect fetches a the task from the API and then sets a state called <code>title</code> after the fetch is completed.
Because we only want this to happen on the initial component render, we specify an empty dependency array.</p>
<p>Note that we don't have a cleanup function in our effect - normally we would abort the request here.
However this is out of scope for this introductory book.</p>
<h3 id="you-rarely-need-an-effect"><a class="header" href="#you-rarely-need-an-effect">You Rarely Need an Effect</a></h3>
<p>Just like with state, beginners tend to heavily <em>overuse</em> effects.</p>
<p>Remember: <strong>Effects are only needed if you need to synchronize with an external system</strong>.
You should not need an effect in any other scenario.</p>
<p>Effects are definitely not needed if you need update some state based on props and other state.
Something like this is completely unneccessary:</p>
<pre><code class="language-jsx">import * as React from 'react';

type Task = {
  id: string;
  title: string;
};

export default function TaskList() {
  const [tasks, setTasks] = React.useState&lt;Task[]&gt;([]);
  const [numTasks, setNumTasks] = React.useState(0);

  // This is a really bad idea
  React.useEffect(() =&gt; {
    setNumTasks(tasks + 1);
  }, [tasks])

  function handleSubmit(event) {
    event.preventDefault();
    const taskId = event.currentTarget.taskId.value.trim();
    const title = event.currentTarget.title.value.trim();
    setTasks([
      ...tasks,
      {
        id: taskId,
        title,
      },
    ]);
  }

  return (
    &lt;&gt;
      &lt;ul&gt;
        {tasks.map((item) =&gt; (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;You have {numTasks} tasks&lt;/p&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label htmlFor="taskId"&gt;Task ID:&lt;/label&gt;
        &lt;input type="text" id="taskId" /&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" /&gt;
        &lt;br /&gt;
        &lt;button type="submit"&gt;Add task&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Instead you should simply calculate the depending value during rendering (like we discussed in the previous section).</p>
<p>Similarly, you don't need effects when you want to reset or adjust some state based on a prop change.</p>
<blockquote>
<p>In fact, these days some guidelines recommend to not use an effect even for fetching data.
This is because if you fetch data inside an effect in more complex scenarios, you need to think about cleanup functions, race conditions etc.
This why most frameworks that build on top of React (like Next.js) usually provide better data fetching mechanisms than fetching data in effects.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-moving-to-the-server-with-nextjs"><a class="header" href="#chapter-6-moving-to-the-server-with-nextjs">Chapter 6: Moving to the Server with Next.js</a></h1>
<p>Now that you have a rough overview of React, we want to move to the server.
Next.js is a React-based framework for building full-stack applications.</p>
<p>You will need to use at least version 13 of Next.js, because that introduced the App Router which is built on top of React Server Components.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<h3 id="creating-a-nextjs-project"><a class="header" href="#creating-a-nextjs-project">Creating a Next.js Project</a></h3>
<p>Run the following command to create a new Next.js project:</p>
<pre><code class="language-sh">pnpm create next-app
</code></pre>
<p>Give your project a name (like <code>easy-opus</code>) and select the following options:</p>
<ul>
<li>we want to use TypeScript</li>
<li>we want to use ESLint</li>
<li>we want to use Tailwind CSS</li>
<li>we want to use the <code>src/</code> directory</li>
<li>we want to use the App Router</li>
<li>we don't want to customize the defalt import alias</li>
</ul>
<p>Next, navigate to the <code>easy-opus</code> directory and run:</p>
<pre><code class="language-sh">pnpm dev
</code></pre>
<blockquote>
<p>Note that <code>pnpm create next-app</code> automatically runs <code>pnpm install</code>, so you don't need to worry about that.</p>
</blockquote>
<p>If you go to <code>http://localhost:3000</code>, you will see the default home page.
Let's simplify it a bit for the following sections.</p>
<h3 id="simplifying-the-default-project"><a class="header" href="#simplifying-the-default-project">Simplifying the Default Project</a></h3>
<p>Enter the <code>src</code> directory (<code>easy-opus/src</code>).</p>
<p>First, remove the <code>globals.css</code> file (styles will be the topic of the next chapter).</p>
<p>Next, replace the code in <code>page.tsx</code> with this:</p>
<pre><code class="language-tsx">export default function Home() {
  return &lt;h1&gt;Welcome&lt;/h1&gt;;
}
</code></pre>
<p>Finally, replace the code in <code>layout.tsx</code> with this:</p>
<pre><code class="language-tsx">export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>Go to <code>http://localhost:3000</code> again and observe the simplified home page.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pages-and-layouts"><a class="header" href="#pages-and-layouts">Pages and Layouts</a></h2>
<h3 id="pages"><a class="header" href="#pages">Pages</a></h3>
<p>Next.js uses <strong>file-based routing</strong>.
Folders are used to define routes and each folder represents a route segment (which maps to a URL segment).
You can define nested routes by nesting folder inside each other.</p>
<p>For example the folder <code>about</code> would represents the route <code>/about</code> (which would be mapped to the URL <code>/about</code>).
If you would have a folder <code>about</code> inside a folder <code>company</code> this would represent the route <code>/company/about</code> (which would be mapped to the URL <code>/company/about</code>).</p>
<p>Note that all of this is relative to our root directory (which in our application is <code>src/app</code>).
This means that the route <code>/about</code> would actually be located at <code>src/app/about</code> and the route <code>/company/about</code> would actually be located at <code>src/app/company/about</code>.</p>
<p>Routes can have special files, which are used to actually define the route.
For example, the special <code>page</code> file (e.g. <code>page.js</code>, <code>page.jsx</code> or <code>page.tsx</code>) is used to display UI for the given route.
For this to work, the <code>page</code> file needs to <code>default</code> export a React component.</p>
<p>You already have one of these files - namely <code>src/app/page.tsx</code> which defines the UI to be displayed for the route <code>/</code>.</p>
<p>Let's create another page.
Add a new directory <code>about</code> in <code>src/app</code> and create the following file <code>src/app/about/page.tsx</code>:</p>
<pre><code class="language-jsx">export default function About() {
  return &lt;h1&gt;About&lt;/h1&gt;;
}
</code></pre>
<p>Go to <code>http://localhost:3000/about</code> and you will see the new page.</p>
<blockquote>
<p>From now on we will stop prefixing everything with <code>src/app</code> and simply talk assume that you are always in <code>src/app</code>.
For example, if we tell you to create a file <code>task/route.ts</code> you should actually create the file at <code>src/app/task/route.ts</code>.</p>
</blockquote>
<h3 id="layouts"><a class="header" href="#layouts">Layouts</a></h3>
<p>A page is a UI that is unique to a route.
You can also define a UI that is shared between multiple pages.
This is called a <strong>layout</strong>.</p>
<p>You define a layout be <code>default</code> exporting a React component from a <code>layout</code> file (e.g. <code>layout.tsx</code>).
The component should accept a <code>children</code> prop that will be populated with a child layout or a child page.</p>
<p>Let's go to <code>layout.ts</code> in the root directory, which currently looks like this:</p>
<pre><code class="language-jsx">export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>Let's change it to:</p>
<pre><code class="language-jsx">export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        &lt;header&gt;My header&lt;/header&gt;
        {children}
      &lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>Now the header <code>"My header"</code> will appear on every page (i.e. both on <code>/</code> and <code>/about</code>).</p>
<blockquote>
<p>After you verified this, you can remove the header again.</p>
</blockquote>
<p>Note that the top-most layout (which must always be present) is called the <strong>root layout</strong> and will be shared across all pages.
The root layout must contain <code>html</code> and <code>body</code> tags.</p>
<p>The root layout is also where you define metadata.
This can be done by exporting a <code>metadata</code> object:</p>
<pre><code class="language-ts">export const metadata: Metadata = {
  title: 'Easy Opus',
  description: 'A task management application',
};
</code></pre>
<h3 id="navigating-with-the-link-component"><a class="header" href="#navigating-with-the-link-component">Navigating with the <code>&lt;Link&gt;</code> Component</a></h3>
<p>You can add navigation between routes by using the <code>&lt;Link&gt;</code> component.</p>
<p>This is a component built on top of the HTML <code>&lt;a&gt;</code> tag that you already know.
However, this component does some additional things, like prefetching (i.e. preloading routes in the background).
It also changes the way navigation works (we will talk more about this in the next sections).</p>
<p>Here is how you could link the About page from the home page:</p>
<pre><code class="language-jsx">import Link from 'next/link';

export default function Home() {
  return (
    &lt;&gt;
      &lt;h1&gt;Welcome&lt;/h1&gt;
      Go to the &lt;Link href="/about"&gt;About&lt;/Link&gt; page
    &lt;/&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="more-on-routes"><a class="header" href="#more-on-routes">More on Routes</a></h2>
<h3 id="dynamic-routes"><a class="header" href="#dynamic-routes">Dynamic Routes</a></h3>
<p>You can use <strong>dynamic routes</strong> when you don't know segment names ahead of time.
Let's say you want to add a route that displays a task with a certain ID at <code>/task/$ID</code>.
For example, you might wish to display a task with the ID <code>1</code> at <code>/task/1</code> and a task with the ID <code>2</code> at <code>/task/2</code>.</p>
<p>Of course, since tasks are added and deleted by the user, you can't know all of the IDs beforehand.
This where dynamic routes come in.</p>
<p>Create a new file <code>task/[id]/page.tsx</code>:</p>
<pre><code class="language-jsx">export default function Task({ params }: { params: { id: string } }) {
  return &lt;p&gt;This is a task with ID {params.id}&lt;/p&gt;;
}
</code></pre>
<p>If you go to <code>http://localhost:3000/task/1</code>, you should see the following text:</p>
<pre><code>This is a task with ID 1
</code></pre>
<p>However, if you go to <code>http://localhost:3000/task/56789</code>, you will see:</p>
<pre><code>This is a task with ID 56789
</code></pre>
<p>Note that the <code>[id]</code> notation will only match a single segment.
This means for example <code>http://localhost:3000/task/1/status</code> will not be matched by <code>task/[id]</code> and you will see a <code>404</code>.</p>
<p>If you want to change this, you can use catch-all segments with <code>[...id]</code> and optional catch-all segments with <code>[[...id]]</code>.</p>
<h3 id="route-handlers"><a class="header" href="#route-handlers">Route Handlers</a></h3>
<p>Route handlers basically allow you to create API routes.
Route handlers are defined by <code>route</code> files.</p>
<p>Let's create a new file <code>api/task/route.ts</code> and add a simple example route handler:</p>
<pre><code class="language-ts">import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({
    taskId: 1,
  });
}
</code></pre>
<p>Try accessing the route:</p>
<pre><code>$ curl localhost:3000/api/task
{"taskId":1}
</code></pre>
<p>You can access the request by passing a <code>request</code> argument to the function:</p>
<pre><code class="language-ts">import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  console.log({ request });

  return NextResponse.json({
    taskId: 1,
  });
}
</code></pre>
<p>If you look at your console, you will see that the request object is logged.</p>
<p>You can use the <code>request</code> object to access the various request properties.
For example, you could retrieve the cookies of the current request using <code>request.cookies</code>.
This is a special <code>RequestCookies</code> object that exposes methods that you can use to retrieve cookies:</p>
<pre><code class="language-ts">import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const cookies = request.cookies;

  const allCookies = cookies.getAll();
  const languageCookie = cookies.get('language');

  return NextResponse.json({
    allCookies,
    languageCookie,
  });
}
</code></pre>
<p>Try accessing the route now:</p>
<pre><code>$ curl --cookie "language=de" localhost:3000/api/task
{"allCookies":[{"name":"language","value":"de"}],"languageCookie":{"name":"language","value":"de"}}
</code></pre>
<p>Similarly you can access the headers of a request:</p>
<pre><code class="language-ts">import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const headers = request.headers;
  const userAgent = headers.get('user-agent');

  return NextResponse.json({
    headers: Array.from(headers),
    userAgent,
  });
}
</code></pre>
<p>Try accessing the route again:</p>
<pre><code>$ curl localhost:3000/api/task
{"headers":[["accept","*/*"],["host","localhost:3000"],["user-agent","curl/7.81.0"],["x-forwarded-for","::ffff:127.0.0.1"],["x-forwarded-host","localhost:3000"],["x-forwarded-port","3000"],["x-forwarded-proto","http"]],"userAgent":"curl/7.81.0"}
</code></pre>
<p>You can have dynamic segments in your route handlers:</p>
<pre><code class="language-ts">import { NextResponse } from 'next/server';

export async function GET(request: Request, { params }: { params: { id: string } }) {
  const id = params.id;

  return NextResponse.json({
    taskId: id,
  });
}
</code></pre>
<p>You can read query params from the <code>nextUrl.searchParams</code> object:</p>
<pre><code class="language-ts">import { NextResponse, type NextRequest } from 'next/server';

export function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const title = searchParams.get('title');
  return NextResponse.json({
    title,
  });
}
</code></pre>
<p>For example:</p>
<pre><code>$ curl "localhost:3000/api/task?title=Title&amp;description=Description"
{"title":"Title"}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="server-and-client-components"><a class="header" href="#server-and-client-components">Server and Client Components</a></h2>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<p>Next.js renders as much as it can on the server.
By default the React components you write are rendered on the server side and the resulting HTML is sent to the browser.
However, not all components can be fully rendered on the server.
For example, components that require interactivity must be partially rendered on the client.</p>
<p>Therefore the rendering is split into multiple stages:</p>
<p>First, Next.js renders as much as it can on the server.</p>
<p>Once the initial HTML is rendered, the client-side JavaScript takes over.
It reconciles the server-rendered HTML with the client-side React tree.</p>
<p>After the reconciliation, the server-rendered HTML is "hydrated".
This stage involves attaching event handlers and setting up necessary state to make the components interactive.</p>
<p>There are several benefits to this approach.</p>
<p>Because the HTML is rendered on the server, you don't get an "empty" HTML page on first load.
Instead, you see some HTML content immediately (albeit not interactive), which improves the user experience and helps with SEO.</p>
<p>Server components can also be cached, which means that repeated requests for the same component are served very fast.
This can significantly improve performance (especially for content that doesn't change a lot).</p>
<p>Data fetching can be moved from the client to the server which can simplify the code and reduce the amount of data that needs to be sent to the client.
This is especially beneficial for clients with slow network speeds.</p>
<p>Additionally, dependencies are now on the server and don't need to be served to the client.
This helps greatly with reducing bundle sizes.</p>
<h3 id="server-components"><a class="header" href="#server-components">Server Components</a></h3>
<p><strong>Server components</strong> are the components that are completely rendered on the server.</p>
<p>For example this component is a server component:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Task() {
  return &lt;p&gt;My task&lt;/p&gt;;
}
</code></pre>
<p>There is no interactivity here, so this component can be rendered on the server completely.</p>
<h3 id="client-components"><a class="header" href="#client-components">Client Components</a></h3>
<p><strong>Client components</strong> are components that are rendered both on the server and on the client.
You use client components when you need interactivity or you need to use certain browser APIs.</p>
<p>You can opt into client components with <code>"use client"</code>.</p>
<p>Consider the following component:</p>
<pre><code class="language-jsx">import * as React from 'react';

export default function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>If you try to go to the corresponding page, you will see an error:</p>
<pre><code>Error: useState only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component
</code></pre>
<p>This is because you can't use <code>useState</code> on the server since you can't store client state there.</p>
<p>To fix the error, we need to add the <code>"use client"</code> directive:</p>
<pre><code class="language-jsx">'use client';

import * as React from 'react';

export default function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can verify that this component is rendered both on the server and the client by adding a <code>console.log</code>:</p>
<pre><code class="language-jsx">'use client';

import * as React from 'react';

export default function Counter() {
  const [count, setCount] = React.useState(0);

  console.log('Rendered counter');

  return (
    &lt;div&gt;
      &lt;p&gt;{count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;+&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>If you go to <code>http://localhost:3000/counter</code>, you will see that the message is output both on the server as well as the client.
If you click the button, you will see that the message is output only on the client (since the component only rerenders there).
However, if you refresh the page, you will observe that the message is again logged both to the server as well as the client.</p>
<h3 id="when-to-use-what"><a class="header" href="#when-to-use-what">When to use what?</a></h3>
<p>Use server components if:</p>
<ul>
<li>you need to fetch data</li>
<li>you need to access a database</li>
<li>you need to keep sensitive information on the server</li>
<li>you want to keep large dependencies on the server</li>
</ul>
<p>Use client components only if:</p>
<ul>
<li>you need event listeners (like <code>onClick</code>)</li>
<li>you need to use <code>useState</code>, <code>useEffect</code> or <code>useReducer</code></li>
<li>you need to use certain browser APIs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-becoming-pretty-with-tailwind-css"><a class="header" href="#chapter-7-becoming-pretty-with-tailwind-css">Chapter 7: Becoming Pretty with Tailwind CSS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Once you've created an app with <code>pnpm create next-app</code> you are already using Tailwind CSS.</p>
<p>The <code>package.json</code> contains these dependencies:</p>
<ul>
<li><code>tailwindcss</code></li>
<li><code>postcss</code></li>
<li><code>autoprefixer</code></li>
</ul>
<p>You also have a <code>tailwind.config.ts</code> file:</p>
<pre><code class="language-ts">import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
};
export default config;
</code></pre>
<p>You also have a <code>postcss.config.js</code>:</p>
<pre><code class="language-js">module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</code></pre>
<p>Add the following content to the <code>globals.css</code> file:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<p>Let's try and use Tailwind.
Recreate the setup we used in chapter 6.1.
Then add a few utility classes to <code>page.tsx</code>:</p>
<pre><code class="language-jsx">export default function Home() {
  return &lt;h1 className="text-3xl font-bold underline"&gt;Welcome&lt;/h1&gt;;
}
</code></pre>
<p>You should see how the styles are applied to the text.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="typography-utilities"><a class="header" href="#typography-utilities">Typography Utilities</a></h2>
<p>Consider the following component:</p>
<pre><code class="language-jsx">export default function Home() {
  return &lt;p&gt;This is a sentence&lt;/p&gt;;
}
</code></pre>
<h3 id="font-family"><a class="header" href="#font-family">Font Family</a></h3>
<p>You can change the font family:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="font-sans"&gt;This uses a sans-serif font&lt;/p&gt;
      &lt;p className="font-serif"&gt;This uses a serif font&lt;/p&gt;
      &lt;p className="font-mono"&gt;This uses a monospace font&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="font-size"><a class="header" href="#font-size">Font Size</a></h3>
<p>You can change the font size:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="text-sm"&gt;This is a small sentence&lt;/p&gt;
      &lt;p className="text-base"&gt;This is a normal sentence&lt;/p&gt;
      &lt;p className="text-lg"&gt;This is a large sentence&lt;/p&gt;
      &lt;p className="text-xl"&gt;This is an extra large sentence&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>You can make your sentences larger than <code>text-xl</code> by prefixing the <code>xl</code> with a number, e.g. <code>text-2xl</code>, <code>text-3xl</code> all the way up <code>text-9xl</code>.</p>
<h3 id="font-weight"><a class="header" href="#font-weight">Font Weight</a></h3>
<p>You can change the font weight:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="font-light"&gt;This sentence is light&lt;/p&gt;
      &lt;p className="font-normal"&gt;This sentence is normal&lt;/p&gt;
      &lt;p className="font-medium"&gt;This sentence is medium&lt;/p&gt;
      &lt;p className="font-semibold"&gt;This sentence is semibold&lt;/p&gt;
      &lt;p className="font-bold"&gt;This sentence is bold&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="line-height"><a class="header" href="#line-height">Line Height</a></h3>
<p>You can also set the line height.
This can be used to control the distance between the lines:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="leading-normal"&gt;
        This is a really, really long sentence that spans multiple lines if you make the window of
        your browser small enough. Just keep resizing the browser window until this text spans
        multiple lines. Then you will be able to see the effect of line height.
      &lt;/p&gt;
      &lt;p className="leading-relaxed"&gt;
        This is a really, really long sentence that spans multiple lines if you make the window of
        your browser small enough. Just keep resizing the browser window until this text spans
        multiple lines. Then you will be able to see the effect of line height.
      &lt;/p&gt;
      &lt;p className="leading-loose"&gt;
        This is a really, really long sentence that spans multiple lines if you make the window of
        your browser small enough. Just keep resizing the browser window until this text spans
        multiple lines. Then you will be able to see the effect of line height.
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>You can also control the line height via <code>leading-{num}</code> utility classes (from <code>leading-3</code> to <code>leading-10</code>).</p>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<p>The text alignment can be set like this:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="text-left"&gt;This text is left-aligned&lt;/p&gt;
      &lt;p className="text-center"&gt;This text is centered&lt;/p&gt;
      &lt;p className="text-right"&gt;This text is right-aligned&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>You can justify text with <code>text-justify</code>.</p>
<h3 id="text-color"><a class="header" href="#text-color">Text Color</a></h3>
<p>You can also set the text color.
These utility classes usually have the form <code>text-{color}-{number}</code>.
The higher the number, the darker the color will be.
The number should be one of the values <code>100</code>, <code>200</code>, <code>300</code> all the way up to <code>900</code>.</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="text-blue-300"&gt;Light blue&lt;/p&gt;
      &lt;p className="text-blue-800"&gt;Dark blue&lt;/p&gt;
      &lt;p className="text-red-300"&gt;Light red&lt;/p&gt;
      &lt;p className="text-red-800"&gt;Dark red&lt;/p&gt;
      &lt;p className="text-green-300"&gt;Light green&lt;/p&gt;
      &lt;p className="text-green-800"&gt;Dark green&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="font-style-and-decoration"><a class="header" href="#font-style-and-decoration">Font Style and Decoration</a></h3>
<p>There are a few additional interesting utility classes for typography.</p>
<p>For example, font style can be controlled with the <code>italic</code> utility:</p>
<pre><code class="language-jsx">export default function Home() {
  return &lt;p className="italic"&gt;This is an italic sentence&lt;/p&gt;;
}
</code></pre>
<p>You can also control text decoration with utilities like <code>underline</code>:</p>
<pre><code class="language-jsx">export default function Home() {
  return &lt;p className="underline"&gt;This text is underlined&lt;/p&gt;;
}
</code></pre>
<p>You can change the text decoration color by using the <code>decoration-{color}-{number}</code> utility classes:</p>
<pre><code class="language-jsx">export default function Home() {
  return &lt;p className="underline decoration-blue-500"&gt;This text has a blue underline&lt;/p&gt;;
}
</code></pre>
<p>And you can even change the decoration style:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;p className="underline decoration-solid"&gt;This text has a solid underline&lt;/p&gt;
      &lt;p className="underline decoration-double"&gt;This text has a double underline&lt;/p&gt;
      &lt;p className="underline decoration-dotted"&gt;This text has a dotted underline&lt;/p&gt;
      &lt;p className="underline decoration-dashed"&gt;This text has a dashed underline&lt;/p&gt;
      &lt;p className="underline decoration-wavy"&gt;This text has a wavy underline&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>You can also change the decoration thickness using one of the <code>decoration-1</code>, <code>decoration-2</code>, <code>decoration-4</code> or <code>decoration-8</code> attributes.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="background-utilities"><a class="header" href="#background-utilities">Background Utilities</a></h2>
<h3 id="background-color"><a class="header" href="#background-color">Background Color</a></h3>
<p>You can change the background color of an element using the <code>bg-{color}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="bg-blue-500"&gt;Blue background&lt;/div&gt;
      &lt;button className="bg-blue-500"&gt;Blue button&lt;/button&gt;
      &lt;p className="bg-blue-500"&gt;Blue paragraph&lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="linear-gradients"><a class="header" href="#linear-gradients">Linear Gradients</a></h3>
<p>You can give elements a linear gradient background using the <code>bg-gradient-{direction}</code> utilities.</p>
<p>First, you specify the direction of the gradient.
For example, you can specify <code>bg-gradient-to-r</code> for "right", <code>bg-gradient-to-t</code> for "top" and more.</p>
<p>Then you specify the starting color via <code>from-{color}-{number}</code> and the end color via <code>to-{color}-{number}</code>.
You can additionally specify a middle color by using <code>via-{color}-{number}</code>.</p>
<p>Here are a few examples:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="bg-gradient-to-r from-blue-500 to-green-500"&gt;
        Right direction, blue to green
      &lt;/div&gt;
      &lt;div className="bg-gradient-to-r from-blue-500 via-yellow-500 to-green-500"&gt;
        Right direction, blue to green, via yellow
      &lt;/div&gt;
      &lt;div className="bg-gradient-to-t from-blue-500 to-green-500"&gt;
        Top direction, blue to green
      &lt;/div&gt;
      &lt;div className="bg-gradient-to-t from-blue-500 to-green-500 via-yellow-500"&gt;
        Top direction, blue to green, via yellow
      &lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="size-utilities"><a class="header" href="#size-utilities">Size Utilities</a></h2>
<p>To actually see that the size utilities work the way, we expect, we will give our elements backgrounds.
Don't be distracted by this.</p>
<h3 id="width"><a class="header" href="#width">Width</a></h3>
<p>You can give an element a fixed width using the <code>w-{number}</code> utilities.
For example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="bg-blue-500 w-24"&gt;Text&lt;/div&gt;
      &lt;div className="bg-blue-500 w-64"&gt;Text&lt;/div&gt;
      &lt;div className="bg-blue-500 w-96"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<blockquote>
<p>Of course, there are many more <code>w-{number}</code> utilities.</p>
</blockquote>
<p>You can give an element a percentage-based width using the <code>w-{fraction}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex"&gt;
      &lt;div className="bg-blue-500 w-1/4"&gt;Text&lt;/div&gt;
      &lt;div className="bg-yellow-500 w-1/4"&gt;Text&lt;/div&gt;
      &lt;div className="bg-green-500 w-1/2"&gt;Text&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use <code>w-screen</code> if you want an element to span the entire viewport width.</p>
<p>You can set the minimum and the maximum width of an elemnent using the <code>min-w-{number}</code> and <code>max-w-{number}</code> attributes.</p>
<h3 id="height"><a class="header" href="#height">Height</a></h3>
<p>You can give an element a fixed height using the <code>h-{number}</code> utilities.
For example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="bg-blue-500 h-24"&gt;Text&lt;/div&gt;
      &lt;div className="bg-yellow-500 h-64"&gt;Text&lt;/div&gt;
      &lt;div className="bg-green-500 h-96"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<blockquote>
<p>Of course, there are many more <code>h-{number}</code> utilities.</p>
</blockquote>
<p>You can use <code>h-screen</code> if you want an element to span the entire viewport height.</p>
<p>You can set the minimum and the maximum height of an elemnent using the <code>min-h-{number}</code> and <code>max-h-{number}</code> attributes.</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>You can set the width and height of an element at the same time using the <code>size-{number}</code> utility classes.
For example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="bg-blue-500 size-24"&gt;Text&lt;/div&gt;
      &lt;div className="bg-yellow-500 size-64"&gt;Text&lt;/div&gt;
      &lt;div className="bg-green-500 size-96"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="border-utilities"><a class="header" href="#border-utilities">Border Utilities</a></h2>
<p>You can use the <code>border</code> attribute to add a border.</p>
<h3 id="border-color"><a class="header" href="#border-color">Border Color</a></h3>
<p>You can use the <code>border-{color}-{number}</code> to control the border element:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500"&gt;Blue border&lt;/div&gt;
      &lt;div className="border border-green-500"&gt;Green border&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="border-width"><a class="header" href="#border-width">Border Width</a></h3>
<p>You can set the border width using the <code>border-{number}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500"&gt;Text&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Text&lt;/div&gt;
      &lt;div className="border-4 border-blue-500"&gt;Text&lt;/div&gt;
      &lt;div className="border-8 border-blue-500"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="border-style"><a class="header" href="#border-style">Border Style</a></h3>
<p>You can use <code>border-{style}</code> to control the border style of an element:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500 border-solid"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 border-dashed"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 border-dotted"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 border-double"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="border-radius"><a class="header" href="#border-radius">Border Radius</a></h3>
<p>You can control the border radius by using utilies like <code>rounded</code>, <code>rounded-md</code>, <code>rounded-lg</code> and <code>rounded-full</code>.</p>
<p>Example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500 bg-blue-500 size-32 border-solid rounded"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 bg-blue-500 size-32 border-solid rounded-md"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 bg-blue-500 size-32 border-solid rounded-lg"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 bg-blue-500 size-32 border-solid rounded-full"&gt;
        Text
      &lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="spacing-utilities"><a class="header" href="#spacing-utilities">Spacing Utilities</a></h2>
<h3 id="padding"><a class="header" href="#padding">Padding</a></h3>
<p>You can control the padding on all sides of an element using the <code>p-{size}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500 size-32 p-2"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 size-32 p-4"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 size-32 p-8"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>You can control the padding on one side of an element using the <code>p{t | r | b | l}-{size}</code> utilities.</p>
<p>For example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500 size-32 pl-4"&gt;Left-padded text&lt;/div&gt;
      &lt;div className="border border-blue-500 size-32 pt-4"&gt;Top-padded text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="margin"><a class="header" href="#margin">Margin</a></h3>
<p>You can control the margin on all sides of an element using the <code>m-{size}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500 size-32 m-2"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 size-32 m-4"&gt;Text&lt;/div&gt;
      &lt;div className="border border-blue-500 size-32 m-8"&gt;Text&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>You can control the margin on one side of an element using the <code>m{t | r | b | l}-{size}</code> utilities.</p>
<p>For example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;&gt;
      &lt;div className="border border-blue-500 size-32 ml-4"&gt;Left margin&lt;/div&gt;
      &lt;div className="border border-blue-500 size-32 mt-4"&gt;Top margin&lt;/div&gt;
    &lt;/&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="flexbox"><a class="header" href="#flexbox">Flexbox</a></h2>
<p>The "flex" feature enables you to control the layout of elements in a one-dimensional space.
You position the elements either as rows or columns.</p>
<h3 id="the-flex-utility-class"><a class="header" href="#the-flex-utility-class">The <code>flex</code> Utility Class</a></h3>
<p>Here is a simple example of a a flex container with 3 elements that are placed horizontally:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex"&gt;
      &lt;div className="size-32 border border-blue-500"&gt;First element&lt;/div&gt;
      &lt;div className="size-32 border border-blue-500"&gt;Second element&lt;/div&gt;
      &lt;div className="size-32 border border-blue-500"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use the <code>flex-col</code> utility class if you want a vertical layout:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex flex-col"&gt;
      &lt;div className="size-32 border border-blue-500"&gt;First element&lt;/div&gt;
      &lt;div className="size-32 border border-blue-500"&gt;Second element&lt;/div&gt;
      &lt;div className="size-32 border border-blue-500"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="flex-basis"><a class="header" href="#flex-basis">Flex Basis</a></h3>
<p>You can use the <code>basis-{size}</code> utilities to set the initial size of flex items:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex"&gt;
      &lt;div className="border border-blue-500 basis-32"&gt;First element&lt;/div&gt;
      &lt;div className="border border-blue-500 basis-32"&gt;Second element&lt;/div&gt;
      &lt;div className="border border-blue-500 basis-64"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can also specify a fraction:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex size-64"&gt;
      &lt;div className="border border-blue-500 basis-1/4"&gt;First element&lt;/div&gt;
      &lt;div className="border border-blue-500 basis-1/4"&gt;Second element&lt;/div&gt;
      &lt;div className="border border-blue-500 basis-1/2"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="flex-wrap"><a class="header" href="#flex-wrap">Flex Wrap</a></h3>
<p>Consider this example:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex w-64"&gt;
      &lt;div className="border border-blue-500 w-32"&gt;First element&lt;/div&gt;
      &lt;div className="border border-blue-500 w-32"&gt;Second element&lt;/div&gt;
      &lt;div className="border border-blue-500 w-32"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>Note that the parent container is too large for the children.
If you want to allow flex items to wrap, you can use <code>flex-wrap</code>:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex flex-wrap w-64"&gt;
      &lt;div className="border border-blue-500 w-32"&gt;First element&lt;/div&gt;
      &lt;div className="border border-blue-500 w-32"&gt;Second element&lt;/div&gt;
      &lt;div className="border border-blue-500 w-32"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>Now the third child element will be placed on the next line.</p>
<h3 id="grow"><a class="header" href="#grow">Grow</a></h3>
<p>You can use <code>grow</code> to tell a flex item to fill all available space:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex w-64"&gt;
      &lt;div className="border border-blue-500 w-16"&gt;First&lt;/div&gt;
      &lt;div className="border border-blue-500 grow"&gt;Second&lt;/div&gt;
      &lt;div className="border border-blue-500 w-16"&gt;Third&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="space-between"><a class="header" href="#space-between">Space Between</a></h3>
<p>You can control horizontal space between elements using <code>space-x-{amount}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex space-x-8"&gt;
      &lt;div className="size-32 bg-blue-500"&gt;First element&lt;/div&gt;
      &lt;div className="size-32 bg-blue-500"&gt;Second element&lt;/div&gt;
      &lt;div className="size-32 bg-blue-500"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can control vertical space between elements using <code>space-y-{amount}</code> utilities:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="flex flex-col space-y-8"&gt;
      &lt;div className="size-32 bg-blue-500"&gt;First element&lt;/div&gt;
      &lt;div className="size-32 bg-blue-500"&gt;Second element&lt;/div&gt;
      &lt;div className="size-32 bg-blue-500"&gt;Third element&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="grid"><a class="header" href="#grid">Grid</a></h2>
<p>Grids allow you to specify two-dimensional layouts.</p>
<h3 id="template-columns"><a class="header" href="#template-columns">Template Columns</a></h3>
<p>You can use the <code>grid</code> and <code>grid-cols-{n}</code> utilities to create a simple grid with a certain number of columns:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-cols-2 size-64"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 2&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use the <code>col-span-{n}</code> utilities to make an element span multiple columns:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-cols-3 size-96"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 3&lt;/div&gt;
      &lt;div className="border-2 border-blue-500 col-span-2"&gt;Row 2, Col 1+2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 3&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use the <code>col-start-{n}</code> and <code>col-end-{n}</code> to start/end an element at the nth grid line.
There are two important caveats here:
First, grid lines start at <code>1</code>, not at <code>0</code>.
Second, the numbers indicate grid <em>lines</em>.</p>
<p>This means that if you want an element to span colummns <code>2</code> and <code>3</code> in a grid, you need to start at grid line <code>2</code> and end at grid line <code>4</code>:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-cols-3 size-96"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 3&lt;/div&gt;
      &lt;div className="border-2 border-blue-500 col-start-2 col-end-4"&gt;Row 2, Col 2+3&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="template-rows"><a class="header" href="#template-rows">Template Rows</a></h3>
<p>You can use the <code>grid</code>, <code>grid-flow-col</code> and <code>grid-rows-{n}</code> utilities to create a simple grid with a certain number of rows:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-flow-col grid-rows-2 size-64"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 3&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 3&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use the <code>row-span-{n}</code> utilities to make an element span multiple rows:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-flow-col grid-rows-3 size-64"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500 row-span-2"&gt;Row 1+2, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 2&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use the <code>row-start-{n}</code> and <code>row-end-{n}</code> to start/end an element at the nth grid line.
The same caveats as with columns apply:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-flow-col grid-rows-3 size-64"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500 row-start-2 row-end-4"&gt;Row 2+3, Col 2&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="gaps"><a class="header" href="#gaps">Gaps</a></h3>
<p>You can use <code>gap-{size}</code> utilities to control the gaps between rows and columns:</p>
<pre><code class="language-jsx">export default function Home() {
  return (
    &lt;div className="grid grid-cols-2 gap-4 size-64"&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 1, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 2, Col 2&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 1&lt;/div&gt;
      &lt;div className="border-2 border-blue-500"&gt;Row 3, Col 2&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>You can use the <code>gap-x-{size}</code> and <code>gap-y-{size}</code> utilities if you need to change the gaps between rows or columns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8-persistence-with-sql"><a class="header" href="#chapter-8-persistence-with-sql">Chapter 8: Persistence with SQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<h2 id="create-a-database"><a class="header" href="#create-a-database">Create a Database</a></h2>
<p>First, we need to create a new database.
For this book, we will use Supabase.</p>
<p>Go to <a href="https://supabase.com">Supabase</a>.
Create a new project, give it a name and select a database password (which you should write down somewhere).</p>
<p>Once you create the new project, go to "Project Settings &gt; Database" and copy past the URI connection string.
Replace <code>[YOUR-PASSWORD]</code> with the password you gave the database in the previous step.</p>
<p>Save the connection string, we will need it in a second.</p>
<h2 id="table-creation"><a class="header" href="#table-creation">Table Creation</a></h2>
<p>Let's also create a table:</p>
<pre><code class="language-sql">create table task (
    id serial primary key,
    title varchar(255) not null,
    description text not null,
    status varchar(255) not null,
    duration integer not null
)
</code></pre>
<p>This table schema defines the columns of the table.
Each column has a name, a data type, an optional constraints.</p>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>The <strong>integer</strong> data type allows you to store integers.</p>
<p>The <strong>float</strong> and <strong>double</strong> data types allow you to store floats and doubles.</p>
<p>The <strong>varchar(num_chat)</strong> data type allows you to store strings with a maximum number of characters.
The <strong>text</strong> data type allows you to store strings of arbitrary length.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>The <strong>primary key</strong> constraint means that the column should be used to identify the rows of the table.</p>
<p>The <strong>not null</strong> means that the inserted value can't be null.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inserting-updating-and-deleting-data"><a class="header" href="#inserting-updating-and-deleting-data">Inserting, Updating and Deleting Data</a></h2>
<h3 id="inserting-data"><a class="header" href="#inserting-data">Inserting Data</a></h3>
<p>To insert rows into a table, you use the <code>insert</code> statement.
Here you need to declare the table to write to, the columns to fill and one or more rows of data to insert:</p>
<pre><code class="language-sql">insert into task (id, title, description, duration, status) VALUES
(1, 'Read the Next.js book', 'Read and understand the Next.js book.', 60, 'In progress'),
(2, 'Write a task app', 'Write an awesome task app.', 0, 'Todo'),
(3, 'Think of a funny joke', 'Come up with a funny joke to lighten the mood.', 120, 'In progress');
</code></pre>
<h3 id="updating-data"><a class="header" href="#updating-data">Updating Data</a></h3>
<p>You can update rows using the <code>update</code> statement.
Here you need to specify which table, which columns and which rows to update:</p>
<pre><code class="language-sql">update task
set status = 'Completed'
where id = 1;
</code></pre>
<h2 id="deleting-data"><a class="header" href="#deleting-data">Deleting Data</a></h2>
<p>You can delete rows using the <code>delete</code> statement.
Here you need to specify which table to use and which rows to remove:</p>
<pre><code class="language-sql">delete from task
where status = 'Completed';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selecting-data"><a class="header" href="#selecting-data">Selecting Data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="multiple-tables"><a class="header" href="#multiple-tables">Multiple Tables</a></h2>
<h3 id="foreign-keys"><a class="header" href="#foreign-keys">Foreign Keys</a></h3>
<p>Let's create a project table:</p>
<pre><code class="language-sql">create table project (
    id serial primary key,
    name varchar(255) not null
);
</code></pre>
<p>Let's add a column to the task table that will store the project ID:</p>
<pre><code class="language-sql">alter table task
add COLUMN project_id integer;
</code></pre>
<p>Finally, we will establish a foreign key relationship:</p>
<pre><code class="language-sql">alter table task
add constraint fk_project
foreign key (project_id)
references project(ID);
</code></pre>
<h3 id="inner-joins"><a class="header" href="#inner-joins">Inner Joins</a></h3>
<p>We can use inner joins to combine data from multiple columns:</p>
<pre><code class="language-sql">select task.id as task_id, task.title, task.status, project.name as project_name
from task
inner join project on task.project_id = project.id;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9-typesafe-sql-with-drizzle"><a class="header" href="#chapter-9-typesafe-sql-with-drizzle">Chapter 9: Typesafe SQL with Drizzle</a></h1>
<p>Drizzle is a TypeScript ORM (object relational mapping).
It allows you to write TypeScript functions that perform database operations in a very similar manner to SQL.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup-3"><a class="header" href="#setup-3">Setup</a></h2>
<h3 id="a-simple-example-1"><a class="header" href="#a-simple-example-1">A Simple Example</a></h3>
<p>Let's create a simple Drizzle script that will declare a task table and read all the tasks from the table.</p>
<p>Create a new supabase database and recreate the task table from the SQL chapter.
Don't add the project IDs yet, that will follow later.</p>
<p>Create a new TypeScript project:</p>
<pre><code class="language-sh">pnpm init
pnpm add typescript tsx --save-dev
pnpm tsc --init
</code></pre>
<p>Install Drizzle:</p>
<pre><code class="language-sh">pnpm add drizzle-orm postgres
pnpm add drizzle-kit --save-dev
</code></pre>
<p>Create the following file <code>demo.ts</code>:</p>
<pre><code class="language-ts">import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

// Paste the supabase URI here
const databaseURI = '...';

// Declare the task table
export const taskTable = pgTable('task', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  description: text('description').notNull(),
  status: text('status').notNull(),
  duration: integer('duration').notNull(),
});

const client = postgres(databaseURI);
const db = drizzle(client);

async function getTasks() {
  return await db.select().from(taskTable);
}

getTasks().then(console.log);
</code></pre>
<p>Execute the file:</p>
<pre><code class="language-sh">pnpm tsx demo.ts
</code></pre>
<p>You will see a list of all the tasks that are currently present in the table.</p>
<h3 id="drizzle-as-typesafe-sql"><a class="header" href="#drizzle-as-typesafe-sql">Drizzle as Typesafe SQL</a></h3>
<p>Did you notice how similar the Drizzle function and the SQL statement are?
The Drizzle function is:</p>
<pre><code class="language-ts">db.select().from(taskTable);
</code></pre>
<p>The SQL function was:</p>
<pre><code class="language-sql">select * from task;
</code></pre>
<p>This similarity is <em>intentional</em> and will be a major theme in this chapter.
Unlike many other frameworks which try to "abstract" SQL away, Drizzle embraces SQL and only adds a bit of type safety on top of it.</p>
<p>If you know SQL, learning Drizzle is a very fast process.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inserting-updating-and-deleting-data-1"><a class="header" href="#inserting-updating-and-deleting-data-1">Inserting, Updating and Deleting Data</a></h2>
<h3 id="inserting-data-1"><a class="header" href="#inserting-data-1">Inserting Data</a></h3>
<p>Inserting data generally looks like this:</p>
<pre><code class="language-ts">await db.insert(table).values(values);
</code></pre>
<p>Here is how you would insert a row into <code>taskTable</code>:</p>
<pre><code class="language-ts">await db.insert(taskTable).values({
  title: 'Read the Next.js book',
  description: 'Read and understand the Next.js book.',
  status: 'In progress',
  duration: 60,
});
</code></pre>
<p>You can insert a row and get it back:</p>
<pre><code class="language-ts">const row = await db
  .insert(taskTable)
  .values({
    name: 'Example project',
  })
  .returning();
</code></pre>
<p>This would return something like:</p>
<pre><code>[ { id: 3, name: 'Example project' } ]
</code></pre>
<p>The <code>returning</code> function is mostly useful if you want to get the ID of the inserted row.</p>
<p>You can insert multiple rows by providing an array of objects:</p>
<pre><code class="language-ts">await db.insert(taskTable).values([
  {
    title: 'Read the Next.js book',
    description: 'Read and understand the Next.js book.',
    status: 'In progress',
    duration: 5000,
  },
  {
    title: 'Write a task app',
    description: 'Write an awesome task app.',
    status: 'Todo',
    duration: 120,
  },
  {
    title: 'Think of a funny joke',
    description: 'Come up with a funny joke to lighten the mood.',
    status: 'In progress',
    duration: 5,
  },
]);
</code></pre>
<h3 id="updating-data-1"><a class="header" href="#updating-data-1">Updating Data</a></h3>
<p>Updating data generally looks like this:</p>
<pre><code class="language-ts">await db.update(table).set(object).where(condition);
</code></pre>
<p>For example, let's say that wanted to set status of the task with the ID <code>1</code> to <code>'Completed'</code>:</p>
<pre><code class="language-ts">await db.update(taskTable).set({ status: 'Completed' }).where(eq(taskTable.id, 1));
</code></pre>
<h3 id="deleting-data-1"><a class="header" href="#deleting-data-1">Deleting Data</a></h3>
<p>Updating data generally looks like this:</p>
<pre><code class="language-ts">await db.delete(table).where(condition);
</code></pre>
<p>For example, here is how you could delete all the completed tasks:</p>
<pre><code class="language-ts">await db.delete(taskTable).where(eq(taskTable.status, 'Completed'));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selecting-data-1"><a class="header" href="#selecting-data-1">Selecting Data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="multiple-tables-1"><a class="header" href="#multiple-tables-1">Multiple Tables</a></h2>
<h3 id="foreign-keys-1"><a class="header" href="#foreign-keys-1">Foreign Keys</a></h3>
<p>Let's recreate the project and task table from the SQL chapter in Drizzle:</p>
<pre><code class="language-ts">const projectTable = pgTable('project', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const taskTable = pgTable("task", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  status: text("status").notNull(),
  projectId: integer('projectId').notNull().references(() =&gt; projectTable.id);
});
</code></pre>
<h3 id="inner-join"><a class="header" href="#inner-join">Inner Join</a></h3>
<p>You can perform an inner join like this:</p>
<pre><code class="language-ts">await db.select().from(projectTable).innerJoin(taskTable, eq(projectTable.id, taskTable.projectId));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<h3 id="why-migrations"><a class="header" href="#why-migrations">Why Migrations?</a></h3>
<p>Quite often, during the course of development an application will have to change.
This will sometimes include the underlying tables in the database.</p>
<p>To manage these changes, Drizzle allows you to create <strong>migrations</strong>, i.e. files that can help you update the table schemas.</p>
<h3 id="creating-your-first-migration"><a class="header" href="#creating-your-first-migration">Creating Your First Migration</a></h3>
<p>Let's consider the task table without the project IDs.</p>
<p>Create a <code>schema.ts</code> file:</p>
<pre><code class="language-ts">import { pgTable, serial, text } from 'drizzle-orm/pg-core';

export const taskTable = pgTable('task', {
  id: serial('id').primaryKey(),
  title: text('name').notNull(),
  description: text('description').notNull(),
  status: text('name').notNull(),
});
</code></pre>
<p>Create a <code>drizzle.config.ts</code> file:</p>
<pre><code class="language-ts">import type { Config } from 'drizzle-kit';

export default {
  schema: './schema.ts',
  out: '.',
  driver: 'pg',
  dbCredentials: {
    connectionString: '$YOUR_DATABASE_URL_HERE',
  },
} satisfies Config;
</code></pre>
<p>Now run:</p>
<pre><code class="language-sh">pnpm drizzle-kit generate:pg
</code></pre>
<p>This will create a <code>meta</code> directory and an SQL file:</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS "task" (
	"id" serial PRIMARY KEY NOT NULL,
	"title" text NOT NULL,
	"description" text NOT NULL,
	"status" text NOT NULL
);
</code></pre>
<p>This SQL file contains the migration.
In this example, running the migration will create a new task table with the columns we would expect.</p>
<h3 id="run-migrations"><a class="header" href="#run-migrations">Run Migrations</a></h3>
<p>Create the <code>migration.ts</code> script:</p>
<pre><code class="language-ts">import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import { migrate } from 'drizzle-orm/postgres-js/migrator';

const databaseURI = '$YOUR_DATABASE_URL_HERE';

const client = postgres(databaseURI, { max: 1 });
const db = drizzle(client);

async function runMigrations() {
  await migrate(db, { migrationsFolder: '.' });
  await client.end();
}

runMigrations().then(console.log).catch(console.error);
</code></pre>
<p>Run the script:</p>
<pre><code class="language-sh">pnpm tsx migrate.ts
</code></pre>
<p>You will see that the table now appears in Supabase.</p>
<h3 id="read-the-database-password-from-environment"><a class="header" href="#read-the-database-password-from-environment">Read the Database Password from Environment</a></h3>
<p>Of course, in real life, we want to avoid hardcoding the database password in our scripts.
Instead, we will read it from an environment variable.</p>
<p>Change the <code>migrations.ts</code> to read the password from <code>process.env.DATABASE_URL</code>:</p>
<pre><code class="language-ts">const databaseURL = process.env.DATABASE_URL;

if (databaseURL === undefined) {
  console.log('You need to provide the database URI');
  process.exit(1);
}
</code></pre>
<p>Do the same thing with <code>drizzle.config.ts</code>:</p>
<pre><code class="language-ts">import type { Config } from 'drizzle-kit';

export default {
  schema: './schema.ts',
  out: '.',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL,
  },
} satisfies Config;
</code></pre>
<p>Now you can run the script again:</p>
<pre><code class="language-sh">export DATABASE_URL=$YOUR_DATABASE_URL_HERE
pnpm tsx migrate.ts
</code></pre>
<p>If you want to get typechecking for <code>process.env</code>, you can install <code>@types/node</code>:</p>
<pre><code class="language-sh">pnpm add --save-dev @types/node
</code></pre>
<p>Alternatively you can read the environment variables from a <code>.env</code> file.
Install <code>dotenv</code>:</p>
<pre><code class="language-sh">pnpm add dotenv
</code></pre>
<p>Create a <code>.env</code> file:</p>
<pre><code>DATABASE_URL=$YOUR_DATABASE_URL_HERE
</code></pre>
<p>Add this to the <code>migrate.ts</code> script:</p>
<pre><code class="language-ts">import dotenv from 'dotenv';
dotenv.config();
</code></pre>
<p>The final migration script now looks like this:</p>
<pre><code class="language-ts">import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import dotenv from 'dotenv';
import { migrate } from 'drizzle-orm/postgres-js/migrator';

dotenv.config();

const databaseURI = process.env.DATABASE_URL;

if (databaseURI === undefined) {
  console.log('You need to provide the database URI');
  process.exit(0);
}

const client = postgres(databaseURI, { max: 1 });
const db = drizzle(client);

async function runMigrations() {
  await migrate(db, { migrationsFolder: '.' });
  await client.end();
}

runMigrations().then(console.log).catch(console.error);
</code></pre>
<p>You can now run:</p>
<pre><code class="language-ts">pnpm tsx migrate.ts
</code></pre>
<p>Note that you no longer need to export <code>DATABASE_URL</code> manually.
Thanks to <code>dotenv</code> the script will simply pick the URL up from the <code>.env</code> file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-10---the-project"><a class="header" href="#chapter-10---the-project">Chapter 10 - The Project</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="setup-4"><a class="header" href="#setup-4">Setup</a></h2>
<h3 id="creating-a-nextjs-project-1"><a class="header" href="#creating-a-nextjs-project-1">Creating a Next.js Project</a></h3>
<p>First, we need to create a new Next.js Project.
Here, we simply follow the steps from the Next.js chapter.</p>
<p>Run the following command to create a new Next.js project:</p>
<pre><code class="language-sh">pnpm create next-app
</code></pre>
<p>Give your project the name <code>easy-opus</code> and select the following options:</p>
<ul>
<li>we want to use TypeScript</li>
<li>we want to use ESLint</li>
<li>we want to use Tailwind CSS</li>
<li>we want to use the <code>src/</code> directory</li>
<li>we want to use the App Router</li>
<li>we don't want to customize the defalt import alias</li>
</ul>
<p>Next, remove all the unneeded code from the generated files.
Note that we specify all paths relative to the <code>src</code> directory.
If you are unsure about where a file should go, you can look at the end of this section, which contains the file tree you should have after the setup is completed.</p>
<p>The file <code>app/layout.tsx</code> should look like this:</p>
<pre><code class="language-jsx">import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: 'Easy Opus',
  description: 'A simple task management application',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;{children}&lt;/body&gt;
    &lt;/html&gt;
  );
}
</code></pre>
<p>The file <code>app/page.tsx</code> should look like this:</p>
<pre><code class="language-jsx">export default function Home() {
  return &lt;h1 className="underline"&gt;Welcome to Easy Opus&lt;/h1&gt;;
}
</code></pre>
<p>The file <code>app/globals.css</code> should look like this:</p>
<pre><code class="language-css">@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<p>Run <code>pnpm dev</code> and check out the page at <code>http://localhost:3000</code>.</p>
<p>Also feel free to delete the SVG files in the <code>public</code> directory.
You should also change (or delete) the <code>favicon</code>.</p>
<h3 id="setup-a-database"><a class="header" href="#setup-a-database">Setup a Database</a></h3>
<p>Just follow the steps from the SQL chapter.</p>
<p>Create a new Supabase project, copy the database URL and create the following <code>.env</code> file:</p>
<pre><code>DATABASE_URL=$YOUR_DATABASE_URL_HERE
</code></pre>
<blockquote>
<p>Of course, you need to specify the actual database URL you copied from Supabase instead of <code>$YOUR_DATABASE_URL_HERE</code>.</p>
</blockquote>
<h3 id="setup-drizzle"><a class="header" href="#setup-drizzle">Setup Drizzle</a></h3>
<p>Next, we need to set up Drizzle.</p>
<p>Install Drizzle and <code>dotenv</code>:</p>
<pre><code class="language-sh">pnpm add drizzle-orm postgres dotenv
pnpm add --save-dev tsx drizzle-kit
</code></pre>
<p>Create a new directory called <code>db</code>.
This is where our database-related files will go.</p>
<blockquote>
<p>Remember that we specify all paths relative to <code>src</code>, i.e. you need to create the <code>db</code> directory in <code>src</code>.</p>
</blockquote>
<p>Now create a directory <code>db/migrations</code>.
This is where we will store our migrations.</p>
<p>Next, we need to create the files needed by Drizzle.
This is very similar to the setup from the Drizzle chapter.</p>
<p>Create a file <code>db/drizzle.config.ts</code>:</p>
<pre><code class="language-ts">import type { Config } from 'drizzle-kit';

export default {
  schema: './src/db/schema.ts',
  out: './src/db/migrations',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
} satisfies Config;
</code></pre>
<p>Here you need to be <em>careful</em>.
The properties <code>schema</code> and <code>out</code> both have to specify the path <em>relative to the root directory of our application</em>.
This is because we will run the migrations from our root directory.</p>
<p>If you set <code>schema</code> to just <code>./schema.ts</code> (or even <code>./db/schema.ts</code>), you will get errors.
Setting the wrong file paths is the most common problem when performing the Drizzle setup, so watch out for that.</p>
<p>Next we create a file <code>db/migrate.ts</code>:</p>
<pre><code class="language-ts">import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import dotenv from 'dotenv';
import { migrate } from 'drizzle-orm/postgres-js/migrator';

dotenv.config();

const databaseURI = process.env.DATABASE_URL;

if (databaseURI === undefined) {
  console.log('You need to provide the database URI');
  process.exit(0);
}

const client = postgres(databaseURI, { max: 1 });
const db = drizzle(client);

async function runMigrations() {
  await migrate(db, { migrationsFolder: './src/db/migrations' });
  await client.end();
}

runMigrations().then(console.log).catch(console.error);
</code></pre>
<p>Again, pay careful attention to the paths.
The migrations folder is path <code>./src/db/migrations</code>, <em>not</em> <code>./migrations</code> or <code>./db/migrations</code>.</p>
<p>Finally, let's create the schema at <code>db/schema.ts</code>:</p>
<pre><code class="language-ts">import { pgTable, serial, text } from 'drizzle-orm/pg-core';

export const taskTable = pgTable('task', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  description: text('description').notNull(),
  status: text('status').notNull(),
});
</code></pre>
<p>If you to run <code>pnpm drizzle-kit generate:pg</code> from the root directory right now, you will get the following error:</p>
<pre><code>No config path provided [...]
</code></pre>
<p>This is because the <code>drizzle.config.ts</code> file is no longer in the root directory.
Therefore we need to manually specify the location of the config file using the <code>--config</code> option:</p>
<pre><code class="language-sh">pnpm drizzle-kit generate:pg --config=src/db/drizzle.config.ts
</code></pre>
<p>The migration file will now appear in <code>db/migrations</code>.</p>
<p>We can now execute the migration:</p>
<pre><code class="language-sh">pnpm tsx src/db/migrate.ts
</code></pre>
<p>To simplify future migrations, we will add the following script to <code>package.json</code>:</p>
<pre><code class="language-json">{
  "scripts": {
    "db:generate": "pnpm drizzle-kit generate:pg --config=src/db/drizzle.config.ts",
    "db:migrate": "pnpm tsx src/db/migrate.ts"
  }
}
</code></pre>
<p>Now all we have to do is to run <code>pnpm db:generate</code> to generate a migration and <code>pnpm db:migrate</code> to execute a migration.</p>
<p>Finally, we create the <code>db/index.ts</code> file which exports the <code>db</code> object.
This allows other files to call database functions:</p>
<pre><code class="language-ts">import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const databaseURL = process.env.DATABASE_URL!;

const client = postgres(databaseURL);
export const db = drizzle(client);
</code></pre>
<h3 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h3>
<p>This is the file structure you should have right now:</p>
<pre><code>├── next.config.mjs
├── next-env.d.ts
├── node_modules
├── package.json
├── pnpm-lock.yaml
├── postcss.config.js
├── README.md
├── src
│   ├── app
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   └── page.tsx
│   └── db
│       ├── drizzle.config.ts
│       ├── index.ts
│       ├── migrate.ts
│       ├── migrations
│       │   ├── 0000_moaning_doctor_doom.sql
│       │   └── meta
│       │       ├── 0000_snapshot.json
│       │       └── _journal.json
│       └── schema.ts
├── tailwind.config.ts
└── tsconfig.json
</code></pre>
<p>You <em>should absolutely understand each and every one of these files</em> if you read the book carefully.</p>
<p>Just to recap:</p>
<p>The <code>README.md</code> file contains basic information about the project.</p>
<p>The <code>package.json</code> file marks the directory as a JavaScript project and contains vital project information such as the name, the dependencies and the scripts of this project.
The <code>pnpm-lock.yaml</code> file is automatically generated by the <code>pnpm</code> package manager and contains a complete list of all dependencies (including nested dependencies).
The <code>node_modules</code> contain the actual dependencies.</p>
<p>The <code>tsconfig.json</code> file marks the directory as a TypeScript project and primarily contains important compiler options for the TypeScript compiler.</p>
<p>The <code>next.config.mjs</code> file contains the configuration that is relevant for Next.js.
The <code>next-env.d.ts</code> file ensures that Next.js types are picked up by the TypeScript compiler.</p>
<p>The <code>tailwind.config.ts</code> file contains the configuration that is relevant for Tailwind CSS.
The <code>postcss.config.js</code> file contains the configuration relevant for PostCSS (which is used by Tailwind CSS).</p>
<p>The file <code>src/app/page.tsx</code> specifies the root page and <code>src/app/layout.tsx</code> specifies the root layout.</p>
<p>The <code>globals.css</code> file specifies global styles - right now it's needed for the Tailwind directives.</p>
<p>The <code>src/db</code> directory contains everything that is related to the database (including the migrations).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="task-page"><a class="header" href="#task-page">Task Page</a></h2>
<h3 id="showing-the-tasks"><a class="header" href="#showing-the-tasks">Showing the Tasks</a></h3>
<p>Let's show all the tasks on the homepage by changing <code>app/page.tsx</code>:</p>
<pre><code class="language-jsx">import { db } from '@/db';
import { taskTable } from '@/db/schema';

export default async function Home() {
  // Get all the tasks from the task table
  const tasks = await db.select().from(taskTable);

  // Render the tasks
  return (
    &lt;&gt;
      {tasks.map((task) =&gt; (
        &lt;div&gt;
          &lt;h3&gt;{task.title}&lt;/h3&gt;
          &lt;p&gt;{task.description}&lt;/p&gt;
          &lt;p&gt;{task.status}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/&gt;
  );
}
</code></pre>
<p>Note that this is a server component, which is why we can directly call a database function in our component.</p>
<p>Let's insert a few tasks into the table:</p>
<pre><code class="language-sql">insert into task (title, description, status) VALUES
('Read the Next.js book', 'Read and understand the Next.js book.', 'In progress'),
('Write a task app', 'Write an awesome task app.', 'Todo'),
('Think of a funny joke', 'Come up with a funny joke to lighten the mood.', 'In progress');
</code></pre>
<p>Refresh the page and you should see the tasks.</p>
<blockquote>
<p>That was really simple, wasn't it?
This is the big advantage of rendering components on the server.
If we would render everything on the client, we would need to create an endpoint, call the endpoint on the client etc.</p>
</blockquote>
<h3 id="adding-the-form"><a class="header" href="#adding-the-form">Adding the Form</a></h3>
<p>Next, we need to add the form for creating a new task.
The form should have an input field for the title and the description of the task.
We will automatically set the status of the task to "In progress" and the task ID will be automatically set by the database.</p>
<p>Let's add the form and write the function that we will pass to <code>onSubmit</code>:</p>
<pre><code class="language-jsx">import { db } from '@/db';
import { taskTable } from '@/db/schema';

export default async function Home() {
  const tasks = await db.select().from(taskTable);

  async function handleSubmit(event) {
    event.preventDefault();
    const title = event.currentTarget.title.value.trim();
    const description = event.currentTarget.description.value.trim();

    await db.insert(taskTable).values({ title, description, status: 'In progress' });
  }

  return (
    &lt;&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
        &lt;input type="text" id="title" name="title" /&gt;
        &lt;label htmlFor="description"&gt;Description:&lt;/label&gt;
        &lt;textarea id="description" name="description" /&gt;
        &lt;button type="submit"&gt;Send&lt;/button&gt;
      &lt;/form&gt;
      {tasks.map((task) =&gt; (
        &lt;p&gt;{`${task.title} (${task.description}) ${task.status}`}&lt;/p&gt;
      ))}
    &lt;/&gt;
  );
}
</code></pre>
<p>Go to the page now and you will get an error:</p>
<pre><code>Error: Event handlers cannot be passed to Client Component props.
  &lt;form onSubmit={function} children=...&gt;
                 ^^^^^^^^^^
If you need interactivity, consider converting part of this to a Client Component.
</code></pre>
<p>This is why it's so important to actually understand what server and client components do.
If you don't know these concepts, you would have a very hard time resolving this error.</p>
<p>For example, maybe you would try to slap a "use client" on top of the component.
Only to get a different error:</p>
<pre><code>./node_modules/.pnpm/postgres@3.4.3/node_modules/postgres/src/connection.js:1:0
Module not found: Can't resolve 'net'

https://nextjs.org/docs/messages/module-not-found

Import trace for requested module:
./node_modules/.pnpm/postgres@3.4.3/node_modules/postgres/src/index.js
./src/db/index.ts
./src/app/page.tsx
</code></pre>
<p>This one is even worse.
Why can't <code>net</code> be resolved?
What even is <code>net</code>?</p>
<p>That won't do.
We need to use our <em>knowledge</em> to fix the problem.</p>
<h3 id="fixing-the-component"><a class="header" href="#fixing-the-component">Fixing the Component</a></h3>
<p>Of course, if you <em>understand</em> the difference between client and server components, the problem is really obvious.
Our form should clearly be a client component since it contains a form submission handler.
However we also need to call the database which should happen on the server.</p>
<p>Therefore we need to extract the form as a client component.
Then we need to extract the task insertion into a server action and call it from the client component.</p>
<p>Let's first extract the form.
Create a new file <code>app/task-form.tsx</code>:</p>
<pre><code class="language-jsx">'use client';

import { insertTask } from '@/db/actions';

export function TaskForm() {
  async function handleSubmit(event) {
    event.preventDefault();
    const title = event.currentTarget.title.value.trim();
    const description = event.currentTarget.description.value.trim();
    await insertTask(title, description);
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
      &lt;input type="text" id="title" name="title" /&gt;
      &lt;label htmlFor="description"&gt;Description:&lt;/label&gt;
      &lt;textarea id="description" name="description" /&gt;
      &lt;button type="submit"&gt;Send&lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>Now create a file <code>db/actions.ts</code> and write the implementation for <code>insertTask</code>.
Don't forget the <code>'use server'</code> directive and the top of the file:</p>
<pre><code class="language-ts">'use server';

import { db } from '.';
import { taskTable } from './schema';

export async function insertTask(title: string, description: string) {
  await db.insert(taskTable).values({ title, description, status: 'In progress' });
}
</code></pre>
<p>Now change the <code>app/page.tsx</code> file to use the <code>TaskForm</code> client component:</p>
<pre><code class="language-jsx">import { db } from '@/db';
import { taskTable } from '@/db/schema';
import { TaskForm } from './task-form';

export default async function Home() {
  const tasks = await db.select().from(taskTable);

  return (
    &lt;&gt;
      &lt;TaskForm /&gt;
      {tasks.map((task) =&gt; (
        &lt;div&gt;
          &lt;h3&gt;{task.title}&lt;/h3&gt;
          &lt;p&gt;{task.description}&lt;/p&gt;
          &lt;p&gt;{task.status}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/&gt;
  );
}
</code></pre>
<p>Voila!
The error no longer appears.</p>
<p>The only problem that is left is that you currently need to manually refresh the page after the task is submitted.
Let's use the Next.js router the refresh the page upon task submission:</p>
<pre><code class="language-jsx">// ...
import { useRouter } from 'next/navigation';

export function TaskForm() {
  const router = useRouter();

  async function handleSubmit(event) {
    // ...
    router.refresh();
  }

  // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="styling-the-task-page"><a class="header" href="#styling-the-task-page">Styling the Task Page</a></h2>
<h3 id="thinking-about-the-style"><a class="header" href="#thinking-about-the-style">Thinking about the Style</a></h3>
<p>Before we style anything, we should establish how the page should look like.
This normally involves thinking about typography, color, spacing as well as establishing a design system and much more.</p>
<p>Since this is only a small example project to tie together the things you've learned we will no go full "UI Design" on you.
However, we will set a few rules:</p>
<ul>
<li>we will go for a standard "blue" look</li>
<li>we will use borders (especially for input fields)</li>
<li>we will use relatively aggressive spacing to separate elements</li>
<li>we will use font size to indicate importance of elements</li>
</ul>
<p>Note that right now we mostly care about UI design in so far as it will make the page <em>usable</em>.
Making it <em>pretty</em> is the subject of other books.</p>
<h3 id="styling-the-form"><a class="header" href="#styling-the-form">Styling the Form</a></h3>
<p>The default styling of the form is so bad, that it's borderline unusable.
Right now, it's not even clear, where we should be typing the title and description.</p>
<p>Here is how the form looks like right now:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit}&gt;
  &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
  &lt;input type="text" id="title" name="title" /&gt;
  &lt;label htmlFor="description"&gt;Description:&lt;/label&gt;
  &lt;textarea id="description" name="description" /&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>First, let's give all the input fields some borders:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit}&gt;
  &lt;label htmlFor="title"&gt;Title:&lt;/label&gt;
  &lt;input type="text" id="title" name="title" className="border border-gray-400" /&gt;
  &lt;label htmlFor="description"&gt;Description:&lt;/label&gt;
  &lt;textarea id="description" name="description" className="border border-gray-400" /&gt;
  &lt;button type="submit"&gt;Send&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>Now we can at least see where to type.</p>
<p>Next, we really need to fix the layout and the spacing of the form.
We want all elements to be below each other:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit} className="flex flex-col"&gt;
  {/*...*/}
&lt;/form&gt;
</code></pre>
<p>Now we fix the problem that the form is too wide:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit} className="... w-64"&gt;
  {/*...*/}
&lt;/form&gt;
</code></pre>
<p>This already looks much better, but there is too little spacing.
Let's fix that:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit} className="... space-y-4"&gt;
  {/*...*/}
&lt;/form&gt;
</code></pre>
<p>Let's also make the button, give it rounded corners and improve the general look &amp; feel a bit:</p>
<pre><code class="language-jsx">&lt;button type="submit" className="text-center bg-blue-500 w-24 text-white p-2 font-bold rounded-md"&gt;
  Add Task
&lt;/button&gt;
</code></pre>
<p>Finally, let's center the form horizontally:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit} className="... mx-auto"&gt;
  {/*...*/}
&lt;/form&gt;
</code></pre>
<p>Let's also add some margin above and below the form:</p>
<pre><code class="language-jsx">&lt;form onSubmit={handleSubmit} className="... my-4"&gt;
  {/*...*/}
&lt;/form&gt;
</code></pre>
<p>Does this look great?
No.</p>
<p>But at least it's usable and the user knows where to enter things.</p>
<h3 id="styling-the-tasks"><a class="header" href="#styling-the-tasks">Styling the Tasks</a></h3>
<p>Currently each task looks like this:</p>
<pre><code class="language-jsx">&lt;div&gt;
  &lt;h3&gt;{task.title}&lt;/h3&gt;
  &lt;p&gt;{task.description}&lt;/p&gt;
  &lt;p&gt;{task.status}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>First, let's create a border around each task for better separation:</p>
<pre><code class="language-jsx">&lt;div className="border border-gray-400"&gt;{/*...*/}&lt;/div&gt;
</code></pre>
<p>Just like the form, the tasks shouldn't take up the entire width:</p>
<pre><code class="language-jsx">&lt;div className="... w-96"&gt;{/*...*/}&lt;/div&gt;
</code></pre>
<p>Let's center everything:</p>
<pre><code class="language-jsx">&lt;div className="... mx-auto"&gt;{/*...*/}&lt;/div&gt;
</code></pre>
<p>Finally, let's add some padding:</p>
<pre><code class="language-jsx">&lt;div className="... p-4"&gt;{/*...*/}&lt;/div&gt;
</code></pre>
<p>Let's also style the task content a bit:</p>
<pre><code class="language-jsx">&lt;div className="border border-gray-400 w-96 mx-auto p-4"&gt;
  &lt;h3 className="text-lg font-bold"&gt;{task.title}&lt;/h3&gt;
  &lt;p&gt;{task.description}&lt;/p&gt;
  &lt;p className="text-sm"&gt;{task.status}&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>Again, it doesn't look pretty, but at least it's functional.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="project-page"><a class="header" href="#project-page">Project Page</a></h2>
<h3 id="creating-the-table"><a class="header" href="#creating-the-table">Creating the Table</a></h3>
<p>Let's add projects to our application.
The idea is simple - tasks belong to projects now and each project might contain multiple tasks.</p>
<p>First, we need to make a change to the schema:</p>
<pre><code class="language-ts">import { integer, pgTable, serial, text } from 'drizzle-orm/pg-core';

export const projectTable = pgTable('project', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

export const taskTable = pgTable('task', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  description: text('description').notNull(),
  status: text('status').notNull(),
  projectId: integer('projectId')
    .notNull()
    .references(() =&gt; projectTable.id),
});
</code></pre>
<p>Next, we need to create a migration:</p>
<pre><code class="language-sh">pnpm db:generate
</code></pre>
<p>This will create a new migration in <code>db/migrations</code>.</p>
<p>If you would try to run the migrations right now, you would see the following error:</p>
<pre><code>PostgresError: column "projectId" of relation "task" contains null values
</code></pre>
<p>This is because we already have tasks and the migration doesn't know what to do with them.
In the real world, we would need to manually change the migration (or make the <code>projectId</code> column nullable).
However, for now we will simply delete the tasks, because we have no real users yet anyway.</p>
<p>Now run the migrations:</p>
<pre><code class="language-sh">pnpm db:migrate
</code></pre>
<h3 id="updating-the-tasks-page"><a class="header" href="#updating-the-tasks-page">Updating the Tasks Page</a></h3>
<p>Let's move the tasks page to <code>app/project/[id]/page.tsx</code>.
Also let's move the task form to <code>app/project/[id]/task-form.tsx</code>.</p>
<p>We will also retrieve the project ID and only show and add tasks for the current project:</p>
<pre><code class="language-jsx">import { db } from '@/db';
import { taskTable } from '@/db/schema';
import { TaskForm } from './task-form';
import { eq } from 'drizzle-orm';

export default async function Project({ params: { id } }: { params: { id: number } }) {
  const tasks = await db.select().from(taskTable).where(eq(taskTable.projectId, id));

  return (
    &lt;&gt;
      &lt;TaskForm projectId={id} /&gt;
      {tasks.map((task) =&gt; (
        &lt;div className="border border-gray-400 w-96 mx-auto p-4"&gt;
          &lt;h3 className="text-lg font-bold"&gt;{task.title}&lt;/h3&gt;
          &lt;p&gt;{task.description}&lt;/p&gt;
          &lt;p className="text-sm"&gt;{task.status}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/&gt;
  );
}
</code></pre>
<p>Update the <code>TaskForm</code>:</p>
<pre><code class="language-ts">export function TaskForm({ projectId }: { projectId: number }) {
  // ...

  async function handleSubmit(event) {
    // ...
    await insertTask(title, description, projectId);
    // ...
  }

  // ...
}
</code></pre>
<p>Update the <code>insertTask</code> function:</p>
<pre><code class="language-ts">export async function insertTask(title: string, description: string, projectId: number) {
  await db.insert(taskTable).values({ title, description, status: 'In progress', projectId });
}
</code></pre>
<h3 id="creating-the-project-page"><a class="header" href="#creating-the-project-page">Creating the Project Page</a></h3>
<p>Add an <code>insertProject</code> function to <code>db/actions.ts</code>:</p>
<pre><code class="language-ts">export async function insertProject(name: string) {
  await db.insert(projectTable).values({ name });
}
</code></pre>
<p>Finally, let's create a <code>ProjectForm</code> in <code>app/project-form.tsx</code>:</p>
<pre><code class="language-jsx">'use client';

import { insertProject } from '@/db/actions';
import { useRouter } from 'next/navigation';

export function ProjectForm() {
  const router = useRouter();

  async function handleSubmit(event) {
    event.preventDefault();
    const name = event.currentTarget.name.value.trim();
    await insertProject(name);
    router.refresh();
  }

  return (
    &lt;form onSubmit={handleSubmit} className="flex flex-col w-64 space-y-4 mx-auto my-4"&gt;
      &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
      &lt;input type="text" id="name" name="name" className="border border-gray-400" /&gt;
      &lt;button
        type="submit"
        className="text-center bg-blue-500 w-24 text-white p-2 font-bold rounded-md"
      &gt;
        Add Project
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
</code></pre>
<p>This duplicates the <code>TaskForm</code> a bit - a good exercise would be to try and use a single component for the project and for the task form.</p>
<p>Then we will create a new <code>app/page.tsx</code> which will contain the projects:</p>
<pre><code class="language-ts">import { db } from '@/db';
import { projectTable } from '@/db/schema';
import { ProjectForm } from './project-form';

export default async function Home() {
  const projects = await db.select().from(projectTable);

  return (
    &lt;&gt;
      &lt;ProjectForm /&gt;
      {projects.map((project) =&gt; (
        &lt;h3 className="border border-gray-400 w-96 mx-auto p-4 text-lg font-bold"&gt;
          {project.name}
        &lt;/h3&gt;
      ))}
    &lt;/&gt;
  );
}
</code></pre>
<p>Now we can add projects.</p>
<h3 id="adding-navigation"><a class="header" href="#adding-navigation">Adding Navigation</a></h3>
<p>Let's make all projects into links, so that we can navigate to the individual project pages:</p>
<pre><code class="language-jsx">&lt;div className="flex flex-col"&gt;
  {projects.map((project) =&gt; (
    &lt;Link
      href={`project/${project.id}`}
      className="border border-gray-400 w-96 mx-auto p-4 text-lg font-bold"
    &gt;
      {project.name}
    &lt;/Link&gt;
  ))}
&lt;/div&gt;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
