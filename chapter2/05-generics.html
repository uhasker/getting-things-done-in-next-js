<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generics</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<div style="text-align: right"> <i> Generics are the invisible hat of the TypeScript sage, fitting the heads of both the giant and the dwarf. <br> — Ancient Chinese proverb </i> </div>
<h3 id="why-generics"><a class="header" href="#why-generics">Why Generics?</a></h3>
<p>Generics allow us to write code that is type-safe, yet independent of specific types.</p>
<p>Consider the example of retrieving the first element of an array:</p>
<pre><code class="language-js">function getFirstElement(arr) {
  return arr[0];
}
</code></pre>
<p>How would we type this?
We could use <code>any</code>:</p>
<pre><code class="language-ts">function getFirstElement(arr: any): any {
  return arr[0];
}
</code></pre>
<p>However using <code>any</code> is—as we already mentioned—a bad idea since we lose all the type information even if we pass in an array of a known type.
For example, all these constants would be inferred to have type <code>any</code>:</p>
<pre><code class="language-ts">const num = getFirstElement([1, 2, 3]);
const str = getFirstElement(['a', 'b', 'c']);
</code></pre>
<p>We also can't use the <code>unknown</code> type since it doesn't permit any operations:</p>
<pre><code class="language-ts">function getFirstElement(arr: unknown) {
  // This will result in a type error
  return arr[0];
}
</code></pre>
<p>We could also make use of <em>function overloads</em> and write something like this:</p>
<pre><code class="language-ts">function getFirstElement(arr: number[]): number;
function getFirstElement(arr: string[]): string;
function getFirstElement(arr: undefined[]): undefined;
// More overloads and implementation here
</code></pre>
<blockquote>
<p>We will not discuss function overloads in more detail as it's out of scope for this book.</p>
</blockquote>
<p>But this obviously gets very tedious and error-prone for most cases.
Instead, TypeScript allows us to use <strong>generics</strong> to specify that some code doesn't depend on the concrete types and only cares about the relation between certain types.</p>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<p>Consider the identity function that simply takes an argument <code>arg</code> and returns it unchanged.
We can use a <strong>type variable</strong> <code>Type</code> and type it like this:</p>
<pre><code class="language-ts">function identity&lt;Type&gt;(arg: Type): Type {
  return arg;
}
</code></pre>
<p>This basically says that the <code>identity</code> function takes an argument of type <code>Type</code> and that its return type is of the same type as the argument.
Now we get proper type inference:</p>
<pre><code class="language-ts">let val = 'Hello, World!';
let val2 = identity&lt;string&gt;(val); // val2 is of type string
</code></pre>
<p>We don't actually have to manually specify the type <code>string</code> when calling the function and can instead rely on the inference capabilities of TypeScript once again:</p>
<pre><code class="language-ts">let val = 'Hello, World!';
let val2 = identity(val); // val2 is of type string
</code></pre>
<blockquote>
<p>There is no single convention for naming type parameters.
Common names include <code>T</code>, <code>Type</code> and <code>TType</code>.
We will stick to the <code>Type</code> convention throughout this book.</p>
</blockquote>
<p>Similarly, we can type the <code>getFirstElement</code> function using type parameters:</p>
<pre><code class="language-ts">function getFirstElement&lt;Type&gt;(arr: Type[]): Type {
  return arr[0];
}

const num = getFirstElement([1, 2, 3]);
const str = getFirstElement(['a', 'b', 'c']);
</code></pre>
<p>Unlike in the <code>getFirstElement</code> example that was typed using <code>any</code>, we now get meaningful type inference.
For example, <code>num</code> will have the type <code>number</code> (instead of <code>any</code>) and <code>str</code> will have the type <code>string</code>.</p>
<p>You can use any number of type parameters you want.
Here is how we could write a correctly annotated <code>map</code> function:</p>
<pre><code class="language-ts">function map&lt;In, Out&gt;(array: In[], f: (value: In) =&gt; Out): Out[] {
  return array.map(f);
}
</code></pre>
<p>Here, we have two type parameters <code>In</code> and <code>Out</code>.
The type parameter <code>In</code> indicates the types of the elements of the original array.
The type parameter <code>Out</code> indicates the types of the elements of the result array.</p>
<p>Note how the type of the parameter <code>f</code> makes uses of both the <code>In</code> and <code>Out</code> parameter types.
This makes sense since <code>f</code> transforms an element of the original array (<code>In</code>) into an element of the result array (<code>Out</code>).</p>
<p>Again, we will get proper type inference:</p>
<pre><code class="language-ts">const arr = map([1, 2, 3, 4], (x) =&gt; x % 2 === 0);
</code></pre>
<p>Here <code>arr</code> will have the type <code>boolean[]</code>.</p>
<h3 id="generic-object-types"><a class="header" href="#generic-object-types">Generic Object Types</a></h3>
<p>Just as with functions, we can use type parameters with objects:</p>
<pre><code class="language-ts">type Box&lt;Type&gt; = {
  content: Type;
};
</code></pre>
<p>Now we can use the <code>Box</code> type with any type:</p>
<pre><code class="language-ts">// Here, box has the type Box&lt;number&gt;
const box = {
  content: 0,
};

// Here, box2 has the type Box&lt;string&gt;
const box2 = {
  content: 'Hello, world!',
};
</code></pre>
<p>We can also use generic functions and objects together:</p>
<pre><code class="language-ts">function extractContent&lt;Type&gt;(box: Box&lt;Type&gt;): Type {
  return box.content;
}
</code></pre>
<h3 id="important-builtin-generics"><a class="header" href="#important-builtin-generics">Important Builtin Generics</a></h3>
<p>Generic object types are often useful for collections (and containers), since collection logic is often independent of the specific item types.
For example, retrieving the first element of an array or finding an element of a set by value using the <code>===</code> operator will work the same way regardless of the types of the array or set elements.</p>
<p>You already learned about generic arrays (note that you can use <code>Array&lt;T&gt;</code> in place of <code>T[]</code>).</p>
<p>If you have an object type where the property keys have a certain known type and the property values have a certain known type, you can use the generic type <code>Record&lt;Key, Value&gt;</code></p>
<pre><code class="language-ts">const ScoreRecord: Record&lt;string, number&gt; = {
  Alice: 50,
  Bob: 60,
  Charlie: 70,
};
</code></pre>
<p>Two other generic data structures that you already know about are sets and maps:</p>
<pre><code class="language-ts">const mySet: Set&lt;number&gt; = new Set([1, 2, 3]);
const myMap: Map&lt;string, number&gt; = new Map([
  ['Item 1', 1],
  ['Item 2', 2],
]);
</code></pre>
<p>This example can also be written like this:</p>
<pre><code class="language-ts">const mySet = new Set&lt;number&gt;([1, 2, 3]);
const myMap = new Map&lt;string, number&gt;([
  ['Item 1', 1],
  ['Item 2', 2],
]);
</code></pre>
<p>One other very important generic type is the <code>Promise&lt;Type&gt;</code> type which is most commonly used to annotate asynchronous functions.
For example, if we have an asynchronous function <code>f</code> that returns a promise that will eventually fulfill with a <code>string</code>, we would annotate it like this:</p>
<pre><code class="language-ts">async function f(): Promise&lt;string&gt; {
  // Implementation here
}
</code></pre>
<h3 id="generic-constraints"><a class="header" href="#generic-constraints">Generic Constraints</a></h3>
<p>Often, we don't want to pass <em>completely arbitrary</em> type parameters.</p>
<p>Consider this example:</p>
<pre><code class="language-ts">function getLength&lt;Type&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<p>This will throw the following error:</p>
<pre><code>index.ts:2:14 - error TS2339: Property 'length' does not exist on type 'Type'.
2   return arg.length;
               ~~~~~~
Found 1 error in index.ts:2
</code></pre>
<p>This makes sense since <code>arg</code> can be of literally any type and there is no guarantee that <code>arg</code> will actually have the property <code>length</code>.
To change this, we need to constrain the type <code>Type</code> and make sure that <code>arg</code> must have the <code>length</code> property:</p>
<pre><code class="language-ts">function getLength&lt;Type extends { length: number }&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>
<p>As usual, we can use a type alias here:</p>
<pre><code class="language-ts">type HasLength = {
  length: number;
};

function printLength&lt;Type extends HasLength&gt;(arg: Type): number {
  return arg.length;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter2/04-union-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter2/06-configuring-typescript.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter2/04-union-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter2/06-configuring-typescript.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
